{"version":3,"sources":["../src/index.ts","../src/storage.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\tgetWallets,\n\tisWalletWithSuiFeatures,\n\tStandardConnectInput,\n\tSuiSignAndExecuteTransactionBlockInput,\n\tSuiSignAndExecuteTransactionBlockOutput,\n\tSuiSignMessageInput,\n\tSuiSignMessageOutput,\n\tSuiSignPersonalMessageInput,\n\tSuiSignPersonalMessageOutput,\n\tSuiSignTransactionBlockInput,\n\tSuiSignTransactionBlockOutput,\n\tWallet,\n\tWalletAccount,\n\tWalletWithSuiFeatures,\n} from '@mysten/wallet-standard';\n\nimport { localStorageAdapter, StorageAdapter } from './storage';\n\nexport * from './storage';\n\nexport const DEFAULT_FEATURES: (keyof WalletWithSuiFeatures['features'])[] = [\n\t'sui:signAndExecuteTransactionBlock',\n];\n\nexport interface WalletKitCoreOptions {\n\tpreferredWallets?: string[];\n\tstorageAdapter?: StorageAdapter;\n\tstorageKey?: string;\n\tfeatures?: string[];\n}\n\nexport enum WalletKitCoreConnectionStatus {\n\tDISCONNECTED = 'DISCONNECTED',\n\tCONNECTING = 'CONNECTING',\n\tCONNECTED = 'CONNECTED',\n\t// TODO: Figure out if this is really a separate status, or is just a piece of state alongside the `disconnected` state:\n\tERROR = 'ERROR',\n}\n\nexport interface InternalWalletKitCoreState {\n\twallets: WalletWithSuiFeatures[];\n\tcurrentWallet: WalletWithSuiFeatures | null;\n\taccounts: readonly WalletAccount[];\n\tcurrentAccount: WalletAccount | null;\n\tstatus: WalletKitCoreConnectionStatus;\n}\n\nexport interface WalletKitCoreState extends InternalWalletKitCoreState {\n\tisConnecting: boolean;\n\tisConnected: boolean;\n\tisError: boolean;\n}\n\ntype OptionalProperties<T extends Record<any, any>, U extends keyof T> = Omit<T, U> &\n\tPartial<Pick<T, U>>;\n\nexport interface WalletKitCore {\n\tautoconnect(): Promise<void>;\n\tgetState(): WalletKitCoreState;\n\tsubscribe(handler: SubscribeHandler): Unsubscribe;\n\tconnect(walletName: string, connectInput?: StandardConnectInput): Promise<void>;\n\tselectAccount(account: WalletAccount): void;\n\tdisconnect(): Promise<void>;\n\t/** @deprecated Use `signPersonalMessage` instead. */\n\tsignMessage(\n\t\tmessageInput: OptionalProperties<SuiSignMessageInput, 'account'>,\n\t): Promise<SuiSignMessageOutput>;\n\tsignPersonalMessage(\n\t\tmessageInput: OptionalProperties<SuiSignPersonalMessageInput, 'account'>,\n\t): Promise<SuiSignPersonalMessageOutput>;\n\tsignTransactionBlock: (\n\t\ttransactionInput: OptionalProperties<SuiSignTransactionBlockInput, 'chain' | 'account'>,\n\t) => Promise<SuiSignTransactionBlockOutput>;\n\tsignAndExecuteTransactionBlock: (\n\t\ttransactionInput: OptionalProperties<\n\t\t\tSuiSignAndExecuteTransactionBlockInput,\n\t\t\t'chain' | 'account'\n\t\t>,\n\t) => Promise<SuiSignAndExecuteTransactionBlockOutput>;\n}\n\nexport type SubscribeHandler = (state: WalletKitCoreState) => void;\nexport type Unsubscribe = () => void;\n\nconst SUI_WALLET_NAME = 'Sui Wallet';\n\nconst RECENT_WALLET_STORAGE = 'wallet-kit:last-wallet';\n\nfunction waitToBeVisible() {\n\tif (!document || document.visibilityState === 'visible') {\n\t\treturn Promise.resolve();\n\t}\n\tlet promiseResolve: (() => void) | null = null;\n\tconst promise = new Promise<void>((r) => (promiseResolve = r));\n\tconst callback = () => {\n\t\tif (promiseResolve && document.visibilityState === 'visible') {\n\t\t\tpromiseResolve();\n\t\t\tdocument.removeEventListener('visibilitychange', callback);\n\t\t}\n\t};\n\tdocument.addEventListener('visibilitychange', callback);\n\treturn promise;\n}\n\nfunction sortWallets(\n\twallets: readonly Wallet[],\n\tpreferredWallets: string[],\n\tfeatures?: string[],\n): WalletWithSuiFeatures[] {\n\tconst suiWallets = wallets.filter((wallet) =>\n\t\tisWalletWithSuiFeatures(wallet, features),\n\t) as WalletWithSuiFeatures[];\n\n\treturn [\n\t\t// Preferred wallets, in order:\n\t\t...(preferredWallets\n\t\t\t.map((name) => suiWallets.find((wallet) => wallet.name === name))\n\t\t\t.filter(Boolean) as WalletWithSuiFeatures[]),\n\n\t\t// Wallets in default order:\n\t\t...suiWallets.filter((wallet) => !preferredWallets.includes(wallet.name)),\n\t];\n}\n\nexport function createWalletKitCore({\n\tpreferredWallets = [SUI_WALLET_NAME],\n\tstorageAdapter = localStorageAdapter,\n\tstorageKey = RECENT_WALLET_STORAGE,\n\tfeatures = DEFAULT_FEATURES,\n}: WalletKitCoreOptions): WalletKitCore {\n\tconst registeredWallets = getWallets();\n\tlet wallets = registeredWallets.get();\n\n\tconst subscriptions: Set<(state: WalletKitCoreState) => void> = new Set();\n\tlet walletEventUnsubscribe: (() => void) | null = null;\n\n\tlet internalState: InternalWalletKitCoreState = {\n\t\taccounts: [],\n\t\tcurrentAccount: null,\n\t\twallets: sortWallets(wallets, preferredWallets, features),\n\t\tcurrentWallet: null,\n\t\tstatus: WalletKitCoreConnectionStatus.DISCONNECTED,\n\t};\n\n\tconst computeState = () => ({\n\t\t...internalState,\n\t\tisConnecting: internalState.status === WalletKitCoreConnectionStatus.CONNECTING,\n\t\tisConnected: internalState.status === WalletKitCoreConnectionStatus.CONNECTED,\n\t\tisError: internalState.status === WalletKitCoreConnectionStatus.ERROR,\n\t});\n\n\tlet state = computeState();\n\n\tfunction setState(nextInternalState: Partial<InternalWalletKitCoreState>) {\n\t\tinternalState = {\n\t\t\t...internalState,\n\t\t\t...nextInternalState,\n\t\t};\n\t\tstate = computeState();\n\t\tsubscriptions.forEach((handler) => {\n\t\t\ttry {\n\t\t\t\thandler(state);\n\t\t\t} catch {\n\t\t\t\t/* ignore error */\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction disconnected() {\n\t\tif (walletEventUnsubscribe) {\n\t\t\twalletEventUnsubscribe();\n\t\t\twalletEventUnsubscribe = null;\n\t\t}\n\t\tsetState({\n\t\t\tstatus: WalletKitCoreConnectionStatus.DISCONNECTED,\n\t\t\taccounts: [],\n\t\t\tcurrentAccount: null,\n\t\t\tcurrentWallet: null,\n\t\t});\n\t}\n\n\tconst handleWalletsChanged = () => {\n\t\tsetState({\n\t\t\twallets: sortWallets(registeredWallets.get(), preferredWallets, features),\n\t\t});\n\t};\n\n\tregisteredWallets.on('register', handleWalletsChanged);\n\tregisteredWallets.on('unregister', handleWalletsChanged);\n\n\tconst walletKit: WalletKitCore = {\n\t\tasync autoconnect() {\n\t\t\tif (state.currentWallet) return;\n\t\t\tawait waitToBeVisible();\n\t\t\ttry {\n\t\t\t\tconst lastWalletName = await storageAdapter.get(storageKey);\n\t\t\t\tif (lastWalletName) {\n\t\t\t\t\twalletKit.connect(lastWalletName, { silent: true });\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t/* ignore error */\n\t\t\t}\n\t\t},\n\n\t\tgetState() {\n\t\t\treturn state;\n\t\t},\n\n\t\tsubscribe(handler) {\n\t\t\tsubscriptions.add(handler);\n\n\t\t\t// Immediately invoke the handler with the current state to make it compatible with Svelte stores:\n\t\t\ttry {\n\t\t\t\thandler(state);\n\t\t\t} catch {\n\t\t\t\t/* ignore error */\n\t\t\t}\n\n\t\t\treturn () => {\n\t\t\t\tsubscriptions.delete(handler);\n\t\t\t};\n\t\t},\n\n\t\tselectAccount(account) {\n\t\t\tif (account === internalState.currentAccount || !internalState.accounts.includes(account)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsetState({\n\t\t\t\tcurrentAccount: account,\n\t\t\t});\n\t\t},\n\n\t\tasync connect(walletName, connectInput) {\n\t\t\tconst currentWallet =\n\t\t\t\tinternalState.wallets.find((wallet) => wallet.name === walletName) ?? null;\n\n\t\t\t// TODO: Should the current wallet actually be set before we successfully connect to it?\n\t\t\tsetState({ currentWallet });\n\n\t\t\tif (currentWallet) {\n\t\t\t\tif (walletEventUnsubscribe) {\n\t\t\t\t\twalletEventUnsubscribe();\n\t\t\t\t}\n\t\t\t\twalletEventUnsubscribe = currentWallet.features['standard:events'].on(\n\t\t\t\t\t'change',\n\t\t\t\t\t({ accounts, features, chains }) => {\n\t\t\t\t\t\t// TODO: Handle features or chains changing.\n\t\t\t\t\t\tif (accounts) {\n\t\t\t\t\t\t\tsetState({\n\t\t\t\t\t\t\t\taccounts,\n\t\t\t\t\t\t\t\tcurrentAccount:\n\t\t\t\t\t\t\t\t\tinternalState.currentAccount &&\n\t\t\t\t\t\t\t\t\t!accounts.find(({ address }) => address === internalState.currentAccount?.address)\n\t\t\t\t\t\t\t\t\t\t? accounts[0]\n\t\t\t\t\t\t\t\t\t\t: internalState.currentAccount,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\ttry {\n\t\t\t\t\tsetState({ status: WalletKitCoreConnectionStatus.CONNECTING });\n\t\t\t\t\tawait currentWallet.features['standard:connect'].connect(connectInput);\n\t\t\t\t\tsetState({ status: WalletKitCoreConnectionStatus.CONNECTED });\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait storageAdapter.set(storageKey, currentWallet.name);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t/* ignore error */\n\t\t\t\t\t}\n\n\t\t\t\t\tsetState({\n\t\t\t\t\t\taccounts: currentWallet.accounts,\n\t\t\t\t\t\tcurrentAccount: currentWallet.accounts[0] ?? null,\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.log('Wallet connection error', e);\n\n\t\t\t\t\tsetState({ status: WalletKitCoreConnectionStatus.ERROR });\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsetState({ status: WalletKitCoreConnectionStatus.DISCONNECTED });\n\t\t\t}\n\t\t},\n\n\t\tasync disconnect() {\n\t\t\tif (!internalState.currentWallet) {\n\t\t\t\tconsole.warn('Attempted to `disconnect` but no wallet was connected.');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tawait storageAdapter.del(storageKey);\n\t\t\t} catch {\n\t\t\t\t/* ignore error */\n\t\t\t}\n\t\t\tawait internalState.currentWallet.features['standard:disconnect']?.disconnect();\n\t\t\tdisconnected();\n\t\t},\n\n\t\t/** @deprecated Use `signPersonalMessage` instead. */\n\t\tsignMessage(messageInput) {\n\t\t\tif (!internalState.currentWallet || !internalState.currentAccount) {\n\t\t\t\tthrow new Error('No wallet is currently connected, cannot call `signMessage`.');\n\t\t\t}\n\n\t\t\tif (!internalState.currentWallet.features['sui:signMessage']) {\n\t\t\t\tthrow new Error('Wallet does not support deprecated `signMessage` method.');\n\t\t\t}\n\n\t\t\treturn internalState.currentWallet.features['sui:signMessage'].signMessage({\n\t\t\t\t...messageInput,\n\t\t\t\taccount: messageInput.account ?? internalState.currentAccount,\n\t\t\t});\n\t\t},\n\n\t\tsignPersonalMessage(messageInput) {\n\t\t\tif (!internalState.currentWallet || !internalState.currentAccount) {\n\t\t\t\tthrow new Error('No wallet is currently connected, cannot call `signPersonalMessage`.');\n\t\t\t}\n\n\t\t\tif (!internalState.currentWallet.features['sui:signPersonalMessage']) {\n\t\t\t\tthrow new Error('Wallet does not support the new `signPersonalMessage` method.');\n\t\t\t}\n\n\t\t\treturn internalState.currentWallet.features['sui:signPersonalMessage'].signPersonalMessage({\n\t\t\t\t...messageInput,\n\t\t\t\taccount: messageInput.account ?? internalState.currentAccount,\n\t\t\t});\n\t\t},\n\n\t\tasync signTransactionBlock(transactionInput) {\n\t\t\tif (!internalState.currentWallet || !internalState.currentAccount) {\n\t\t\t\tthrow new Error('No wallet is currently connected, cannot call `signTransaction`.');\n\t\t\t}\n\t\t\tconst {\n\t\t\t\taccount = internalState.currentAccount,\n\t\t\t\tchain = internalState.currentAccount.chains[0],\n\t\t\t} = transactionInput;\n\t\t\tif (!chain) {\n\t\t\t\tthrow new Error('Missing chain');\n\t\t\t}\n\t\t\treturn internalState.currentWallet.features['sui:signTransactionBlock'].signTransactionBlock({\n\t\t\t\t...transactionInput,\n\t\t\t\taccount,\n\t\t\t\tchain,\n\t\t\t});\n\t\t},\n\n\t\tasync signAndExecuteTransactionBlock(transactionInput) {\n\t\t\tif (!internalState.currentWallet || !internalState.currentAccount) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'No wallet is currently connected, cannot call `signAndExecuteTransactionBlock`.',\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst {\n\t\t\t\taccount = internalState.currentAccount,\n\t\t\t\tchain = internalState.currentAccount.chains[0],\n\t\t\t} = transactionInput;\n\n\t\t\tif (!chain) {\n\t\t\t\tthrow new Error('Missing chain');\n\t\t\t}\n\n\t\t\treturn internalState.currentWallet.features[\n\t\t\t\t'sui:signAndExecuteTransactionBlock'\n\t\t\t].signAndExecuteTransactionBlock({\n\t\t\t\t...transactionInput,\n\t\t\t\taccount,\n\t\t\t\tchain,\n\t\t\t});\n\t\t},\n\t};\n\n\treturn walletKit;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface StorageAdapter {\n\tset(key: string, value: string): Promise<void>;\n\tget(key: string): Promise<string | undefined | null>;\n\tdel(key: string): Promise<void>;\n}\n\nexport const localStorageAdapter: StorageAdapter = {\n\tasync set(key, value) {\n\t\treturn localStorage.setItem(key, value);\n\t},\n\tasync get(key) {\n\t\treturn localStorage.getItem(key);\n\t},\n\tasync del(key) {\n\t\tlocalStorage.removeItem(key);\n\t},\n};\n\nexport const noopStorageAdapter: StorageAdapter = {\n\tasync set() {},\n\tasync get() {\n\t\treturn null;\n\t},\n\tasync del() {},\n};\n"],"mappings":"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","names":["WalletKitCoreConnectionStatus","features"]}