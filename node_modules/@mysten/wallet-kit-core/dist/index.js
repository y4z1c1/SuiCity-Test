"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DEFAULT_FEATURES: () => DEFAULT_FEATURES,
  WalletKitCoreConnectionStatus: () => WalletKitCoreConnectionStatus,
  createWalletKitCore: () => createWalletKitCore,
  localStorageAdapter: () => localStorageAdapter,
  noopStorageAdapter: () => noopStorageAdapter
});
module.exports = __toCommonJS(src_exports);
var import_wallet_standard = require("@mysten/wallet-standard");

// src/storage.ts
var localStorageAdapter = {
  async set(key, value) {
    return localStorage.setItem(key, value);
  },
  async get(key) {
    return localStorage.getItem(key);
  },
  async del(key) {
    localStorage.removeItem(key);
  }
};
var noopStorageAdapter = {
  async set() {
  },
  async get() {
    return null;
  },
  async del() {
  }
};

// src/index.ts
var DEFAULT_FEATURES = [
  "sui:signAndExecuteTransactionBlock"
];
var WalletKitCoreConnectionStatus = /* @__PURE__ */ ((WalletKitCoreConnectionStatus2) => {
  WalletKitCoreConnectionStatus2["DISCONNECTED"] = "DISCONNECTED";
  WalletKitCoreConnectionStatus2["CONNECTING"] = "CONNECTING";
  WalletKitCoreConnectionStatus2["CONNECTED"] = "CONNECTED";
  WalletKitCoreConnectionStatus2["ERROR"] = "ERROR";
  return WalletKitCoreConnectionStatus2;
})(WalletKitCoreConnectionStatus || {});
var SUI_WALLET_NAME = "Sui Wallet";
var RECENT_WALLET_STORAGE = "wallet-kit:last-wallet";
function waitToBeVisible() {
  if (!document || document.visibilityState === "visible") {
    return Promise.resolve();
  }
  let promiseResolve = null;
  const promise = new Promise((r) => promiseResolve = r);
  const callback = () => {
    if (promiseResolve && document.visibilityState === "visible") {
      promiseResolve();
      document.removeEventListener("visibilitychange", callback);
    }
  };
  document.addEventListener("visibilitychange", callback);
  return promise;
}
function sortWallets(wallets, preferredWallets, features) {
  const suiWallets = wallets.filter(
    (wallet) => (0, import_wallet_standard.isWalletWithSuiFeatures)(wallet, features)
  );
  return [
    // Preferred wallets, in order:
    ...preferredWallets.map((name) => suiWallets.find((wallet) => wallet.name === name)).filter(Boolean),
    // Wallets in default order:
    ...suiWallets.filter((wallet) => !preferredWallets.includes(wallet.name))
  ];
}
function createWalletKitCore({
  preferredWallets = [SUI_WALLET_NAME],
  storageAdapter = localStorageAdapter,
  storageKey = RECENT_WALLET_STORAGE,
  features = DEFAULT_FEATURES
}) {
  const registeredWallets = (0, import_wallet_standard.getWallets)();
  let wallets = registeredWallets.get();
  const subscriptions = /* @__PURE__ */ new Set();
  let walletEventUnsubscribe = null;
  let internalState = {
    accounts: [],
    currentAccount: null,
    wallets: sortWallets(wallets, preferredWallets, features),
    currentWallet: null,
    status: "DISCONNECTED" /* DISCONNECTED */
  };
  const computeState = () => ({
    ...internalState,
    isConnecting: internalState.status === "CONNECTING" /* CONNECTING */,
    isConnected: internalState.status === "CONNECTED" /* CONNECTED */,
    isError: internalState.status === "ERROR" /* ERROR */
  });
  let state = computeState();
  function setState(nextInternalState) {
    internalState = {
      ...internalState,
      ...nextInternalState
    };
    state = computeState();
    subscriptions.forEach((handler) => {
      try {
        handler(state);
      } catch {
      }
    });
  }
  function disconnected() {
    if (walletEventUnsubscribe) {
      walletEventUnsubscribe();
      walletEventUnsubscribe = null;
    }
    setState({
      status: "DISCONNECTED" /* DISCONNECTED */,
      accounts: [],
      currentAccount: null,
      currentWallet: null
    });
  }
  const handleWalletsChanged = () => {
    setState({
      wallets: sortWallets(registeredWallets.get(), preferredWallets, features)
    });
  };
  registeredWallets.on("register", handleWalletsChanged);
  registeredWallets.on("unregister", handleWalletsChanged);
  const walletKit = {
    async autoconnect() {
      if (state.currentWallet)
        return;
      await waitToBeVisible();
      try {
        const lastWalletName = await storageAdapter.get(storageKey);
        if (lastWalletName) {
          walletKit.connect(lastWalletName, { silent: true });
        }
      } catch {
      }
    },
    getState() {
      return state;
    },
    subscribe(handler) {
      subscriptions.add(handler);
      try {
        handler(state);
      } catch {
      }
      return () => {
        subscriptions.delete(handler);
      };
    },
    selectAccount(account) {
      if (account === internalState.currentAccount || !internalState.accounts.includes(account)) {
        return;
      }
      setState({
        currentAccount: account
      });
    },
    async connect(walletName, connectInput) {
      const currentWallet = internalState.wallets.find((wallet) => wallet.name === walletName) ?? null;
      setState({ currentWallet });
      if (currentWallet) {
        if (walletEventUnsubscribe) {
          walletEventUnsubscribe();
        }
        walletEventUnsubscribe = currentWallet.features["standard:events"].on(
          "change",
          ({ accounts, features: features2, chains }) => {
            if (accounts) {
              setState({
                accounts,
                currentAccount: internalState.currentAccount && !accounts.find(({ address }) => address === internalState.currentAccount?.address) ? accounts[0] : internalState.currentAccount
              });
            }
          }
        );
        try {
          setState({ status: "CONNECTING" /* CONNECTING */ });
          await currentWallet.features["standard:connect"].connect(connectInput);
          setState({ status: "CONNECTED" /* CONNECTED */ });
          try {
            await storageAdapter.set(storageKey, currentWallet.name);
          } catch {
          }
          setState({
            accounts: currentWallet.accounts,
            currentAccount: currentWallet.accounts[0] ?? null
          });
        } catch (e) {
          console.log("Wallet connection error", e);
          setState({ status: "ERROR" /* ERROR */ });
        }
      } else {
        setState({ status: "DISCONNECTED" /* DISCONNECTED */ });
      }
    },
    async disconnect() {
      if (!internalState.currentWallet) {
        console.warn("Attempted to `disconnect` but no wallet was connected.");
        return;
      }
      try {
        await storageAdapter.del(storageKey);
      } catch {
      }
      await internalState.currentWallet.features["standard:disconnect"]?.disconnect();
      disconnected();
    },
    /** @deprecated Use `signPersonalMessage` instead. */
    signMessage(messageInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error("No wallet is currently connected, cannot call `signMessage`.");
      }
      if (!internalState.currentWallet.features["sui:signMessage"]) {
        throw new Error("Wallet does not support deprecated `signMessage` method.");
      }
      return internalState.currentWallet.features["sui:signMessage"].signMessage({
        ...messageInput,
        account: messageInput.account ?? internalState.currentAccount
      });
    },
    signPersonalMessage(messageInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error("No wallet is currently connected, cannot call `signPersonalMessage`.");
      }
      if (!internalState.currentWallet.features["sui:signPersonalMessage"]) {
        throw new Error("Wallet does not support the new `signPersonalMessage` method.");
      }
      return internalState.currentWallet.features["sui:signPersonalMessage"].signPersonalMessage({
        ...messageInput,
        account: messageInput.account ?? internalState.currentAccount
      });
    },
    async signTransactionBlock(transactionInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error("No wallet is currently connected, cannot call `signTransaction`.");
      }
      const {
        account = internalState.currentAccount,
        chain = internalState.currentAccount.chains[0]
      } = transactionInput;
      if (!chain) {
        throw new Error("Missing chain");
      }
      return internalState.currentWallet.features["sui:signTransactionBlock"].signTransactionBlock({
        ...transactionInput,
        account,
        chain
      });
    },
    async signAndExecuteTransactionBlock(transactionInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error(
          "No wallet is currently connected, cannot call `signAndExecuteTransactionBlock`."
        );
      }
      const {
        account = internalState.currentAccount,
        chain = internalState.currentAccount.chains[0]
      } = transactionInput;
      if (!chain) {
        throw new Error("Missing chain");
      }
      return internalState.currentWallet.features["sui:signAndExecuteTransactionBlock"].signAndExecuteTransactionBlock({
        ...transactionInput,
        account,
        chain
      });
    }
  };
  return walletKit;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DEFAULT_FEATURES,
  WalletKitCoreConnectionStatus,
  createWalletKitCore,
  localStorageAdapter,
  noopStorageAdapter
});
//# sourceMappingURL=index.js.map