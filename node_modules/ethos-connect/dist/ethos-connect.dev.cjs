var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = {exports: {}}).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/base-x/src/index.js"(exports, module2) {
    "use strict";
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    module2.exports = base;
  }
});

// node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/bs58/index.js"(exports, module2) {
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module2.exports = basex(ALPHABET);
  }
});

// node_modules/@mysten/bcs/dist/index.js
var require_dist = __commonJS({
  "node_modules/@mysten/bcs/dist/index.js"(exports, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", {value: mod, enumerable: true}) : target, mod));
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var src_exports = {};
    __export2(src_exports, {
      BCS: () => BCS,
      BcsReader: () => BcsReader,
      BcsWriter: () => BcsWriter,
      decodeStr: () => decodeStr,
      encodeStr: () => encodeStr,
      fromB58: () => fromB58,
      fromB64: () => fromB64,
      fromHEX: () => fromHEX,
      getRustConfig: () => getRustConfig,
      getSuiMoveConfig: () => getSuiMoveConfig,
      registerPrimitives: () => registerPrimitives,
      splitGenericParameters: () => splitGenericParameters,
      toB58: () => toB58,
      toB64: () => toB64,
      toHEX: () => toHEX
    });
    module2.exports = __toCommonJS(src_exports);
    function b64ToUint6(nChr) {
      return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
    }
    function fromB64(sBase64, nBlocksSize) {
      var sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, ""), nInLen = sB64Enc.length, nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, taBytes = new Uint8Array(nOutLen);
      for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
        nMod4 = nInIdx & 3;
        nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);
        if (nMod4 === 3 || nInLen - nInIdx === 1) {
          for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
            taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
          }
          nUint24 = 0;
        }
      }
      return taBytes;
    }
    function uint6ToB64(nUint6) {
      return nUint6 < 26 ? nUint6 + 65 : nUint6 < 52 ? nUint6 + 71 : nUint6 < 62 ? nUint6 - 4 : nUint6 === 62 ? 43 : nUint6 === 63 ? 47 : 65;
    }
    function toB64(aBytes) {
      var nMod3 = 2, sB64Enc = "";
      for (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {
        nMod3 = nIdx % 3;
        nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);
        if (nMod3 === 2 || aBytes.length - nIdx === 1) {
          sB64Enc += String.fromCodePoint(uint6ToB64(nUint24 >>> 18 & 63), uint6ToB64(nUint24 >>> 12 & 63), uint6ToB64(nUint24 >>> 6 & 63), uint6ToB64(nUint24 & 63));
          nUint24 = 0;
        }
      }
      return sB64Enc.slice(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? "" : nMod3 === 1 ? "=" : "==");
    }
    function fromHEX(hexStr) {
      const normalized = hexStr.startsWith("0x") ? hexStr.slice(2) : hexStr;
      const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;
      const intArr = padded.match(/.{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];
      return Uint8Array.from(intArr);
    }
    function toHEX(bytes) {
      return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
    }
    var import_bs58 = __toESM(require_bs58());
    var SUI_ADDRESS_LENGTH = 32;
    function toLittleEndian(bigint, size) {
      let result = new Uint8Array(size);
      let i = 0;
      while (bigint > 0) {
        result[i] = Number(bigint % BigInt(256));
        bigint = bigint / BigInt(256);
        i += 1;
      }
      return result;
    }
    var toB58 = (buffer) => import_bs58.default.encode(buffer);
    var fromB58 = (str) => import_bs58.default.decode(str);
    var BcsReader = class {
      constructor(data) {
        this.bytePosition = 0;
        this.dataView = new DataView(data.buffer);
      }
      shift(bytes) {
        this.bytePosition += bytes;
        return this;
      }
      read8() {
        let value = this.dataView.getUint8(this.bytePosition);
        this.shift(1);
        return value;
      }
      read16() {
        let value = this.dataView.getUint16(this.bytePosition, true);
        this.shift(2);
        return value;
      }
      read32() {
        let value = this.dataView.getUint32(this.bytePosition, true);
        this.shift(4);
        return value;
      }
      read64() {
        let value1 = this.read32();
        let value2 = this.read32();
        let result = value2.toString(16) + value1.toString(16).padStart(8, "0");
        return BigInt("0x" + result).toString(10);
      }
      read128() {
        let value1 = BigInt(this.read64());
        let value2 = BigInt(this.read64());
        let result = value2.toString(16) + value1.toString(16).padStart(16, "0");
        return BigInt("0x" + result).toString(10);
      }
      read256() {
        let value1 = BigInt(this.read128());
        let value2 = BigInt(this.read128());
        let result = value2.toString(16) + value1.toString(16).padStart(32, "0");
        return BigInt("0x" + result).toString(10);
      }
      readBytes(num) {
        let start = this.bytePosition + this.dataView.byteOffset;
        let value = new Uint8Array(this.dataView.buffer, start, num);
        this.shift(num);
        return value;
      }
      readULEB() {
        let start = this.bytePosition + this.dataView.byteOffset;
        let buffer = new Uint8Array(this.dataView.buffer, start);
        let {value, length} = ulebDecode(buffer);
        this.shift(length);
        return value;
      }
      readVec(cb) {
        let length = this.readULEB();
        let result = [];
        for (let i = 0; i < length; i++) {
          result.push(cb(this, i, length));
        }
        return result;
      }
    };
    var BcsWriter = class {
      constructor({size = 1024, maxSize, allocateSize = 1024} = {}) {
        this.bytePosition = 0;
        this.size = size;
        this.maxSize = maxSize || size;
        this.allocateSize = allocateSize;
        this.dataView = new DataView(new ArrayBuffer(size));
      }
      ensureSizeOrGrow(bytes) {
        const requiredSize = this.bytePosition + bytes;
        if (requiredSize > this.size) {
          const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);
          if (requiredSize > nextSize) {
            throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`);
          }
          this.size = nextSize;
          const nextBuffer = new ArrayBuffer(this.size);
          new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
          this.dataView = new DataView(nextBuffer);
        }
      }
      shift(bytes) {
        this.bytePosition += bytes;
        return this;
      }
      write8(value) {
        this.ensureSizeOrGrow(1);
        this.dataView.setUint8(this.bytePosition, Number(value));
        return this.shift(1);
      }
      write16(value) {
        this.ensureSizeOrGrow(2);
        this.dataView.setUint16(this.bytePosition, Number(value), true);
        return this.shift(2);
      }
      write32(value) {
        this.ensureSizeOrGrow(4);
        this.dataView.setUint32(this.bytePosition, Number(value), true);
        return this.shift(4);
      }
      write64(value) {
        toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));
        return this;
      }
      write128(value) {
        toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));
        return this;
      }
      write256(value) {
        toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));
        return this;
      }
      writeULEB(value) {
        ulebEncode(value).forEach((el) => this.write8(el));
        return this;
      }
      writeVec(vector, cb) {
        this.writeULEB(vector.length);
        Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));
        return this;
      }
      *[Symbol.iterator]() {
        for (let i = 0; i < this.bytePosition; i++) {
          yield this.dataView.getUint8(i);
        }
        return this.toBytes();
      }
      toBytes() {
        return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
      }
      toString(encoding) {
        return encodeStr(this.toBytes(), encoding);
      }
    };
    function ulebEncode(num) {
      let arr = [];
      let len = 0;
      if (num === 0) {
        return [0];
      }
      while (num > 0) {
        arr[len] = num & 127;
        if (num >>= 7) {
          arr[len] |= 128;
        }
        len += 1;
      }
      return arr;
    }
    function ulebDecode(arr) {
      let total = 0;
      let shift = 0;
      let len = 0;
      while (true) {
        let byte = arr[len];
        len += 1;
        total |= (byte & 127) << shift;
        if ((byte & 128) === 0) {
          break;
        }
        shift += 7;
      }
      return {
        value: total,
        length: len
      };
    }
    var _BCS = class _BCS2 {
      constructor(schema) {
        this.types = /* @__PURE__ */ new Map();
        this.counter = 0;
        if (schema instanceof _BCS2) {
          this.schema = schema.schema;
          this.types = new Map(schema.types);
          return;
        }
        this.schema = schema;
        this.registerAddressType(_BCS2.ADDRESS, schema.addressLength, schema.addressEncoding);
        this.registerVectorType(schema.vectorType);
        if (schema.types && schema.types.structs) {
          for (let name of Object.keys(schema.types.structs)) {
            this.registerStructType(name, schema.types.structs[name]);
          }
        }
        if (schema.types && schema.types.enums) {
          for (let name of Object.keys(schema.types.enums)) {
            this.registerEnumType(name, schema.types.enums[name]);
          }
        }
        if (schema.types && schema.types.aliases) {
          for (let name of Object.keys(schema.types.aliases)) {
            this.registerAlias(name, schema.types.aliases[name]);
          }
        }
        if (schema.withPrimitives !== false) {
          registerPrimitives(this);
        }
      }
      tempKey() {
        return `bcs-struct-${++this.counter}`;
      }
      ser(type, data, options) {
        if (typeof type === "string" || Array.isArray(type)) {
          const {name, params} = this.parseTypeName(type);
          return this.getTypeInterface(name).encode(this, data, options, params);
        }
        if (typeof type === "object") {
          const key = this.tempKey();
          const temp = new _BCS2(this);
          return temp.registerStructType(key, type).ser(key, data, options);
        }
        throw new Error(`Incorrect type passed into the '.ser()' function. 
${JSON.stringify(type)}`);
      }
      de(type, data, encoding) {
        if (typeof data === "string") {
          if (encoding) {
            data = decodeStr(data, encoding);
          } else {
            throw new Error("To pass a string to `bcs.de`, specify encoding");
          }
        }
        if (typeof type === "string" || Array.isArray(type)) {
          const {name, params} = this.parseTypeName(type);
          return this.getTypeInterface(name).decode(this, data, params);
        }
        if (typeof type === "object") {
          const temp = new _BCS2(this);
          const key = this.tempKey();
          return temp.registerStructType(key, type).de(key, data, encoding);
        }
        throw new Error(`Incorrect type passed into the '.de()' function. 
${JSON.stringify(type)}`);
      }
      hasType(type) {
        return this.types.has(type);
      }
      registerAlias(name, forType) {
        this.types.set(name, forType);
        return this;
      }
      registerType(typeName, encodeCb, decodeCb, validateCb = () => true) {
        const {name, params: generics} = this.parseTypeName(typeName);
        this.types.set(name, {
          encode(self2, data, options, typeParams) {
            const typeMap = generics.reduce((acc, value, index) => {
              return Object.assign(acc, {[value]: typeParams[index]});
            }, {});
            return this._encodeRaw.call(self2, new BcsWriter(options), data, typeParams, typeMap);
          },
          decode(self2, data, typeParams) {
            const typeMap = generics.reduce((acc, value, index) => {
              return Object.assign(acc, {[value]: typeParams[index]});
            }, {});
            return this._decodeRaw.call(self2, new BcsReader(data), typeParams, typeMap);
          },
          _encodeRaw(writer, data, typeParams, typeMap) {
            if (validateCb(data)) {
              return encodeCb.call(this, writer, data, typeParams, typeMap);
            } else {
              throw new Error(`Validation failed for type ${name}, data: ${data}`);
            }
          },
          _decodeRaw(reader, typeParams, typeMap) {
            return decodeCb.call(this, reader, typeParams, typeMap);
          }
        });
        return this;
      }
      registerAddressType(name, length, encoding = "hex") {
        switch (encoding) {
          case "base64":
            return this.registerType(name, function encodeAddress(writer, data) {
              return fromB64(data).reduce((writer2, el) => writer2.write8(el), writer);
            }, function decodeAddress(reader) {
              return toB64(reader.readBytes(length));
            });
          case "hex":
            return this.registerType(name, function encodeAddress(writer, data) {
              return fromHEX(data).reduce((writer2, el) => writer2.write8(el), writer);
            }, function decodeAddress(reader) {
              return toHEX(reader.readBytes(length));
            });
          default:
            throw new Error("Unsupported encoding! Use either hex or base64");
        }
      }
      registerVectorType(typeName) {
        let {name, params} = this.parseTypeName(typeName);
        if (params.length > 1) {
          throw new Error("Vector can have only one type parameter; got " + name);
        }
        return this.registerType(typeName, function encodeVector(writer, data, typeParams, typeMap) {
          return writer.writeVec(data, (writer2, el) => {
            let elementType = typeParams[0];
            if (!elementType) {
              throw new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);
            }
            let {name: name2, params: params2} = this.parseTypeName(elementType);
            if (this.hasType(name2)) {
              return this.getTypeInterface(name2)._encodeRaw.call(this, writer2, el, params2, typeMap);
            }
            if (!(name2 in typeMap)) {
              throw new Error(`Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`);
            }
            let {name: innerName, params: innerParams} = this.parseTypeName(typeMap[name2]);
            return this.getTypeInterface(innerName)._encodeRaw.call(this, writer2, el, innerParams, typeMap);
          });
        }, function decodeVector(reader, typeParams, typeMap) {
          return reader.readVec((reader2) => {
            let elementType = typeParams[0];
            if (!elementType) {
              throw new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);
            }
            let {name: name2, params: params2} = this.parseTypeName(elementType);
            if (this.hasType(name2)) {
              return this.getTypeInterface(name2)._decodeRaw.call(this, reader2, params2, typeMap);
            }
            if (!(name2 in typeMap)) {
              throw new Error(`Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`);
            }
            let {name: innerName, params: innerParams} = this.parseTypeName(typeMap[name2]);
            return this.getTypeInterface(innerName)._decodeRaw.call(this, reader2, innerParams, typeMap);
          });
        });
      }
      registerStructType(typeName, fields) {
        for (let key in fields) {
          let internalName = this.tempKey();
          let value = fields[key];
          if (!Array.isArray(value) && typeof value !== "string") {
            fields[key] = internalName;
            this.registerStructType(internalName, value);
          }
        }
        let struct = Object.freeze(fields);
        let canonicalOrder = Object.keys(struct);
        let {name: structName, params: generics} = this.parseTypeName(typeName);
        return this.registerType(typeName, function encodeStruct(writer, data, typeParams, typeMap) {
          if (!data || data.constructor !== Object) {
            throw new Error(`Expected ${structName} to be an Object, got: ${data}`);
          }
          if (typeParams.length !== generics.length) {
            throw new Error(`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`);
          }
          for (let key of canonicalOrder) {
            if (!(key in data)) {
              throw new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);
            }
            const {name: fieldType, params: fieldParams} = this.parseTypeName(struct[key]);
            if (!generics.includes(fieldType)) {
              this.getTypeInterface(fieldType)._encodeRaw.call(this, writer, data[key], fieldParams, typeMap);
            } else {
              const paramIdx = generics.indexOf(fieldType);
              let {name, params} = this.parseTypeName(typeParams[paramIdx]);
              if (this.hasType(name)) {
                this.getTypeInterface(name)._encodeRaw.call(this, writer, data[key], params, typeMap);
                continue;
              }
              if (!(name in typeMap)) {
                throw new Error(`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`);
              }
              let {name: innerName, params: innerParams} = this.parseTypeName(typeMap[name]);
              this.getTypeInterface(innerName)._encodeRaw.call(this, writer, data[key], innerParams, typeMap);
            }
          }
          return writer;
        }, function decodeStruct(reader, typeParams, typeMap) {
          if (typeParams.length !== generics.length) {
            throw new Error(`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`);
          }
          let result = {};
          for (let key of canonicalOrder) {
            const {name: fieldName, params: fieldParams} = this.parseTypeName(struct[key]);
            if (!generics.includes(fieldName)) {
              result[key] = this.getTypeInterface(fieldName)._decodeRaw.call(this, reader, fieldParams, typeMap);
            } else {
              const paramIdx = generics.indexOf(fieldName);
              let {name, params} = this.parseTypeName(typeParams[paramIdx]);
              if (this.hasType(name)) {
                result[key] = this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap);
                continue;
              }
              if (!(name in typeMap)) {
                throw new Error(`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`);
              }
              let {name: innerName, params: innerParams} = this.parseTypeName(typeMap[name]);
              result[key] = this.getTypeInterface(innerName)._decodeRaw.call(this, reader, innerParams, typeMap);
            }
          }
          return result;
        });
      }
      registerEnumType(typeName, variants) {
        for (let key in variants) {
          let internalName = this.tempKey();
          let value = variants[key];
          if (value !== null && !Array.isArray(value) && typeof value !== "string") {
            variants[key] = internalName;
            this.registerStructType(internalName, value);
          }
        }
        let struct = Object.freeze(variants);
        let canonicalOrder = Object.keys(struct);
        let {name, params: canonicalTypeParams} = this.parseTypeName(typeName);
        return this.registerType(typeName, function encodeEnum(writer, data, typeParams, typeMap) {
          if (!data) {
            throw new Error(`Unable to write enum "${name}", missing data.
Received: "${data}"`);
          }
          if (typeof data !== "object") {
            throw new Error(`Incorrect data passed into enum "${name}", expected object with properties: "${canonicalOrder.join(" | ")}".
Received: "${JSON.stringify(data)}"`);
          }
          let key = Object.keys(data)[0];
          if (key === void 0) {
            throw new Error(`Empty object passed as invariant of the enum "${name}"`);
          }
          let orderByte = canonicalOrder.indexOf(key);
          if (orderByte === -1) {
            throw new Error(`Unknown invariant of the enum "${name}", allowed values: "${canonicalOrder.join(" | ")}"; received "${key}"`);
          }
          let invariant = canonicalOrder[orderByte];
          let invariantType = struct[invariant];
          writer.write8(orderByte);
          if (invariantType === null) {
            return writer;
          }
          let paramIndex = canonicalTypeParams.indexOf(invariantType);
          let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];
          {
            let {name: name2, params} = this.parseTypeName(typeOrParam);
            return this.getTypeInterface(name2)._encodeRaw.call(this, writer, data[key], params, typeMap);
          }
        }, function decodeEnum(reader, typeParams, typeMap) {
          let orderByte = reader.readULEB();
          let invariant = canonicalOrder[orderByte];
          let invariantType = struct[invariant];
          if (orderByte === -1) {
            throw new Error(`Decoding type mismatch, expected enum "${name}" invariant index, received "${orderByte}"`);
          }
          if (invariantType === null) {
            return {[invariant]: true};
          }
          let paramIndex = canonicalTypeParams.indexOf(invariantType);
          let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];
          {
            let {name: name2, params} = this.parseTypeName(typeOrParam);
            return {
              [invariant]: this.getTypeInterface(name2)._decodeRaw.call(this, reader, params, typeMap)
            };
          }
        });
      }
      getTypeInterface(type) {
        let typeInterface = this.types.get(type);
        if (typeof typeInterface === "string") {
          let chain = [];
          while (typeof typeInterface === "string") {
            if (chain.includes(typeInterface)) {
              throw new Error(`Recursive definition found: ${chain.join(" -> ")} -> ${typeInterface}`);
            }
            chain.push(typeInterface);
            typeInterface = this.types.get(typeInterface);
          }
        }
        if (typeInterface === void 0) {
          throw new Error(`Type ${type} is not registered`);
        }
        return typeInterface;
      }
      parseTypeName(name) {
        if (Array.isArray(name)) {
          let [typeName2, ...params2] = name;
          return {name: typeName2, params: params2};
        }
        if (typeof name !== "string") {
          throw new Error(`Illegal type passed as a name of the type: ${name}`);
        }
        let [left, right] = this.schema.genericSeparators || ["<", ">"];
        let l_bound = name.indexOf(left);
        let r_bound = Array.from(name).reverse().indexOf(right);
        if (l_bound === -1 && r_bound === -1) {
          return {name, params: []};
        }
        if (l_bound === -1 || r_bound === -1) {
          throw new Error(`Unclosed generic in name '${name}'`);
        }
        let typeName = name.slice(0, l_bound);
        let params = splitGenericParameters(name.slice(l_bound + 1, name.length - r_bound - 1), this.schema.genericSeparators);
        return {name: typeName, params};
      }
    };
    _BCS.U8 = "u8";
    _BCS.U16 = "u16";
    _BCS.U32 = "u32";
    _BCS.U64 = "u64";
    _BCS.U128 = "u128";
    _BCS.U256 = "u256";
    _BCS.BOOL = "bool";
    _BCS.VECTOR = "vector";
    _BCS.ADDRESS = "address";
    _BCS.STRING = "string";
    _BCS.HEX = "hex-string";
    _BCS.BASE58 = "base58-string";
    _BCS.BASE64 = "base64-string";
    var BCS = _BCS;
    function encodeStr(data, encoding) {
      switch (encoding) {
        case "base58":
          return toB58(data);
        case "base64":
          return toB64(data);
        case "hex":
          return toHEX(data);
        default:
          throw new Error("Unsupported encoding, supported values are: base64, hex");
      }
    }
    function decodeStr(data, encoding) {
      switch (encoding) {
        case "base58":
          return fromB58(data);
        case "base64":
          return fromB64(data);
        case "hex":
          return fromHEX(data);
        default:
          throw new Error("Unsupported encoding, supported values are: base64, hex");
      }
    }
    function registerPrimitives(bcs) {
      bcs.registerType(BCS.U8, function(writer, data) {
        return writer.write8(data);
      }, function(reader) {
        return reader.read8();
      }, (u8) => u8 < 256);
      bcs.registerType(BCS.U16, function(writer, data) {
        return writer.write16(data);
      }, function(reader) {
        return reader.read16();
      }, (u16) => u16 < 65536);
      bcs.registerType(BCS.U32, function(writer, data) {
        return writer.write32(data);
      }, function(reader) {
        return reader.read32();
      }, (u32) => u32 <= 4294967296n);
      bcs.registerType(BCS.U64, function(writer, data) {
        return writer.write64(data);
      }, function(reader) {
        return reader.read64();
      });
      bcs.registerType(BCS.U128, function(writer, data) {
        return writer.write128(data);
      }, function(reader) {
        return reader.read128();
      });
      bcs.registerType(BCS.U256, function(writer, data) {
        return writer.write256(data);
      }, function(reader) {
        return reader.read256();
      });
      bcs.registerType(BCS.BOOL, function(writer, data) {
        return writer.write8(data);
      }, function(reader) {
        return reader.read8().toString(10) === "1";
      });
      bcs.registerType(BCS.STRING, function(writer, data) {
        return writer.writeVec(Array.from(data), (writer2, el) => writer2.write8(el.charCodeAt(0)));
      }, function(reader) {
        return reader.readVec((reader2) => reader2.read8()).map((el) => String.fromCharCode(Number(el))).join("");
      }, (_str) => true);
      bcs.registerType(BCS.HEX, function(writer, data) {
        return writer.writeVec(Array.from(fromHEX(data)), (writer2, el) => writer2.write8(el));
      }, function(reader) {
        let bytes = reader.readVec((reader2) => reader2.read8());
        return toHEX(new Uint8Array(bytes));
      });
      bcs.registerType(BCS.BASE58, function(writer, data) {
        return writer.writeVec(Array.from(fromB58(data)), (writer2, el) => writer2.write8(el));
      }, function(reader) {
        let bytes = reader.readVec((reader2) => reader2.read8());
        return toB58(new Uint8Array(bytes));
      });
      bcs.registerType(BCS.BASE64, function(writer, data) {
        return writer.writeVec(Array.from(fromB64(data)), (writer2, el) => writer2.write8(el));
      }, function(reader) {
        let bytes = reader.readVec((reader2) => reader2.read8());
        return toB64(new Uint8Array(bytes));
      });
    }
    function getRustConfig() {
      return {
        genericSeparators: ["<", ">"],
        vectorType: "Vec",
        addressLength: SUI_ADDRESS_LENGTH,
        addressEncoding: "hex"
      };
    }
    function getSuiMoveConfig() {
      return {
        genericSeparators: ["<", ">"],
        vectorType: "vector",
        addressLength: SUI_ADDRESS_LENGTH,
        addressEncoding: "hex"
      };
    }
    function splitGenericParameters(str, genericSeparators = ["<", ">"]) {
      const [left, right] = genericSeparators;
      const tok = [];
      let word = "";
      let nestedAngleBrackets = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str[i];
        if (char === left) {
          nestedAngleBrackets++;
        }
        if (char === right) {
          nestedAngleBrackets--;
        }
        if (nestedAngleBrackets === 0 && char === ",") {
          tok.push(word.trim());
          word = "";
          continue;
        }
        word += char;
      }
      tok.push(word.trim());
      return tok;
    }
  }
});

// node_modules/@mysten/sui.js/dist/cjs/utils/sui-types.js
var require_sui_types = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/utils/sui-types.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var sui_types_exports = {};
    __export2(sui_types_exports, {
      SUI_ADDRESS_LENGTH: () => SUI_ADDRESS_LENGTH,
      isValidSuiAddress: () => isValidSuiAddress,
      isValidSuiObjectId: () => isValidSuiObjectId,
      isValidTransactionDigest: () => isValidTransactionDigest,
      normalizeStructTag: () => normalizeStructTag,
      normalizeSuiAddress: () => normalizeSuiAddress,
      normalizeSuiObjectId: () => normalizeSuiObjectId,
      parseStructTag: () => parseStructTag
    });
    module2.exports = __toCommonJS(sui_types_exports);
    var import_bcs = require_dist();
    var TX_DIGEST_LENGTH = 32;
    function isValidTransactionDigest(value) {
      try {
        const buffer = (0, import_bcs.fromB58)(value);
        return buffer.length === TX_DIGEST_LENGTH;
      } catch (e) {
        return false;
      }
    }
    var SUI_ADDRESS_LENGTH = 32;
    function isValidSuiAddress(value) {
      return isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;
    }
    function isValidSuiObjectId(value) {
      return isValidSuiAddress(value);
    }
    function parseTypeTag(type) {
      if (!type.includes("::"))
        return type;
      return parseStructTag(type);
    }
    function parseStructTag(type) {
      const [address2, module22] = type.split("::");
      const rest = type.slice(address2.length + module22.length + 4);
      const name = rest.includes("<") ? rest.slice(0, rest.indexOf("<")) : rest;
      const typeParams = rest.includes("<") ? (0, import_bcs.splitGenericParameters)(rest.slice(rest.indexOf("<") + 1, rest.lastIndexOf(">"))).map((typeParam) => parseTypeTag(typeParam.trim())) : [];
      return {
        address: normalizeSuiAddress(address2),
        module: module22,
        name,
        typeParams
      };
    }
    function normalizeStructTag(type) {
      const {address: address2, module: module22, name, typeParams} = typeof type === "string" ? parseStructTag(type) : type;
      const formattedTypeParams = typeParams.length > 0 ? `<${typeParams.map((typeParam) => typeof typeParam === "string" ? typeParam : normalizeStructTag(typeParam)).join(",")}>` : "";
      return `${address2}::${module22}::${name}${formattedTypeParams}`;
    }
    function normalizeSuiAddress(value, forceAdd0x = false) {
      let address2 = value.toLowerCase();
      if (!forceAdd0x && address2.startsWith("0x")) {
        address2 = address2.slice(2);
      }
      return `0x${address2.padStart(SUI_ADDRESS_LENGTH * 2, "0")}`;
    }
    function normalizeSuiObjectId(value, forceAdd0x = false) {
      return normalizeSuiAddress(value, forceAdd0x);
    }
    function isHex(value) {
      return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;
    }
    function getHexByteLength(value) {
      return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
    }
  }
});

// node_modules/superstruct/dist/index.cjs
var require_dist2 = __commonJS({
  "node_modules/superstruct/dist/index.cjs"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.Superstruct = {}));
    })(exports, function(exports2) {
      "use strict";
      class StructError extends TypeError {
        constructor(failure, failures) {
          let cached;
          const {message, explanation, ...rest} = failure;
          const {path} = failure;
          const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
          super(explanation ?? msg);
          if (explanation != null)
            this.cause = msg;
          Object.assign(this, rest);
          this.name = this.constructor.name;
          this.failures = () => {
            return cached ?? (cached = [failure, ...failures()]);
          };
        }
      }
      function isIterable(x) {
        return isObject2(x) && typeof x[Symbol.iterator] === "function";
      }
      function isObject2(x) {
        return typeof x === "object" && x != null;
      }
      function isPlainObject(x) {
        if (Object.prototype.toString.call(x) !== "[object Object]") {
          return false;
        }
        const prototype = Object.getPrototypeOf(x);
        return prototype === null || prototype === Object.prototype;
      }
      function print(value) {
        if (typeof value === "symbol") {
          return value.toString();
        }
        return typeof value === "string" ? JSON.stringify(value) : `${value}`;
      }
      function shiftIterator(input) {
        const {done, value} = input.next();
        return done ? void 0 : value;
      }
      function toFailure(result, context, struct2, value) {
        if (result === true) {
          return;
        } else if (result === false) {
          result = {};
        } else if (typeof result === "string") {
          result = {message: result};
        }
        const {path, branch} = context;
        const {type: type2} = struct2;
        const {refinement, message = `Expected a value of type \`${type2}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print(value)}\``} = result;
        return {
          value,
          type: type2,
          refinement,
          key: path[path.length - 1],
          path,
          branch,
          ...result,
          message
        };
      }
      function* toFailures(result, context, struct2, value) {
        if (!isIterable(result)) {
          result = [result];
        }
        for (const r of result) {
          const failure = toFailure(r, context, struct2, value);
          if (failure) {
            yield failure;
          }
        }
      }
      function* run(value, struct2, options = {}) {
        const {path = [], branch = [value], coerce: coerce2 = false, mask: mask2 = false} = options;
        const ctx = {path, branch};
        if (coerce2) {
          value = struct2.coercer(value, ctx);
          if (mask2 && struct2.type !== "type" && isObject2(struct2.schema) && isObject2(value) && !Array.isArray(value)) {
            for (const key in value) {
              if (struct2.schema[key] === void 0) {
                delete value[key];
              }
            }
          }
        }
        let status = "valid";
        for (const failure of struct2.validator(value, ctx)) {
          failure.explanation = options.message;
          status = "not_valid";
          yield [failure, void 0];
        }
        for (let [k, v, s] of struct2.entries(value, ctx)) {
          const ts = run(v, s, {
            path: k === void 0 ? path : [...path, k],
            branch: k === void 0 ? branch : [...branch, v],
            coerce: coerce2,
            mask: mask2,
            message: options.message
          });
          for (const t of ts) {
            if (t[0]) {
              status = t[0].refinement != null ? "not_refined" : "not_valid";
              yield [t[0], void 0];
            } else if (coerce2) {
              v = t[1];
              if (k === void 0) {
                value = v;
              } else if (value instanceof Map) {
                value.set(k, v);
              } else if (value instanceof Set) {
                value.add(v);
              } else if (isObject2(value)) {
                if (v !== void 0 || k in value)
                  value[k] = v;
              }
            }
          }
        }
        if (status !== "not_valid") {
          for (const failure of struct2.refiner(value, ctx)) {
            failure.explanation = options.message;
            status = "not_refined";
            yield [failure, void 0];
          }
        }
        if (status === "valid") {
          yield [void 0, value];
        }
      }
      class Struct {
        constructor(props) {
          const {type: type2, schema, validator, refiner, coercer = (value) => value, entries = function* () {
          }} = props;
          this.type = type2;
          this.schema = schema;
          this.entries = entries;
          this.coercer = coercer;
          if (validator) {
            this.validator = (value, context) => {
              const result = validator(value, context);
              return toFailures(result, context, this, value);
            };
          } else {
            this.validator = () => [];
          }
          if (refiner) {
            this.refiner = (value, context) => {
              const result = refiner(value, context);
              return toFailures(result, context, this, value);
            };
          } else {
            this.refiner = () => [];
          }
        }
        assert(value, message) {
          return assert(value, this, message);
        }
        create(value, message) {
          return create(value, this, message);
        }
        is(value) {
          return is(value, this);
        }
        mask(value, message) {
          return mask(value, this, message);
        }
        validate(value, options = {}) {
          return validate(value, this, options);
        }
      }
      function assert(value, struct2, message) {
        const result = validate(value, struct2, {message});
        if (result[0]) {
          throw result[0];
        }
      }
      function create(value, struct2, message) {
        const result = validate(value, struct2, {coerce: true, message});
        if (result[0]) {
          throw result[0];
        } else {
          return result[1];
        }
      }
      function mask(value, struct2, message) {
        const result = validate(value, struct2, {coerce: true, mask: true, message});
        if (result[0]) {
          throw result[0];
        } else {
          return result[1];
        }
      }
      function is(value, struct2) {
        const result = validate(value, struct2);
        return !result[0];
      }
      function validate(value, struct2, options = {}) {
        const tuples = run(value, struct2, options);
        const tuple2 = shiftIterator(tuples);
        if (tuple2[0]) {
          const error = new StructError(tuple2[0], function* () {
            for (const t of tuples) {
              if (t[0]) {
                yield t[0];
              }
            }
          });
          return [error, void 0];
        } else {
          const v = tuple2[1];
          return [void 0, v];
        }
      }
      function assign(...Structs) {
        const isType = Structs[0].type === "type";
        const schemas = Structs.map((s) => s.schema);
        const schema = Object.assign({}, ...schemas);
        return isType ? type(schema) : object(schema);
      }
      function define2(name, validator) {
        return new Struct({type: name, schema: null, validator});
      }
      function deprecated(struct2, log2) {
        return new Struct({
          ...struct2,
          refiner: (value, ctx) => value === void 0 || struct2.refiner(value, ctx),
          validator(value, ctx) {
            if (value === void 0) {
              return true;
            } else {
              log2(value, ctx);
              return struct2.validator(value, ctx);
            }
          }
        });
      }
      function dynamic(fn) {
        return new Struct({
          type: "dynamic",
          schema: null,
          *entries(value, ctx) {
            const struct2 = fn(value, ctx);
            yield* struct2.entries(value, ctx);
          },
          validator(value, ctx) {
            const struct2 = fn(value, ctx);
            return struct2.validator(value, ctx);
          },
          coercer(value, ctx) {
            const struct2 = fn(value, ctx);
            return struct2.coercer(value, ctx);
          },
          refiner(value, ctx) {
            const struct2 = fn(value, ctx);
            return struct2.refiner(value, ctx);
          }
        });
      }
      function lazy(fn) {
        let struct2;
        return new Struct({
          type: "lazy",
          schema: null,
          *entries(value, ctx) {
            struct2 ?? (struct2 = fn());
            yield* struct2.entries(value, ctx);
          },
          validator(value, ctx) {
            struct2 ?? (struct2 = fn());
            return struct2.validator(value, ctx);
          },
          coercer(value, ctx) {
            struct2 ?? (struct2 = fn());
            return struct2.coercer(value, ctx);
          },
          refiner(value, ctx) {
            struct2 ?? (struct2 = fn());
            return struct2.refiner(value, ctx);
          }
        });
      }
      function omit(struct2, keys) {
        const {schema} = struct2;
        const subschema = {...schema};
        for (const key of keys) {
          delete subschema[key];
        }
        switch (struct2.type) {
          case "type":
            return type(subschema);
          default:
            return object(subschema);
        }
      }
      function partial(struct2) {
        const schema = struct2 instanceof Struct ? {...struct2.schema} : {...struct2};
        for (const key in schema) {
          schema[key] = optional(schema[key]);
        }
        return object(schema);
      }
      function pick(struct2, keys) {
        const {schema} = struct2;
        const subschema = {};
        for (const key of keys) {
          subschema[key] = schema[key];
        }
        return object(subschema);
      }
      function struct(name, validator) {
        console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`.");
        return define2(name, validator);
      }
      function any() {
        return define2("any", () => true);
      }
      function array(Element) {
        return new Struct({
          type: "array",
          schema: Element,
          *entries(value) {
            if (Element && Array.isArray(value)) {
              for (const [i, v] of value.entries()) {
                yield [i, v, Element];
              }
            }
          },
          coercer(value) {
            return Array.isArray(value) ? value.slice() : value;
          },
          validator(value) {
            return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
          }
        });
      }
      function bigint() {
        return define2("bigint", (value) => {
          return typeof value === "bigint";
        });
      }
      function boolean() {
        return define2("boolean", (value) => {
          return typeof value === "boolean";
        });
      }
      function date() {
        return define2("date", (value) => {
          return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \`Date\` object, but received: ${print(value)}`;
        });
      }
      function enums2(values) {
        const schema = {};
        const description = values.map((v) => print(v)).join();
        for (const key of values) {
          schema[key] = key;
        }
        return new Struct({
          type: "enums",
          schema,
          validator(value) {
            return values.includes(value) || `Expected one of \`${description}\`, but received: ${print(value)}`;
          }
        });
      }
      function func() {
        return define2("func", (value) => {
          return typeof value === "function" || `Expected a function, but received: ${print(value)}`;
        });
      }
      function instance(Class) {
        return define2("instance", (value) => {
          return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print(value)}`;
        });
      }
      function integer() {
        return define2("integer", (value) => {
          return typeof value === "number" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;
        });
      }
      function intersection(Structs) {
        return new Struct({
          type: "intersection",
          schema: null,
          *entries(value, ctx) {
            for (const S of Structs) {
              yield* S.entries(value, ctx);
            }
          },
          *validator(value, ctx) {
            for (const S of Structs) {
              yield* S.validator(value, ctx);
            }
          },
          *refiner(value, ctx) {
            for (const S of Structs) {
              yield* S.refiner(value, ctx);
            }
          }
        });
      }
      function literal(constant) {
        const description = print(constant);
        const t = typeof constant;
        return new Struct({
          type: "literal",
          schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
          validator(value) {
            return value === constant || `Expected the literal \`${description}\`, but received: ${print(value)}`;
          }
        });
      }
      function map(Key, Value) {
        return new Struct({
          type: "map",
          schema: null,
          *entries(value) {
            if (Key && Value && value instanceof Map) {
              for (const [k, v] of value.entries()) {
                yield [k, k, Key];
                yield [k, v, Value];
              }
            }
          },
          coercer(value) {
            return value instanceof Map ? new Map(value) : value;
          },
          validator(value) {
            return value instanceof Map || `Expected a \`Map\` object, but received: ${print(value)}`;
          }
        });
      }
      function never() {
        return define2("never", () => false);
      }
      function nullable(struct2) {
        return new Struct({
          ...struct2,
          validator: (value, ctx) => value === null || struct2.validator(value, ctx),
          refiner: (value, ctx) => value === null || struct2.refiner(value, ctx)
        });
      }
      function number() {
        return define2("number", (value) => {
          return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
        });
      }
      function object(schema) {
        const knowns = schema ? Object.keys(schema) : [];
        const Never = never();
        return new Struct({
          type: "object",
          schema: schema ? schema : null,
          *entries(value) {
            if (schema && isObject2(value)) {
              const unknowns = new Set(Object.keys(value));
              for (const key of knowns) {
                unknowns.delete(key);
                yield [key, value[key], schema[key]];
              }
              for (const key of unknowns) {
                yield [key, value[key], Never];
              }
            }
          },
          validator(value) {
            return isObject2(value) || `Expected an object, but received: ${print(value)}`;
          },
          coercer(value) {
            return isObject2(value) ? {...value} : value;
          }
        });
      }
      function optional(struct2) {
        return new Struct({
          ...struct2,
          validator: (value, ctx) => value === void 0 || struct2.validator(value, ctx),
          refiner: (value, ctx) => value === void 0 || struct2.refiner(value, ctx)
        });
      }
      function record(Key, Value) {
        return new Struct({
          type: "record",
          schema: null,
          *entries(value) {
            if (isObject2(value)) {
              for (const k in value) {
                const v = value[k];
                yield [k, k, Key];
                yield [k, v, Value];
              }
            }
          },
          validator(value) {
            return isObject2(value) || `Expected an object, but received: ${print(value)}`;
          }
        });
      }
      function regexp() {
        return define2("regexp", (value) => {
          return value instanceof RegExp;
        });
      }
      function set(Element) {
        return new Struct({
          type: "set",
          schema: null,
          *entries(value) {
            if (Element && value instanceof Set) {
              for (const v of value) {
                yield [v, v, Element];
              }
            }
          },
          coercer(value) {
            return value instanceof Set ? new Set(value) : value;
          },
          validator(value) {
            return value instanceof Set || `Expected a \`Set\` object, but received: ${print(value)}`;
          }
        });
      }
      function string() {
        return define2("string", (value) => {
          return typeof value === "string" || `Expected a string, but received: ${print(value)}`;
        });
      }
      function tuple(Structs) {
        const Never = never();
        return new Struct({
          type: "tuple",
          schema: null,
          *entries(value) {
            if (Array.isArray(value)) {
              const length = Math.max(Structs.length, value.length);
              for (let i = 0; i < length; i++) {
                yield [i, value[i], Structs[i] || Never];
              }
            }
          },
          validator(value) {
            return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;
          }
        });
      }
      function type(schema) {
        const keys = Object.keys(schema);
        return new Struct({
          type: "type",
          schema,
          *entries(value) {
            if (isObject2(value)) {
              for (const k of keys) {
                yield [k, value[k], schema[k]];
              }
            }
          },
          validator(value) {
            return isObject2(value) || `Expected an object, but received: ${print(value)}`;
          },
          coercer(value) {
            return isObject2(value) ? {...value} : value;
          }
        });
      }
      function union(Structs) {
        const description = Structs.map((s) => s.type).join(" | ");
        return new Struct({
          type: "union",
          schema: null,
          coercer(value) {
            for (const S of Structs) {
              const [error, coerced] = S.validate(value, {coerce: true});
              if (!error) {
                return coerced;
              }
            }
            return value;
          },
          validator(value, ctx) {
            const failures = [];
            for (const S of Structs) {
              const [...tuples] = run(value, S, ctx);
              const [first] = tuples;
              if (!first[0]) {
                return [];
              } else {
                for (const [failure] of tuples) {
                  if (failure) {
                    failures.push(failure);
                  }
                }
              }
            }
            return [
              `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,
              ...failures
            ];
          }
        });
      }
      function unknown() {
        return define2("unknown", () => true);
      }
      function coerce(struct2, condition, coercer) {
        return new Struct({
          ...struct2,
          coercer: (value, ctx) => {
            return is(value, condition) ? struct2.coercer(coercer(value, ctx), ctx) : struct2.coercer(value, ctx);
          }
        });
      }
      function defaulted(struct2, fallback, options = {}) {
        return coerce(struct2, unknown(), (x) => {
          const f = typeof fallback === "function" ? fallback() : fallback;
          if (x === void 0) {
            return f;
          }
          if (!options.strict && isPlainObject(x) && isPlainObject(f)) {
            const ret = {...x};
            let changed = false;
            for (const key in f) {
              if (ret[key] === void 0) {
                ret[key] = f[key];
                changed = true;
              }
            }
            if (changed) {
              return ret;
            }
          }
          return x;
        });
      }
      function trimmed(struct2) {
        return coerce(struct2, string(), (x) => x.trim());
      }
      function empty2(struct2) {
        return refine(struct2, "empty", (value) => {
          const size2 = getSize(value);
          return size2 === 0 || `Expected an empty ${struct2.type} but received one with a size of \`${size2}\``;
        });
      }
      function getSize(value) {
        if (value instanceof Map || value instanceof Set) {
          return value.size;
        } else {
          return value.length;
        }
      }
      function max(struct2, threshold, options = {}) {
        const {exclusive} = options;
        return refine(struct2, "max", (value) => {
          return exclusive ? value < threshold : value <= threshold || `Expected a ${struct2.type} less than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
        });
      }
      function min(struct2, threshold, options = {}) {
        const {exclusive} = options;
        return refine(struct2, "min", (value) => {
          return exclusive ? value > threshold : value >= threshold || `Expected a ${struct2.type} greater than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
        });
      }
      function nonempty(struct2) {
        return refine(struct2, "nonempty", (value) => {
          const size2 = getSize(value);
          return size2 > 0 || `Expected a nonempty ${struct2.type} but received an empty one`;
        });
      }
      function pattern(struct2, regexp2) {
        return refine(struct2, "pattern", (value) => {
          return regexp2.test(value) || `Expected a ${struct2.type} matching \`/${regexp2.source}/\` but received "${value}"`;
        });
      }
      function size(struct2, min2, max2 = min2) {
        const expected = `Expected a ${struct2.type}`;
        const of = min2 === max2 ? `of \`${min2}\`` : `between \`${min2}\` and \`${max2}\``;
        return refine(struct2, "size", (value) => {
          if (typeof value === "number" || value instanceof Date) {
            return min2 <= value && value <= max2 || `${expected} ${of} but received \`${value}\``;
          } else if (value instanceof Map || value instanceof Set) {
            const {size: size2} = value;
            return min2 <= size2 && size2 <= max2 || `${expected} with a size ${of} but received one with a size of \`${size2}\``;
          } else {
            const {length} = value;
            return min2 <= length && length <= max2 || `${expected} with a length ${of} but received one with a length of \`${length}\``;
          }
        });
      }
      function refine(struct2, name, refiner) {
        return new Struct({
          ...struct2,
          *refiner(value, ctx) {
            yield* struct2.refiner(value, ctx);
            const result = refiner(value, ctx);
            const failures = toFailures(result, ctx, struct2, value);
            for (const failure of failures) {
              yield {...failure, refinement: name};
            }
          }
        });
      }
      exports2.Struct = Struct;
      exports2.StructError = StructError;
      exports2.any = any;
      exports2.array = array;
      exports2.assert = assert;
      exports2.assign = assign;
      exports2.bigint = bigint;
      exports2.boolean = boolean;
      exports2.coerce = coerce;
      exports2.create = create;
      exports2.date = date;
      exports2.defaulted = defaulted;
      exports2.define = define2;
      exports2.deprecated = deprecated;
      exports2.dynamic = dynamic;
      exports2.empty = empty2;
      exports2.enums = enums2;
      exports2.func = func;
      exports2.instance = instance;
      exports2.integer = integer;
      exports2.intersection = intersection;
      exports2.is = is;
      exports2.lazy = lazy;
      exports2.literal = literal;
      exports2.map = map;
      exports2.mask = mask;
      exports2.max = max;
      exports2.min = min;
      exports2.never = never;
      exports2.nonempty = nonempty;
      exports2.nullable = nullable;
      exports2.number = number;
      exports2.object = object;
      exports2.omit = omit;
      exports2.optional = optional;
      exports2.partial = partial;
      exports2.pattern = pattern;
      exports2.pick = pick;
      exports2.record = record;
      exports2.refine = refine;
      exports2.regexp = regexp;
      exports2.set = set;
      exports2.size = size;
      exports2.string = string;
      exports2.struct = struct;
      exports2.trimmed = trimmed;
      exports2.tuple = tuple;
      exports2.type = type;
      exports2.union = union;
      exports2.unknown = unknown;
      exports2.validate = validate;
    });
  }
});

// node_modules/@mysten/sui.js/dist/cjs/types/common.js
var require_common = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/types/common.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var common_exports = {};
    __export2(common_exports, {
      ObjectId: () => ObjectId,
      ObjectOwner: () => ObjectOwner,
      ProtocolConfig: () => ProtocolConfig,
      SequenceNumber: () => SequenceNumber,
      SuiAddress: () => SuiAddress,
      SuiJsonValue: () => SuiJsonValue,
      TransactionDigest: () => TransactionDigest,
      TransactionEffectsDigest: () => TransactionEffectsDigest,
      TransactionEventDigest: () => TransactionEventDigest
    });
    module2.exports = __toCommonJS(common_exports);
    var import_superstruct = require_dist2();
    var TransactionDigest = (0, import_superstruct.string)();
    var TransactionEffectsDigest = (0, import_superstruct.string)();
    var TransactionEventDigest = (0, import_superstruct.string)();
    var ObjectId = (0, import_superstruct.string)();
    var SuiAddress = (0, import_superstruct.string)();
    var SequenceNumber = (0, import_superstruct.string)();
    var ObjectOwner = (0, import_superstruct.union)([
      (0, import_superstruct.object)({
        AddressOwner: (0, import_superstruct.string)()
      }),
      (0, import_superstruct.object)({
        ObjectOwner: (0, import_superstruct.string)()
      }),
      (0, import_superstruct.object)({
        Shared: (0, import_superstruct.object)({
          initial_shared_version: (0, import_superstruct.nullable)((0, import_superstruct.string)())
        })
      }),
      (0, import_superstruct.literal)("Immutable")
    ]);
    var SuiJsonValue = (0, import_superstruct.define)("SuiJsonValue", () => true);
    var ProtocolConfigValue = (0, import_superstruct.union)([
      (0, import_superstruct.object)({u32: (0, import_superstruct.string)()}),
      (0, import_superstruct.object)({u64: (0, import_superstruct.string)()}),
      (0, import_superstruct.object)({f64: (0, import_superstruct.string)()})
    ]);
    var ProtocolConfig = (0, import_superstruct.object)({
      attributes: (0, import_superstruct.record)((0, import_superstruct.string)(), (0, import_superstruct.nullable)(ProtocolConfigValue)),
      featureFlags: (0, import_superstruct.record)((0, import_superstruct.string)(), (0, import_superstruct.boolean)()),
      maxSupportedProtocolVersion: (0, import_superstruct.string)(),
      minSupportedProtocolVersion: (0, import_superstruct.string)(),
      protocolVersion: (0, import_superstruct.string)()
    });
  }
});

// node_modules/@mysten/sui.js/dist/cjs/types/objects.js
var require_objects = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/types/objects.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var objects_exports = {};
    __export2(objects_exports, {
      CheckpointedObjectId: () => CheckpointedObjectId,
      DisplayFieldsBackwardCompatibleResponse: () => DisplayFieldsBackwardCompatibleResponse,
      DisplayFieldsResponse: () => DisplayFieldsResponse,
      GetOwnedObjectsResponse: () => GetOwnedObjectsResponse,
      MIST_PER_SUI: () => MIST_PER_SUI,
      MovePackageContent: () => MovePackageContent,
      ObjectContentFields: () => ObjectContentFields,
      ObjectDigest: () => ObjectDigest,
      ObjectRead: () => ObjectRead,
      ObjectStatus: () => ObjectStatus,
      ObjectType: () => ObjectType,
      PaginatedObjectsResponse: () => PaginatedObjectsResponse2,
      SUI_DECIMALS: () => SUI_DECIMALS,
      SuiGasData: () => SuiGasData,
      SuiMoveObject: () => SuiMoveObject,
      SuiMovePackage: () => SuiMovePackage,
      SuiObjectData: () => SuiObjectData2,
      SuiObjectDataOptions: () => SuiObjectDataOptions,
      SuiObjectInfo: () => SuiObjectInfo,
      SuiObjectRef: () => SuiObjectRef,
      SuiObjectResponse: () => SuiObjectResponse2,
      SuiObjectResponseError: () => SuiObjectResponseError,
      SuiParsedData: () => SuiParsedData,
      SuiRawData: () => SuiRawData,
      SuiRawMoveObject: () => SuiRawMoveObject,
      SuiRawMovePackage: () => SuiRawMovePackage,
      getMoveObject: () => getMoveObject,
      getMoveObjectType: () => getMoveObjectType,
      getMovePackageContent: () => getMovePackageContent,
      getObjectDeletedResponse: () => getObjectDeletedResponse,
      getObjectDisplay: () => getObjectDisplay,
      getObjectFields: () => getObjectFields,
      getObjectId: () => getObjectId,
      getObjectNotExistsResponse: () => getObjectNotExistsResponse,
      getObjectOwner: () => getObjectOwner,
      getObjectPreviousTransactionDigest: () => getObjectPreviousTransactionDigest,
      getObjectReference: () => getObjectReference,
      getObjectType: () => getObjectType,
      getObjectVersion: () => getObjectVersion,
      getSharedObjectInitialVersion: () => getSharedObjectInitialVersion,
      getSuiObjectData: () => getSuiObjectData,
      hasPublicTransfer: () => hasPublicTransfer,
      isImmutableObject: () => isImmutableObject,
      isSharedObject: () => isSharedObject,
      isSuiObjectResponse: () => isSuiObjectResponse
    });
    module2.exports = __toCommonJS(objects_exports);
    var import_superstruct = require_dist2();
    var import_common = require_common();
    var ObjectType = (0, import_superstruct.union)([(0, import_superstruct.string)(), (0, import_superstruct.literal)("package")]);
    var SuiObjectRef = (0, import_superstruct.object)({
      digest: (0, import_superstruct.string)(),
      objectId: (0, import_superstruct.string)(),
      version: (0, import_superstruct.union)([(0, import_superstruct.number)(), (0, import_superstruct.string)()])
    });
    var SuiGasData = (0, import_superstruct.object)({
      payment: (0, import_superstruct.array)(SuiObjectRef),
      owner: (0, import_superstruct.string)(),
      price: (0, import_superstruct.string)(),
      budget: (0, import_superstruct.string)()
    });
    var SuiObjectInfo = (0, import_superstruct.assign)(SuiObjectRef, (0, import_superstruct.object)({
      type: (0, import_superstruct.string)(),
      owner: import_common.ObjectOwner,
      previousTransaction: (0, import_superstruct.string)()
    }));
    var ObjectContentFields = (0, import_superstruct.record)((0, import_superstruct.string)(), (0, import_superstruct.any)());
    var MovePackageContent = (0, import_superstruct.record)((0, import_superstruct.string)(), (0, import_superstruct.unknown)());
    var SuiMoveObject = (0, import_superstruct.object)({
      type: (0, import_superstruct.string)(),
      fields: ObjectContentFields,
      hasPublicTransfer: (0, import_superstruct.boolean)()
    });
    var SuiMovePackage = (0, import_superstruct.object)({
      disassembled: MovePackageContent
    });
    var SuiParsedData = (0, import_superstruct.union)([
      (0, import_superstruct.assign)(SuiMoveObject, (0, import_superstruct.object)({dataType: (0, import_superstruct.literal)("moveObject")})),
      (0, import_superstruct.assign)(SuiMovePackage, (0, import_superstruct.object)({dataType: (0, import_superstruct.literal)("package")}))
    ]);
    var SuiRawMoveObject = (0, import_superstruct.object)({
      type: (0, import_superstruct.string)(),
      hasPublicTransfer: (0, import_superstruct.boolean)(),
      version: (0, import_superstruct.string)(),
      bcsBytes: (0, import_superstruct.string)()
    });
    var SuiRawMovePackage = (0, import_superstruct.object)({
      id: (0, import_superstruct.string)(),
      moduleMap: (0, import_superstruct.record)((0, import_superstruct.string)(), (0, import_superstruct.string)())
    });
    var SuiRawData = (0, import_superstruct.union)([
      (0, import_superstruct.assign)(SuiRawMoveObject, (0, import_superstruct.object)({dataType: (0, import_superstruct.literal)("moveObject")})),
      (0, import_superstruct.assign)(SuiRawMovePackage, (0, import_superstruct.object)({dataType: (0, import_superstruct.literal)("package")}))
    ]);
    var SUI_DECIMALS = 9;
    var MIST_PER_SUI = BigInt(1e9);
    var ObjectDigest = (0, import_superstruct.string)();
    var SuiObjectResponseError = (0, import_superstruct.object)({
      code: (0, import_superstruct.string)(),
      error: (0, import_superstruct.optional)((0, import_superstruct.string)()),
      object_id: (0, import_superstruct.optional)((0, import_superstruct.string)()),
      parent_object_id: (0, import_superstruct.optional)((0, import_superstruct.string)()),
      version: (0, import_superstruct.optional)((0, import_superstruct.string)()),
      digest: (0, import_superstruct.optional)((0, import_superstruct.string)())
    });
    var DisplayFieldsResponse = (0, import_superstruct.object)({
      data: (0, import_superstruct.nullable)((0, import_superstruct.optional)((0, import_superstruct.record)((0, import_superstruct.string)(), (0, import_superstruct.string)()))),
      error: (0, import_superstruct.nullable)((0, import_superstruct.optional)(SuiObjectResponseError))
    });
    var DisplayFieldsBackwardCompatibleResponse = (0, import_superstruct.union)([
      DisplayFieldsResponse,
      (0, import_superstruct.optional)((0, import_superstruct.record)((0, import_superstruct.string)(), (0, import_superstruct.string)()))
    ]);
    var SuiObjectData2 = (0, import_superstruct.object)({
      objectId: (0, import_superstruct.string)(),
      version: (0, import_superstruct.string)(),
      digest: (0, import_superstruct.string)(),
      type: (0, import_superstruct.nullable)((0, import_superstruct.optional)((0, import_superstruct.string)())),
      content: (0, import_superstruct.nullable)((0, import_superstruct.optional)(SuiParsedData)),
      bcs: (0, import_superstruct.nullable)((0, import_superstruct.optional)(SuiRawData)),
      owner: (0, import_superstruct.nullable)((0, import_superstruct.optional)(import_common.ObjectOwner)),
      previousTransaction: (0, import_superstruct.nullable)((0, import_superstruct.optional)((0, import_superstruct.string)())),
      storageRebate: (0, import_superstruct.nullable)((0, import_superstruct.optional)((0, import_superstruct.string)())),
      display: (0, import_superstruct.nullable)((0, import_superstruct.optional)(DisplayFieldsBackwardCompatibleResponse))
    });
    var SuiObjectDataOptions = (0, import_superstruct.object)({
      showType: (0, import_superstruct.nullable)((0, import_superstruct.optional)((0, import_superstruct.boolean)())),
      showContent: (0, import_superstruct.nullable)((0, import_superstruct.optional)((0, import_superstruct.boolean)())),
      showBcs: (0, import_superstruct.nullable)((0, import_superstruct.optional)((0, import_superstruct.boolean)())),
      showOwner: (0, import_superstruct.nullable)((0, import_superstruct.optional)((0, import_superstruct.boolean)())),
      showPreviousTransaction: (0, import_superstruct.nullable)((0, import_superstruct.optional)((0, import_superstruct.boolean)())),
      showStorageRebate: (0, import_superstruct.nullable)((0, import_superstruct.optional)((0, import_superstruct.boolean)())),
      showDisplay: (0, import_superstruct.nullable)((0, import_superstruct.optional)((0, import_superstruct.boolean)()))
    });
    var ObjectStatus = (0, import_superstruct.union)([(0, import_superstruct.literal)("Exists"), (0, import_superstruct.literal)("notExists"), (0, import_superstruct.literal)("Deleted")]);
    var GetOwnedObjectsResponse = (0, import_superstruct.array)(SuiObjectInfo);
    var SuiObjectResponse2 = (0, import_superstruct.object)({
      data: (0, import_superstruct.nullable)((0, import_superstruct.optional)(SuiObjectData2)),
      error: (0, import_superstruct.nullable)((0, import_superstruct.optional)(SuiObjectResponseError))
    });
    function getSuiObjectData(resp) {
      return resp.data;
    }
    function getObjectDeletedResponse(resp) {
      if (resp.error && "object_id" in resp.error && "version" in resp.error && "digest" in resp.error) {
        const error = resp.error;
        return {
          objectId: error.object_id,
          version: error.version,
          digest: error.digest
        };
      }
      return void 0;
    }
    function getObjectNotExistsResponse(resp) {
      if (resp.error && "object_id" in resp.error && !("version" in resp.error) && !("digest" in resp.error)) {
        return resp.error.object_id;
      }
      return void 0;
    }
    function getObjectReference(resp) {
      if ("reference" in resp) {
        return resp.reference;
      }
      const exists = getSuiObjectData(resp);
      if (exists) {
        return {
          objectId: exists.objectId,
          version: exists.version,
          digest: exists.digest
        };
      }
      return getObjectDeletedResponse(resp);
    }
    function getObjectId(data) {
      if ("objectId" in data) {
        return data.objectId;
      }
      return getObjectReference(data)?.objectId ?? getObjectNotExistsResponse(data);
    }
    function getObjectVersion(data) {
      if ("version" in data) {
        return data.version;
      }
      return getObjectReference(data)?.version;
    }
    function isSuiObjectResponse(resp) {
      return resp.data !== void 0;
    }
    function getObjectType(resp) {
      const data = isSuiObjectResponse(resp) ? resp.data : resp;
      if (!data?.type && "data" in resp) {
        if (data?.content?.dataType === "package") {
          return "package";
        }
        return getMoveObjectType(resp);
      }
      return data?.type;
    }
    function getObjectPreviousTransactionDigest(resp) {
      return getSuiObjectData(resp)?.previousTransaction;
    }
    function getObjectOwner(resp) {
      if ((0, import_superstruct.is)(resp, import_common.ObjectOwner)) {
        return resp;
      }
      return getSuiObjectData(resp)?.owner;
    }
    function getObjectDisplay(resp) {
      const display = getSuiObjectData(resp)?.display;
      if (!display) {
        return {data: null, error: null};
      }
      if ((0, import_superstruct.is)(display, DisplayFieldsResponse)) {
        return display;
      }
      return {
        data: display,
        error: null
      };
    }
    function getSharedObjectInitialVersion(resp) {
      const owner = getObjectOwner(resp);
      if (owner && typeof owner === "object" && "Shared" in owner) {
        return owner.Shared.initial_shared_version;
      } else {
        return void 0;
      }
    }
    function isSharedObject(resp) {
      const owner = getObjectOwner(resp);
      return !!owner && typeof owner === "object" && "Shared" in owner;
    }
    function isImmutableObject(resp) {
      const owner = getObjectOwner(resp);
      return owner === "Immutable";
    }
    function getMoveObjectType(resp) {
      return getMoveObject(resp)?.type;
    }
    function getObjectFields(resp) {
      if ("fields" in resp) {
        return resp.fields;
      }
      return getMoveObject(resp)?.fields;
    }
    function isSuiObjectDataWithContent(data) {
      return data.content !== void 0;
    }
    function getMoveObject(data) {
      const suiObject = "data" in data ? getSuiObjectData(data) : data;
      if (!suiObject || !isSuiObjectDataWithContent(suiObject) || suiObject.content.dataType !== "moveObject") {
        return void 0;
      }
      return suiObject.content;
    }
    function hasPublicTransfer(data) {
      return getMoveObject(data)?.hasPublicTransfer ?? false;
    }
    function getMovePackageContent(data) {
      if ("disassembled" in data) {
        return data.disassembled;
      }
      const suiObject = getSuiObjectData(data);
      if (suiObject?.content?.dataType !== "package") {
        return void 0;
      }
      return suiObject.content.disassembled;
    }
    var CheckpointedObjectId = (0, import_superstruct.object)({
      objectId: (0, import_superstruct.string)(),
      atCheckpoint: (0, import_superstruct.optional)((0, import_superstruct.number)())
    });
    var PaginatedObjectsResponse2 = (0, import_superstruct.object)({
      data: (0, import_superstruct.array)(SuiObjectResponse2),
      nextCursor: (0, import_superstruct.optional)((0, import_superstruct.nullable)((0, import_superstruct.string)())),
      hasNextPage: (0, import_superstruct.boolean)()
    });
    var ObjectRead = (0, import_superstruct.union)([
      (0, import_superstruct.object)({
        details: SuiObjectData2,
        status: (0, import_superstruct.literal)("VersionFound")
      }),
      (0, import_superstruct.object)({
        details: (0, import_superstruct.string)(),
        status: (0, import_superstruct.literal)("ObjectNotExists")
      }),
      (0, import_superstruct.object)({
        details: SuiObjectRef,
        status: (0, import_superstruct.literal)("ObjectDeleted")
      }),
      (0, import_superstruct.object)({
        details: (0, import_superstruct.tuple)([(0, import_superstruct.string)(), (0, import_superstruct.number)()]),
        status: (0, import_superstruct.literal)("VersionNotFound")
      }),
      (0, import_superstruct.object)({
        details: (0, import_superstruct.object)({
          asked_version: (0, import_superstruct.number)(),
          latest_version: (0, import_superstruct.number)(),
          object_id: (0, import_superstruct.string)()
        }),
        status: (0, import_superstruct.literal)("VersionTooHigh")
      })
    ]);
  }
});

// node_modules/@mysten/sui.js/dist/cjs/types/events.js
var require_events = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/types/events.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var events_exports = {};
    __export2(events_exports, {
      EventId: () => EventId,
      PaginatedEvents: () => PaginatedEvents,
      SuiEvent: () => SuiEvent,
      getEventPackage: () => getEventPackage,
      getEventSender: () => getEventSender
    });
    module2.exports = __toCommonJS(events_exports);
    var import_superstruct = require_dist2();
    var EventId = (0, import_superstruct.object)({
      txDigest: (0, import_superstruct.string)(),
      eventSeq: (0, import_superstruct.string)()
    });
    var SuiEvent = (0, import_superstruct.object)({
      id: EventId,
      packageId: (0, import_superstruct.string)(),
      transactionModule: (0, import_superstruct.string)(),
      sender: (0, import_superstruct.string)(),
      type: (0, import_superstruct.string)(),
      parsedJson: (0, import_superstruct.optional)((0, import_superstruct.record)((0, import_superstruct.string)(), (0, import_superstruct.any)())),
      bcs: (0, import_superstruct.optional)((0, import_superstruct.string)()),
      timestampMs: (0, import_superstruct.optional)((0, import_superstruct.string)())
    });
    var PaginatedEvents = (0, import_superstruct.object)({
      data: (0, import_superstruct.array)(SuiEvent),
      nextCursor: (0, import_superstruct.nullable)(EventId),
      hasNextPage: (0, import_superstruct.boolean)()
    });
    function getEventSender(event2) {
      return event2.sender;
    }
    function getEventPackage(event2) {
      return event2.packageId;
    }
  }
});

// node_modules/@mysten/sui.js/dist/cjs/types/transactions.js
var require_transactions = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/types/transactions.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var transactions_exports = {};
    __export2(transactions_exports, {
      AuthorityName: () => AuthorityName,
      AuthorityQuorumSignInfo: () => AuthorityQuorumSignInfo,
      AuthoritySignature: () => AuthoritySignature,
      BalanceChange: () => BalanceChange,
      DevInspectResults: () => DevInspectResults,
      DryRunTransactionBlockResponse: () => DryRunTransactionBlockResponse,
      EpochId: () => EpochId,
      ExecutionStatus: () => ExecutionStatus,
      ExecutionStatusType: () => ExecutionStatusType,
      GasCostSummary: () => GasCostSummary,
      GenericAuthoritySignature: () => GenericAuthoritySignature,
      Genesis: () => Genesis,
      MoveCallSuiTransaction: () => MoveCallSuiTransaction,
      OwnedObjectRef: () => OwnedObjectRef,
      PaginatedTransactionResponse: () => PaginatedTransactionResponse,
      ProgrammableTransaction: () => ProgrammableTransaction,
      SuiArgument: () => SuiArgument,
      SuiCallArg: () => SuiCallArg,
      SuiChangeEpoch: () => SuiChangeEpoch,
      SuiConsensusCommitPrologue: () => SuiConsensusCommitPrologue,
      SuiObjectChange: () => SuiObjectChange,
      SuiObjectChangeCreated: () => SuiObjectChangeCreated,
      SuiObjectChangeDeleted: () => SuiObjectChangeDeleted,
      SuiObjectChangeMutated: () => SuiObjectChangeMutated,
      SuiObjectChangePublished: () => SuiObjectChangePublished,
      SuiObjectChangeTransferred: () => SuiObjectChangeTransferred,
      SuiObjectChangeWrapped: () => SuiObjectChangeWrapped,
      SuiTransaction: () => SuiTransaction,
      SuiTransactionBlock: () => SuiTransactionBlock,
      SuiTransactionBlockData: () => SuiTransactionBlockData,
      SuiTransactionBlockKind: () => SuiTransactionBlockKind,
      SuiTransactionBlockResponse: () => SuiTransactionBlockResponse,
      SuiTransactionBlockResponseOptions: () => SuiTransactionBlockResponseOptions,
      TransactionEffects: () => TransactionEffects,
      TransactionEffectsModifiedAtVersions: () => TransactionEffectsModifiedAtVersions,
      TransactionEvents: () => TransactionEvents,
      getChangeEpochTransaction: () => getChangeEpochTransaction,
      getConsensusCommitPrologueTransaction: () => getConsensusCommitPrologueTransaction,
      getCreatedObjects: () => getCreatedObjects,
      getEvents: () => getEvents,
      getExecutionStatus: () => getExecutionStatus,
      getExecutionStatusError: () => getExecutionStatusError,
      getExecutionStatusGasSummary: () => getExecutionStatusGasSummary,
      getExecutionStatusType: () => getExecutionStatusType,
      getGasData: () => getGasData,
      getNewlyCreatedCoinRefsAfterSplit: () => getNewlyCreatedCoinRefsAfterSplit,
      getObjectChanges: () => getObjectChanges,
      getProgrammableTransaction: () => getProgrammableTransaction,
      getPublishedObjectChanges: () => getPublishedObjectChanges,
      getTimestampFromTransactionResponse: () => getTimestampFromTransactionResponse,
      getTotalGasUsed: () => getTotalGasUsed,
      getTotalGasUsedUpperBound: () => getTotalGasUsedUpperBound,
      getTransaction: () => getTransaction,
      getTransactionDigest: () => getTransactionDigest,
      getTransactionEffects: () => getTransactionEffects,
      getTransactionGasBudget: () => getTransactionGasBudget,
      getTransactionGasObject: () => getTransactionGasObject,
      getTransactionGasPrice: () => getTransactionGasPrice,
      getTransactionKind: () => getTransactionKind,
      getTransactionKindName: () => getTransactionKindName,
      getTransactionSender: () => getTransactionSender,
      getTransactionSignature: () => getTransactionSignature
    });
    module2.exports = __toCommonJS(transactions_exports);
    var import_superstruct = require_dist2();
    var import_common = require_common();
    var import_events = require_events();
    var import_objects = require_objects();
    var EpochId = (0, import_superstruct.string)();
    var SuiChangeEpoch = (0, import_superstruct.object)({
      epoch: (0, import_superstruct.string)(),
      storage_charge: (0, import_superstruct.string)(),
      computation_charge: (0, import_superstruct.string)(),
      storage_rebate: (0, import_superstruct.string)(),
      epoch_start_timestamp_ms: (0, import_superstruct.optional)((0, import_superstruct.string)())
    });
    var SuiConsensusCommitPrologue = (0, import_superstruct.object)({
      epoch: (0, import_superstruct.string)(),
      round: (0, import_superstruct.string)(),
      commit_timestamp_ms: (0, import_superstruct.string)()
    });
    var Genesis = (0, import_superstruct.object)({
      objects: (0, import_superstruct.array)((0, import_superstruct.string)())
    });
    var SuiArgument = (0, import_superstruct.union)([
      (0, import_superstruct.literal)("GasCoin"),
      (0, import_superstruct.object)({Input: (0, import_superstruct.number)()}),
      (0, import_superstruct.object)({Result: (0, import_superstruct.number)()}),
      (0, import_superstruct.object)({NestedResult: (0, import_superstruct.tuple)([(0, import_superstruct.number)(), (0, import_superstruct.number)()])})
    ]);
    var MoveCallSuiTransaction = (0, import_superstruct.object)({
      arguments: (0, import_superstruct.optional)((0, import_superstruct.array)(SuiArgument)),
      type_arguments: (0, import_superstruct.optional)((0, import_superstruct.array)((0, import_superstruct.string)())),
      package: (0, import_superstruct.string)(),
      module: (0, import_superstruct.string)(),
      function: (0, import_superstruct.string)()
    });
    var SuiTransaction = (0, import_superstruct.union)([
      (0, import_superstruct.object)({MoveCall: MoveCallSuiTransaction}),
      (0, import_superstruct.object)({TransferObjects: (0, import_superstruct.tuple)([(0, import_superstruct.array)(SuiArgument), SuiArgument])}),
      (0, import_superstruct.object)({SplitCoins: (0, import_superstruct.tuple)([SuiArgument, (0, import_superstruct.array)(SuiArgument)])}),
      (0, import_superstruct.object)({MergeCoins: (0, import_superstruct.tuple)([SuiArgument, (0, import_superstruct.array)(SuiArgument)])}),
      (0, import_superstruct.object)({
        Publish: (0, import_superstruct.union)([
          (0, import_superstruct.tuple)([import_objects.SuiMovePackage, (0, import_superstruct.array)((0, import_superstruct.string)())]),
          (0, import_superstruct.array)((0, import_superstruct.string)())
        ])
      }),
      (0, import_superstruct.object)({
        Upgrade: (0, import_superstruct.union)([
          (0, import_superstruct.tuple)([import_objects.SuiMovePackage, (0, import_superstruct.array)((0, import_superstruct.string)()), (0, import_superstruct.string)(), SuiArgument]),
          (0, import_superstruct.tuple)([(0, import_superstruct.array)((0, import_superstruct.string)()), (0, import_superstruct.string)(), SuiArgument])
        ])
      }),
      (0, import_superstruct.object)({MakeMoveVec: (0, import_superstruct.tuple)([(0, import_superstruct.nullable)((0, import_superstruct.string)()), (0, import_superstruct.array)(SuiArgument)])})
    ]);
    var SuiCallArg = (0, import_superstruct.union)([
      (0, import_superstruct.object)({
        type: (0, import_superstruct.literal)("pure"),
        valueType: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
        value: import_common.SuiJsonValue
      }),
      (0, import_superstruct.object)({
        type: (0, import_superstruct.literal)("object"),
        objectType: (0, import_superstruct.literal)("immOrOwnedObject"),
        objectId: (0, import_superstruct.string)(),
        version: (0, import_superstruct.string)(),
        digest: (0, import_superstruct.string)()
      }),
      (0, import_superstruct.object)({
        type: (0, import_superstruct.literal)("object"),
        objectType: (0, import_superstruct.literal)("sharedObject"),
        objectId: (0, import_superstruct.string)(),
        initialSharedVersion: (0, import_superstruct.string)(),
        mutable: (0, import_superstruct.boolean)()
      })
    ]);
    var ProgrammableTransaction = (0, import_superstruct.object)({
      transactions: (0, import_superstruct.array)(SuiTransaction),
      inputs: (0, import_superstruct.array)(SuiCallArg)
    });
    var SuiTransactionBlockKind = (0, import_superstruct.union)([
      (0, import_superstruct.assign)(SuiChangeEpoch, (0, import_superstruct.object)({kind: (0, import_superstruct.literal)("ChangeEpoch")})),
      (0, import_superstruct.assign)(SuiConsensusCommitPrologue, (0, import_superstruct.object)({
        kind: (0, import_superstruct.literal)("ConsensusCommitPrologue")
      })),
      (0, import_superstruct.assign)(Genesis, (0, import_superstruct.object)({kind: (0, import_superstruct.literal)("Genesis")})),
      (0, import_superstruct.assign)(ProgrammableTransaction, (0, import_superstruct.object)({kind: (0, import_superstruct.literal)("ProgrammableTransaction")}))
    ]);
    var SuiTransactionBlockData = (0, import_superstruct.object)({
      messageVersion: (0, import_superstruct.literal)("v1"),
      transaction: SuiTransactionBlockKind,
      sender: (0, import_superstruct.string)(),
      gasData: import_objects.SuiGasData
    });
    var AuthoritySignature = (0, import_superstruct.string)();
    var GenericAuthoritySignature = (0, import_superstruct.union)([(0, import_superstruct.string)(), (0, import_superstruct.array)((0, import_superstruct.string)())]);
    var AuthorityQuorumSignInfo = (0, import_superstruct.object)({
      epoch: (0, import_superstruct.string)(),
      signature: GenericAuthoritySignature,
      signers_map: (0, import_superstruct.array)((0, import_superstruct.number)())
    });
    var GasCostSummary = (0, import_superstruct.object)({
      computationCost: (0, import_superstruct.string)(),
      storageCost: (0, import_superstruct.string)(),
      storageRebate: (0, import_superstruct.string)(),
      nonRefundableStorageFee: (0, import_superstruct.string)()
    });
    var ExecutionStatusType = (0, import_superstruct.union)([(0, import_superstruct.literal)("success"), (0, import_superstruct.literal)("failure")]);
    var ExecutionStatus = (0, import_superstruct.object)({
      status: ExecutionStatusType,
      error: (0, import_superstruct.optional)((0, import_superstruct.string)())
    });
    var OwnedObjectRef = (0, import_superstruct.object)({
      owner: import_common.ObjectOwner,
      reference: import_objects.SuiObjectRef
    });
    var TransactionEffectsModifiedAtVersions = (0, import_superstruct.object)({
      objectId: (0, import_superstruct.string)(),
      sequenceNumber: (0, import_superstruct.string)()
    });
    var TransactionEffects = (0, import_superstruct.object)({
      messageVersion: (0, import_superstruct.literal)("v1"),
      status: ExecutionStatus,
      executedEpoch: (0, import_superstruct.string)(),
      modifiedAtVersions: (0, import_superstruct.optional)((0, import_superstruct.array)(TransactionEffectsModifiedAtVersions)),
      gasUsed: GasCostSummary,
      sharedObjects: (0, import_superstruct.optional)((0, import_superstruct.array)(import_objects.SuiObjectRef)),
      transactionDigest: (0, import_superstruct.string)(),
      created: (0, import_superstruct.optional)((0, import_superstruct.array)(OwnedObjectRef)),
      mutated: (0, import_superstruct.optional)((0, import_superstruct.array)(OwnedObjectRef)),
      unwrapped: (0, import_superstruct.optional)((0, import_superstruct.array)(OwnedObjectRef)),
      deleted: (0, import_superstruct.optional)((0, import_superstruct.array)(import_objects.SuiObjectRef)),
      unwrappedThenDeleted: (0, import_superstruct.optional)((0, import_superstruct.array)(import_objects.SuiObjectRef)),
      wrapped: (0, import_superstruct.optional)((0, import_superstruct.array)(import_objects.SuiObjectRef)),
      gasObject: OwnedObjectRef,
      eventsDigest: (0, import_superstruct.nullable)((0, import_superstruct.optional)((0, import_superstruct.string)())),
      dependencies: (0, import_superstruct.optional)((0, import_superstruct.array)((0, import_superstruct.string)()))
    });
    var TransactionEvents = (0, import_superstruct.array)(import_events.SuiEvent);
    var ReturnValueType = (0, import_superstruct.tuple)([(0, import_superstruct.array)((0, import_superstruct.number)()), (0, import_superstruct.string)()]);
    var MutableReferenceOutputType = (0, import_superstruct.tuple)([SuiArgument, (0, import_superstruct.array)((0, import_superstruct.number)()), (0, import_superstruct.string)()]);
    var ExecutionResultType = (0, import_superstruct.object)({
      mutableReferenceOutputs: (0, import_superstruct.optional)((0, import_superstruct.array)(MutableReferenceOutputType)),
      returnValues: (0, import_superstruct.optional)((0, import_superstruct.array)(ReturnValueType))
    });
    var DevInspectResults = (0, import_superstruct.object)({
      effects: TransactionEffects,
      events: TransactionEvents,
      results: (0, import_superstruct.optional)((0, import_superstruct.array)(ExecutionResultType)),
      error: (0, import_superstruct.optional)((0, import_superstruct.string)())
    });
    var AuthorityName = (0, import_superstruct.string)();
    var SuiTransactionBlock = (0, import_superstruct.object)({
      data: SuiTransactionBlockData,
      txSignatures: (0, import_superstruct.array)((0, import_superstruct.string)())
    });
    var SuiObjectChangePublished = (0, import_superstruct.object)({
      type: (0, import_superstruct.literal)("published"),
      packageId: (0, import_superstruct.string)(),
      version: (0, import_superstruct.string)(),
      digest: (0, import_superstruct.string)(),
      modules: (0, import_superstruct.array)((0, import_superstruct.string)())
    });
    var SuiObjectChangeTransferred = (0, import_superstruct.object)({
      type: (0, import_superstruct.literal)("transferred"),
      sender: (0, import_superstruct.string)(),
      recipient: import_common.ObjectOwner,
      objectType: (0, import_superstruct.string)(),
      objectId: (0, import_superstruct.string)(),
      version: (0, import_superstruct.string)(),
      digest: (0, import_superstruct.string)()
    });
    var SuiObjectChangeMutated = (0, import_superstruct.object)({
      type: (0, import_superstruct.literal)("mutated"),
      sender: (0, import_superstruct.string)(),
      owner: import_common.ObjectOwner,
      objectType: (0, import_superstruct.string)(),
      objectId: (0, import_superstruct.string)(),
      version: (0, import_superstruct.string)(),
      previousVersion: (0, import_superstruct.string)(),
      digest: (0, import_superstruct.string)()
    });
    var SuiObjectChangeDeleted = (0, import_superstruct.object)({
      type: (0, import_superstruct.literal)("deleted"),
      sender: (0, import_superstruct.string)(),
      objectType: (0, import_superstruct.string)(),
      objectId: (0, import_superstruct.string)(),
      version: (0, import_superstruct.string)()
    });
    var SuiObjectChangeWrapped = (0, import_superstruct.object)({
      type: (0, import_superstruct.literal)("wrapped"),
      sender: (0, import_superstruct.string)(),
      objectType: (0, import_superstruct.string)(),
      objectId: (0, import_superstruct.string)(),
      version: (0, import_superstruct.string)()
    });
    var SuiObjectChangeCreated = (0, import_superstruct.object)({
      type: (0, import_superstruct.literal)("created"),
      sender: (0, import_superstruct.string)(),
      owner: import_common.ObjectOwner,
      objectType: (0, import_superstruct.string)(),
      objectId: (0, import_superstruct.string)(),
      version: (0, import_superstruct.string)(),
      digest: (0, import_superstruct.string)()
    });
    var SuiObjectChange = (0, import_superstruct.union)([
      SuiObjectChangePublished,
      SuiObjectChangeTransferred,
      SuiObjectChangeMutated,
      SuiObjectChangeDeleted,
      SuiObjectChangeWrapped,
      SuiObjectChangeCreated
    ]);
    var BalanceChange = (0, import_superstruct.object)({
      owner: import_common.ObjectOwner,
      coinType: (0, import_superstruct.string)(),
      amount: (0, import_superstruct.string)()
    });
    var SuiTransactionBlockResponse = (0, import_superstruct.object)({
      digest: (0, import_superstruct.string)(),
      transaction: (0, import_superstruct.optional)(SuiTransactionBlock),
      effects: (0, import_superstruct.optional)(TransactionEffects),
      events: (0, import_superstruct.optional)(TransactionEvents),
      timestampMs: (0, import_superstruct.optional)((0, import_superstruct.string)()),
      checkpoint: (0, import_superstruct.optional)((0, import_superstruct.string)()),
      confirmedLocalExecution: (0, import_superstruct.optional)((0, import_superstruct.boolean)()),
      objectChanges: (0, import_superstruct.optional)((0, import_superstruct.array)(SuiObjectChange)),
      balanceChanges: (0, import_superstruct.optional)((0, import_superstruct.array)(BalanceChange)),
      errors: (0, import_superstruct.optional)((0, import_superstruct.array)((0, import_superstruct.string)()))
    });
    var SuiTransactionBlockResponseOptions = (0, import_superstruct.object)({
      showInput: (0, import_superstruct.optional)((0, import_superstruct.boolean)()),
      showEffects: (0, import_superstruct.optional)((0, import_superstruct.boolean)()),
      showEvents: (0, import_superstruct.optional)((0, import_superstruct.boolean)()),
      showObjectChanges: (0, import_superstruct.optional)((0, import_superstruct.boolean)()),
      showBalanceChanges: (0, import_superstruct.optional)((0, import_superstruct.boolean)())
    });
    var PaginatedTransactionResponse = (0, import_superstruct.object)({
      data: (0, import_superstruct.array)(SuiTransactionBlockResponse),
      nextCursor: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
      hasNextPage: (0, import_superstruct.boolean)()
    });
    var DryRunTransactionBlockResponse = (0, import_superstruct.object)({
      effects: TransactionEffects,
      events: TransactionEvents,
      objectChanges: (0, import_superstruct.array)(SuiObjectChange),
      balanceChanges: (0, import_superstruct.array)(BalanceChange),
      input: (0, import_superstruct.optional)(SuiTransactionBlockData)
    });
    function getTransaction(tx) {
      return tx.transaction;
    }
    function getTransactionDigest(tx) {
      return tx.digest;
    }
    function getTransactionSignature(tx) {
      return tx.transaction?.txSignatures;
    }
    function getTransactionSender(tx) {
      return tx.transaction?.data.sender;
    }
    function getGasData(tx) {
      return tx.transaction?.data.gasData;
    }
    function getTransactionGasObject(tx) {
      return getGasData(tx)?.payment;
    }
    function getTransactionGasPrice(tx) {
      return getGasData(tx)?.price;
    }
    function getTransactionGasBudget(tx) {
      return getGasData(tx)?.budget;
    }
    function getChangeEpochTransaction(data) {
      return data.kind === "ChangeEpoch" ? data : void 0;
    }
    function getConsensusCommitPrologueTransaction(data) {
      return data.kind === "ConsensusCommitPrologue" ? data : void 0;
    }
    function getTransactionKind(data) {
      return data.transaction?.data.transaction;
    }
    function getTransactionKindName(data) {
      return data.kind;
    }
    function getProgrammableTransaction(data) {
      return data.kind === "ProgrammableTransaction" ? data : void 0;
    }
    function getExecutionStatusType(data) {
      return getExecutionStatus(data)?.status;
    }
    function getExecutionStatus(data) {
      return getTransactionEffects(data)?.status;
    }
    function getExecutionStatusError(data) {
      return getExecutionStatus(data)?.error;
    }
    function getExecutionStatusGasSummary(data) {
      if ((0, import_superstruct.is)(data, TransactionEffects)) {
        return data.gasUsed;
      }
      return getTransactionEffects(data)?.gasUsed;
    }
    function getTotalGasUsed(data) {
      const gasSummary = getExecutionStatusGasSummary(data);
      return gasSummary ? BigInt(gasSummary.computationCost) + BigInt(gasSummary.storageCost) - BigInt(gasSummary.storageRebate) : void 0;
    }
    function getTotalGasUsedUpperBound(data) {
      const gasSummary = getExecutionStatusGasSummary(data);
      return gasSummary ? BigInt(gasSummary.computationCost) + BigInt(gasSummary.storageCost) : void 0;
    }
    function getTransactionEffects(data) {
      return data.effects;
    }
    function getEvents(data) {
      return data.events;
    }
    function getCreatedObjects(data) {
      return getTransactionEffects(data)?.created;
    }
    function getTimestampFromTransactionResponse(data) {
      return data.timestampMs ?? void 0;
    }
    function getNewlyCreatedCoinRefsAfterSplit(data) {
      return getTransactionEffects(data)?.created?.map((c) => c.reference);
    }
    function getObjectChanges(data) {
      return data.objectChanges;
    }
    function getPublishedObjectChanges(data) {
      return data.objectChanges?.filter((a) => (0, import_superstruct.is)(a, SuiObjectChangePublished)) ?? [];
    }
  }
});

// node_modules/@mysten/sui.js/dist/cjs/types/normalized.js
var require_normalized = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/types/normalized.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var normalized_exports = {};
    __export2(normalized_exports, {
      MoveCallMetric: () => MoveCallMetric,
      MoveCallMetrics: () => MoveCallMetrics,
      SuiMoveAbilitySet: () => SuiMoveAbilitySet,
      SuiMoveFunctionArgType: () => SuiMoveFunctionArgType,
      SuiMoveFunctionArgTypes: () => SuiMoveFunctionArgTypes,
      SuiMoveModuleId: () => SuiMoveModuleId,
      SuiMoveNormalizedField: () => SuiMoveNormalizedField,
      SuiMoveNormalizedFunction: () => SuiMoveNormalizedFunction,
      SuiMoveNormalizedModule: () => SuiMoveNormalizedModule,
      SuiMoveNormalizedModules: () => SuiMoveNormalizedModules,
      SuiMoveNormalizedStruct: () => SuiMoveNormalizedStruct,
      SuiMoveNormalizedStructType: () => SuiMoveNormalizedStructType,
      SuiMoveNormalizedType: () => SuiMoveNormalizedType,
      SuiMoveNormalizedTypeParameterType: () => SuiMoveNormalizedTypeParameterType,
      SuiMoveStructTypeParameter: () => SuiMoveStructTypeParameter,
      SuiMoveVisibility: () => SuiMoveVisibility,
      extractMutableReference: () => extractMutableReference,
      extractReference: () => extractReference,
      extractStructTag: () => extractStructTag
    });
    module2.exports = __toCommonJS(normalized_exports);
    var import_superstruct = require_dist2();
    var SuiMoveFunctionArgType = (0, import_superstruct.union)([(0, import_superstruct.string)(), (0, import_superstruct.object)({Object: (0, import_superstruct.string)()})]);
    var SuiMoveFunctionArgTypes = (0, import_superstruct.array)(SuiMoveFunctionArgType);
    var SuiMoveModuleId = (0, import_superstruct.object)({
      address: (0, import_superstruct.string)(),
      name: (0, import_superstruct.string)()
    });
    var SuiMoveVisibility = (0, import_superstruct.union)([(0, import_superstruct.literal)("Private"), (0, import_superstruct.literal)("Public"), (0, import_superstruct.literal)("Friend")]);
    var SuiMoveAbilitySet = (0, import_superstruct.object)({
      abilities: (0, import_superstruct.array)((0, import_superstruct.string)())
    });
    var SuiMoveStructTypeParameter = (0, import_superstruct.object)({
      constraints: SuiMoveAbilitySet,
      isPhantom: (0, import_superstruct.boolean)()
    });
    var SuiMoveNormalizedTypeParameterType = (0, import_superstruct.object)({
      TypeParameter: (0, import_superstruct.number)()
    });
    var MoveCallMetric = (0, import_superstruct.tuple)([
      (0, import_superstruct.object)({
        module: (0, import_superstruct.string)(),
        package: (0, import_superstruct.string)(),
        function: (0, import_superstruct.string)()
      }),
      (0, import_superstruct.string)()
    ]);
    var MoveCallMetrics = (0, import_superstruct.object)({
      rank3Days: (0, import_superstruct.array)(MoveCallMetric),
      rank7Days: (0, import_superstruct.array)(MoveCallMetric),
      rank30Days: (0, import_superstruct.array)(MoveCallMetric)
    });
    function isSuiMoveNormalizedType(value) {
      if (!value)
        return false;
      if (typeof value === "string")
        return true;
      if ((0, import_superstruct.is)(value, SuiMoveNormalizedTypeParameterType))
        return true;
      if (isSuiMoveNormalizedStructType(value))
        return true;
      if (typeof value !== "object")
        return false;
      const valueProperties = value;
      if ((0, import_superstruct.is)(valueProperties.Reference, SuiMoveNormalizedType))
        return true;
      if ((0, import_superstruct.is)(valueProperties.MutableReference, SuiMoveNormalizedType))
        return true;
      if ((0, import_superstruct.is)(valueProperties.Vector, SuiMoveNormalizedType))
        return true;
      return false;
    }
    var SuiMoveNormalizedType = (0, import_superstruct.define)("SuiMoveNormalizedType", isSuiMoveNormalizedType);
    function isSuiMoveNormalizedStructType(value) {
      if (!value || typeof value !== "object")
        return false;
      const valueProperties = value;
      if (!valueProperties.Struct || typeof valueProperties.Struct !== "object")
        return false;
      const structProperties = valueProperties.Struct;
      if (typeof structProperties.address !== "string" || typeof structProperties.module !== "string" || typeof structProperties.name !== "string" || !Array.isArray(structProperties.typeArguments) || !structProperties.typeArguments.every((value2) => isSuiMoveNormalizedType(value2))) {
        return false;
      }
      return true;
    }
    var SuiMoveNormalizedStructType = (0, import_superstruct.define)("SuiMoveNormalizedStructType", isSuiMoveNormalizedStructType);
    var SuiMoveNormalizedFunction = (0, import_superstruct.object)({
      visibility: SuiMoveVisibility,
      isEntry: (0, import_superstruct.boolean)(),
      typeParameters: (0, import_superstruct.array)(SuiMoveAbilitySet),
      parameters: (0, import_superstruct.array)(SuiMoveNormalizedType),
      return: (0, import_superstruct.array)(SuiMoveNormalizedType)
    });
    var SuiMoveNormalizedField = (0, import_superstruct.object)({
      name: (0, import_superstruct.string)(),
      type: SuiMoveNormalizedType
    });
    var SuiMoveNormalizedStruct = (0, import_superstruct.object)({
      abilities: SuiMoveAbilitySet,
      typeParameters: (0, import_superstruct.array)(SuiMoveStructTypeParameter),
      fields: (0, import_superstruct.array)(SuiMoveNormalizedField)
    });
    var SuiMoveNormalizedModule = (0, import_superstruct.object)({
      fileFormatVersion: (0, import_superstruct.number)(),
      address: (0, import_superstruct.string)(),
      name: (0, import_superstruct.string)(),
      friends: (0, import_superstruct.array)(SuiMoveModuleId),
      structs: (0, import_superstruct.record)((0, import_superstruct.string)(), SuiMoveNormalizedStruct),
      exposedFunctions: (0, import_superstruct.record)((0, import_superstruct.string)(), SuiMoveNormalizedFunction)
    });
    var SuiMoveNormalizedModules = (0, import_superstruct.record)((0, import_superstruct.string)(), SuiMoveNormalizedModule);
    function extractMutableReference(normalizedType) {
      return typeof normalizedType === "object" && "MutableReference" in normalizedType ? normalizedType.MutableReference : void 0;
    }
    function extractReference(normalizedType) {
      return typeof normalizedType === "object" && "Reference" in normalizedType ? normalizedType.Reference : void 0;
    }
    function extractStructTag(normalizedType) {
      if (typeof normalizedType === "object" && "Struct" in normalizedType) {
        return normalizedType;
      }
      const ref = extractReference(normalizedType);
      const mutRef = extractMutableReference(normalizedType);
      if (typeof ref === "object" && "Struct" in ref) {
        return ref;
      }
      if (typeof mutRef === "object" && "Struct" in mutRef) {
        return mutRef;
      }
      return void 0;
    }
  }
});

// node_modules/@mysten/sui.js/dist/cjs/types/validator.js
var require_validator = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/types/validator.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var validator_exports = {};
    __export2(validator_exports, {
      Apy: () => Apy,
      Balance: () => Balance,
      CommitteeInfo: () => CommitteeInfo,
      Contents: () => Contents,
      ContentsFields: () => ContentsFields,
      ContentsFieldsWithdraw: () => ContentsFieldsWithdraw,
      DelegatedStake: () => DelegatedStake,
      DelegationStakingPool: () => DelegationStakingPool,
      DelegationStakingPoolFields: () => DelegationStakingPoolFields,
      StakeObject: () => StakeObject,
      StakeSubsidy: () => StakeSubsidy,
      StakeSubsidyFields: () => StakeSubsidyFields,
      SuiSupplyFields: () => SuiSupplyFields,
      SuiSystemStateSummary: () => SuiSystemStateSummary,
      SuiValidatorSummary: () => SuiValidatorSummary,
      Validators: () => Validators,
      ValidatorsApy: () => ValidatorsApy
    });
    module2.exports = __toCommonJS(validator_exports);
    var import_superstruct = require_dist2();
    var Apy = (0, import_superstruct.object)({
      apy: (0, import_superstruct.number)(),
      address: (0, import_superstruct.string)()
    });
    var ValidatorsApy = (0, import_superstruct.object)({
      epoch: (0, import_superstruct.string)(),
      apys: (0, import_superstruct.array)(Apy)
    });
    var Balance = (0, import_superstruct.object)({
      value: (0, import_superstruct.number)()
    });
    var StakeObject = (0, import_superstruct.object)({
      stakedSuiId: (0, import_superstruct.string)(),
      stakeRequestEpoch: (0, import_superstruct.string)(),
      stakeActiveEpoch: (0, import_superstruct.string)(),
      principal: (0, import_superstruct.string)(),
      status: (0, import_superstruct.union)([(0, import_superstruct.literal)("Active"), (0, import_superstruct.literal)("Pending"), (0, import_superstruct.literal)("Unstaked")]),
      estimatedReward: (0, import_superstruct.optional)((0, import_superstruct.string)())
    });
    var DelegatedStake = (0, import_superstruct.object)({
      validatorAddress: (0, import_superstruct.string)(),
      stakingPool: (0, import_superstruct.string)(),
      stakes: (0, import_superstruct.array)(StakeObject)
    });
    var StakeSubsidyFields = (0, import_superstruct.object)({
      balance: (0, import_superstruct.object)({value: (0, import_superstruct.number)()}),
      distribution_counter: (0, import_superstruct.number)(),
      current_distribution_amount: (0, import_superstruct.number)(),
      stake_subsidy_period_length: (0, import_superstruct.number)(),
      stake_subsidy_decrease_rate: (0, import_superstruct.number)()
    });
    var StakeSubsidy = (0, import_superstruct.object)({
      type: (0, import_superstruct.string)(),
      fields: StakeSubsidyFields
    });
    var SuiSupplyFields = (0, import_superstruct.object)({
      value: (0, import_superstruct.number)()
    });
    var ContentsFields = (0, import_superstruct.object)({
      id: (0, import_superstruct.string)(),
      size: (0, import_superstruct.number)(),
      head: (0, import_superstruct.object)({vec: (0, import_superstruct.array)()}),
      tail: (0, import_superstruct.object)({vec: (0, import_superstruct.array)()})
    });
    var ContentsFieldsWithdraw = (0, import_superstruct.object)({
      id: (0, import_superstruct.string)(),
      size: (0, import_superstruct.number)()
    });
    var Contents = (0, import_superstruct.object)({
      type: (0, import_superstruct.string)(),
      fields: ContentsFields
    });
    var DelegationStakingPoolFields = (0, import_superstruct.object)({
      exchangeRates: (0, import_superstruct.object)({
        id: (0, import_superstruct.string)(),
        size: (0, import_superstruct.number)()
      }),
      id: (0, import_superstruct.string)(),
      pendingStake: (0, import_superstruct.number)(),
      pendingPoolTokenWithdraw: (0, import_superstruct.number)(),
      pendingTotalSuiWithdraw: (0, import_superstruct.number)(),
      poolTokenBalance: (0, import_superstruct.number)(),
      rewardsPool: (0, import_superstruct.object)({value: (0, import_superstruct.number)()}),
      activationEpoch: (0, import_superstruct.object)({vec: (0, import_superstruct.array)()}),
      deactivationEpoch: (0, import_superstruct.object)({vec: (0, import_superstruct.array)()}),
      suiBalance: (0, import_superstruct.number)()
    });
    var DelegationStakingPool = (0, import_superstruct.object)({
      type: (0, import_superstruct.string)(),
      fields: DelegationStakingPoolFields
    });
    var Validators = (0, import_superstruct.array)((0, import_superstruct.tuple)([(0, import_superstruct.string)(), (0, import_superstruct.string)()]));
    var CommitteeInfo = (0, import_superstruct.object)({
      epoch: (0, import_superstruct.string)(),
      validators: Validators
    });
    var SuiValidatorSummary = (0, import_superstruct.object)({
      suiAddress: (0, import_superstruct.string)(),
      protocolPubkeyBytes: (0, import_superstruct.string)(),
      networkPubkeyBytes: (0, import_superstruct.string)(),
      workerPubkeyBytes: (0, import_superstruct.string)(),
      proofOfPossessionBytes: (0, import_superstruct.string)(),
      operationCapId: (0, import_superstruct.string)(),
      name: (0, import_superstruct.string)(),
      description: (0, import_superstruct.string)(),
      imageUrl: (0, import_superstruct.string)(),
      projectUrl: (0, import_superstruct.string)(),
      p2pAddress: (0, import_superstruct.string)(),
      netAddress: (0, import_superstruct.string)(),
      primaryAddress: (0, import_superstruct.string)(),
      workerAddress: (0, import_superstruct.string)(),
      nextEpochProtocolPubkeyBytes: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
      nextEpochProofOfPossession: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
      nextEpochNetworkPubkeyBytes: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
      nextEpochWorkerPubkeyBytes: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
      nextEpochNetAddress: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
      nextEpochP2pAddress: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
      nextEpochPrimaryAddress: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
      nextEpochWorkerAddress: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
      votingPower: (0, import_superstruct.string)(),
      gasPrice: (0, import_superstruct.string)(),
      commissionRate: (0, import_superstruct.string)(),
      nextEpochStake: (0, import_superstruct.string)(),
      nextEpochGasPrice: (0, import_superstruct.string)(),
      nextEpochCommissionRate: (0, import_superstruct.string)(),
      stakingPoolId: (0, import_superstruct.string)(),
      stakingPoolActivationEpoch: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
      stakingPoolDeactivationEpoch: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
      stakingPoolSuiBalance: (0, import_superstruct.string)(),
      rewardsPool: (0, import_superstruct.string)(),
      poolTokenBalance: (0, import_superstruct.string)(),
      pendingStake: (0, import_superstruct.string)(),
      pendingPoolTokenWithdraw: (0, import_superstruct.string)(),
      pendingTotalSuiWithdraw: (0, import_superstruct.string)(),
      exchangeRatesId: (0, import_superstruct.string)(),
      exchangeRatesSize: (0, import_superstruct.string)()
    });
    var SuiSystemStateSummary = (0, import_superstruct.object)({
      epoch: (0, import_superstruct.string)(),
      protocolVersion: (0, import_superstruct.string)(),
      systemStateVersion: (0, import_superstruct.string)(),
      storageFundTotalObjectStorageRebates: (0, import_superstruct.string)(),
      storageFundNonRefundableBalance: (0, import_superstruct.string)(),
      referenceGasPrice: (0, import_superstruct.string)(),
      safeMode: (0, import_superstruct.boolean)(),
      safeModeStorageRewards: (0, import_superstruct.string)(),
      safeModeComputationRewards: (0, import_superstruct.string)(),
      safeModeStorageRebates: (0, import_superstruct.string)(),
      safeModeNonRefundableStorageFee: (0, import_superstruct.string)(),
      epochStartTimestampMs: (0, import_superstruct.string)(),
      epochDurationMs: (0, import_superstruct.string)(),
      stakeSubsidyStartEpoch: (0, import_superstruct.string)(),
      maxValidatorCount: (0, import_superstruct.string)(),
      minValidatorJoiningStake: (0, import_superstruct.string)(),
      validatorLowStakeThreshold: (0, import_superstruct.string)(),
      validatorVeryLowStakeThreshold: (0, import_superstruct.string)(),
      validatorLowStakeGracePeriod: (0, import_superstruct.string)(),
      stakeSubsidyBalance: (0, import_superstruct.string)(),
      stakeSubsidyDistributionCounter: (0, import_superstruct.string)(),
      stakeSubsidyCurrentDistributionAmount: (0, import_superstruct.string)(),
      stakeSubsidyPeriodLength: (0, import_superstruct.string)(),
      stakeSubsidyDecreaseRate: (0, import_superstruct.number)(),
      totalStake: (0, import_superstruct.string)(),
      activeValidators: (0, import_superstruct.array)(SuiValidatorSummary),
      pendingActiveValidatorsId: (0, import_superstruct.string)(),
      pendingActiveValidatorsSize: (0, import_superstruct.string)(),
      pendingRemovals: (0, import_superstruct.array)((0, import_superstruct.string)()),
      stakingPoolMappingsId: (0, import_superstruct.string)(),
      stakingPoolMappingsSize: (0, import_superstruct.string)(),
      inactivePoolsId: (0, import_superstruct.string)(),
      inactivePoolsSize: (0, import_superstruct.string)(),
      validatorCandidatesId: (0, import_superstruct.string)(),
      validatorCandidatesSize: (0, import_superstruct.string)(),
      atRiskValidators: (0, import_superstruct.array)((0, import_superstruct.tuple)([(0, import_superstruct.string)(), (0, import_superstruct.string)()])),
      validatorReportRecords: (0, import_superstruct.array)((0, import_superstruct.tuple)([(0, import_superstruct.string)(), (0, import_superstruct.array)((0, import_superstruct.string)())]))
    });
  }
});

// node_modules/@mysten/sui.js/dist/cjs/types/coin.js
var require_coin = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/types/coin.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var coin_exports = {};
    __export2(coin_exports, {
      CoinBalance: () => CoinBalance2,
      CoinStruct: () => CoinStruct,
      CoinSupply: () => CoinSupply,
      PaginatedCoins: () => PaginatedCoins
    });
    module2.exports = __toCommonJS(coin_exports);
    var import_superstruct = require_dist2();
    var CoinStruct = (0, import_superstruct.object)({
      coinType: (0, import_superstruct.string)(),
      coinObjectId: (0, import_superstruct.string)(),
      version: (0, import_superstruct.string)(),
      digest: (0, import_superstruct.string)(),
      balance: (0, import_superstruct.string)(),
      previousTransaction: (0, import_superstruct.string)()
    });
    var PaginatedCoins = (0, import_superstruct.object)({
      data: (0, import_superstruct.array)(CoinStruct),
      nextCursor: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
      hasNextPage: (0, import_superstruct.boolean)()
    });
    var CoinBalance2 = (0, import_superstruct.object)({
      coinType: (0, import_superstruct.string)(),
      coinObjectCount: (0, import_superstruct.number)(),
      totalBalance: (0, import_superstruct.string)(),
      lockedBalance: (0, import_superstruct.object)({
        epochId: (0, import_superstruct.optional)((0, import_superstruct.number)()),
        number: (0, import_superstruct.optional)((0, import_superstruct.number)())
      })
    });
    var CoinSupply = (0, import_superstruct.object)({
      value: (0, import_superstruct.string)()
    });
  }
});

// node_modules/@mysten/sui.js/dist/cjs/types/epochs.js
var require_epochs = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/types/epochs.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var epochs_exports = {};
    __export2(epochs_exports, {
      EndOfEpochInfo: () => EndOfEpochInfo,
      EpochInfo: () => EpochInfo,
      EpochPage: () => EpochPage
    });
    module2.exports = __toCommonJS(epochs_exports);
    var import_superstruct = require_dist2();
    var import_validator = require_validator();
    var EndOfEpochInfo = (0, import_superstruct.object)({
      lastCheckpointId: (0, import_superstruct.string)(),
      epochEndTimestamp: (0, import_superstruct.string)(),
      protocolVersion: (0, import_superstruct.string)(),
      referenceGasPrice: (0, import_superstruct.string)(),
      totalStake: (0, import_superstruct.string)(),
      storageFundReinvestment: (0, import_superstruct.string)(),
      storageCharge: (0, import_superstruct.string)(),
      storageRebate: (0, import_superstruct.string)(),
      storageFundBalance: (0, import_superstruct.string)(),
      stakeSubsidyAmount: (0, import_superstruct.string)(),
      totalGasFees: (0, import_superstruct.string)(),
      totalStakeRewardsDistributed: (0, import_superstruct.string)(),
      leftoverStorageFundInflow: (0, import_superstruct.string)()
    });
    var EpochInfo = (0, import_superstruct.object)({
      epoch: (0, import_superstruct.string)(),
      validators: (0, import_superstruct.array)(import_validator.SuiValidatorSummary),
      epochTotalTransactions: (0, import_superstruct.string)(),
      firstCheckpointId: (0, import_superstruct.string)(),
      epochStartTimestamp: (0, import_superstruct.string)(),
      endOfEpochInfo: (0, import_superstruct.nullable)(EndOfEpochInfo),
      referenceGasPrice: (0, import_superstruct.nullable)((0, import_superstruct.number)())
    });
    var EpochPage = (0, import_superstruct.object)({
      data: (0, import_superstruct.array)(EpochInfo),
      nextCursor: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
      hasNextPage: (0, import_superstruct.boolean)()
    });
  }
});

// node_modules/@mysten/sui.js/dist/cjs/types/name-service.js
var require_name_service = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/types/name-service.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var name_service_exports = {};
    __export2(name_service_exports, {
      ResolvedNameServiceNames: () => ResolvedNameServiceNames
    });
    module2.exports = __toCommonJS(name_service_exports);
    var import_superstruct = require_dist2();
    var ResolvedNameServiceNames = (0, import_superstruct.object)({
      data: (0, import_superstruct.array)((0, import_superstruct.string)()),
      hasNextPage: (0, import_superstruct.boolean)(),
      nextCursor: (0, import_superstruct.nullable)((0, import_superstruct.string)())
    });
  }
});

// node_modules/@mysten/sui.js/dist/cjs/types/dynamic_fields.js
var require_dynamic_fields = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/types/dynamic_fields.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var dynamic_fields_exports = {};
    __export2(dynamic_fields_exports, {
      DynamicFieldInfo: () => DynamicFieldInfo,
      DynamicFieldName: () => DynamicFieldName,
      DynamicFieldPage: () => DynamicFieldPage,
      DynamicFieldType: () => DynamicFieldType
    });
    module2.exports = __toCommonJS(dynamic_fields_exports);
    var import_superstruct = require_dist2();
    var DynamicFieldType = (0, import_superstruct.union)([(0, import_superstruct.literal)("DynamicField"), (0, import_superstruct.literal)("DynamicObject")]);
    var DynamicFieldName = (0, import_superstruct.object)({
      type: (0, import_superstruct.string)(),
      value: (0, import_superstruct.any)()
    });
    var DynamicFieldInfo = (0, import_superstruct.object)({
      name: DynamicFieldName,
      bcsName: (0, import_superstruct.string)(),
      type: DynamicFieldType,
      objectType: (0, import_superstruct.string)(),
      objectId: (0, import_superstruct.string)(),
      version: (0, import_superstruct.number)(),
      digest: (0, import_superstruct.string)()
    });
    var DynamicFieldPage = (0, import_superstruct.object)({
      data: (0, import_superstruct.array)(DynamicFieldInfo),
      nextCursor: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
      hasNextPage: (0, import_superstruct.boolean)()
    });
  }
});

// node_modules/@mysten/sui.js/dist/cjs/types/checkpoints.js
var require_checkpoints = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/types/checkpoints.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var checkpoints_exports = {};
    __export2(checkpoints_exports, {
      CheckPointContentsDigest: () => CheckPointContentsDigest,
      Checkpoint: () => Checkpoint,
      CheckpointCommitment: () => CheckpointCommitment,
      CheckpointDigest: () => CheckpointDigest,
      CheckpointPage: () => CheckpointPage,
      ECMHLiveObjectSetDigest: () => ECMHLiveObjectSetDigest,
      EndOfEpochData: () => EndOfEpochData,
      ExecutionDigests: () => ExecutionDigests,
      GasCostSummary: () => GasCostSummary,
      ValidatorSignature: () => ValidatorSignature
    });
    module2.exports = __toCommonJS(checkpoints_exports);
    var import_superstruct = require_dist2();
    var GasCostSummary = (0, import_superstruct.object)({
      computationCost: (0, import_superstruct.string)(),
      storageCost: (0, import_superstruct.string)(),
      storageRebate: (0, import_superstruct.string)(),
      nonRefundableStorageFee: (0, import_superstruct.string)()
    });
    var CheckPointContentsDigest = (0, import_superstruct.string)();
    var CheckpointDigest = (0, import_superstruct.string)();
    var ECMHLiveObjectSetDigest = (0, import_superstruct.object)({
      digest: (0, import_superstruct.array)((0, import_superstruct.number)())
    });
    var CheckpointCommitment = (0, import_superstruct.any)();
    var ValidatorSignature = (0, import_superstruct.string)();
    var EndOfEpochData = (0, import_superstruct.object)({
      nextEpochCommittee: (0, import_superstruct.array)((0, import_superstruct.tuple)([(0, import_superstruct.string)(), (0, import_superstruct.string)()])),
      nextEpochProtocolVersion: (0, import_superstruct.string)(),
      epochCommitments: (0, import_superstruct.array)(CheckpointCommitment)
    });
    var ExecutionDigests = (0, import_superstruct.object)({
      transaction: (0, import_superstruct.string)(),
      effects: (0, import_superstruct.string)()
    });
    var Checkpoint = (0, import_superstruct.object)({
      epoch: (0, import_superstruct.string)(),
      sequenceNumber: (0, import_superstruct.string)(),
      digest: (0, import_superstruct.string)(),
      networkTotalTransactions: (0, import_superstruct.string)(),
      previousDigest: (0, import_superstruct.optional)((0, import_superstruct.string)()),
      epochRollingGasCostSummary: GasCostSummary,
      timestampMs: (0, import_superstruct.string)(),
      endOfEpochData: (0, import_superstruct.optional)(EndOfEpochData),
      validatorSignature: (0, import_superstruct.string)(),
      transactions: (0, import_superstruct.array)((0, import_superstruct.string)()),
      checkpointCommitments: (0, import_superstruct.array)(CheckpointCommitment)
    });
    var CheckpointPage = (0, import_superstruct.object)({
      data: (0, import_superstruct.array)(Checkpoint),
      nextCursor: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
      hasNextPage: (0, import_superstruct.boolean)()
    });
  }
});

// node_modules/@mysten/sui.js/dist/cjs/types/metrics.js
var require_metrics = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/types/metrics.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var metrics_exports = {};
    __export2(metrics_exports, {
      AddressMetrics: () => AddressMetrics,
      AllEpochsAddressMetrics: () => AllEpochsAddressMetrics,
      NetworkMetrics: () => NetworkMetrics
    });
    module2.exports = __toCommonJS(metrics_exports);
    var import_superstruct = require_dist2();
    var NetworkMetrics = (0, import_superstruct.object)({
      currentTps: (0, import_superstruct.number)(),
      tps30Days: (0, import_superstruct.number)(),
      currentCheckpoint: (0, import_superstruct.string)(),
      currentEpoch: (0, import_superstruct.string)(),
      totalAddresses: (0, import_superstruct.string)(),
      totalObjects: (0, import_superstruct.string)(),
      totalPackages: (0, import_superstruct.string)()
    });
    var AddressMetrics = (0, import_superstruct.object)({
      checkpoint: (0, import_superstruct.number)(),
      epoch: (0, import_superstruct.number)(),
      timestampMs: (0, import_superstruct.number)(),
      cumulativeAddresses: (0, import_superstruct.number)(),
      cumulativeActiveAddresses: (0, import_superstruct.number)(),
      dailyActiveAddresses: (0, import_superstruct.number)()
    });
    var AllEpochsAddressMetrics = (0, import_superstruct.array)(AddressMetrics);
  }
});

// node_modules/@mysten/sui.js/dist/cjs/types/index.js
var require_types = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/types/index.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var types_exports = {};
    __export2(types_exports, {
      AddressMetrics: () => import_metrics.AddressMetrics,
      AllEpochsAddressMetrics: () => import_metrics.AllEpochsAddressMetrics,
      Apy: () => import_validator.Apy,
      AuthorityName: () => import_transactions2.AuthorityName,
      AuthoritySignature: () => import_transactions2.AuthoritySignature,
      Balance: () => import_validator.Balance,
      BalanceChange: () => import_transactions2.BalanceChange,
      CheckPointContentsDigest: () => import_checkpoints.CheckPointContentsDigest,
      Checkpoint: () => import_checkpoints.Checkpoint,
      CheckpointCommitment: () => import_checkpoints.CheckpointCommitment,
      CheckpointDigest: () => import_checkpoints.CheckpointDigest,
      CheckpointPage: () => import_checkpoints.CheckpointPage,
      CheckpointedObjectId: () => import_objects.CheckpointedObjectId,
      CoinBalance: () => import_coin.CoinBalance,
      CoinStruct: () => import_coin.CoinStruct,
      CoinSupply: () => import_coin.CoinSupply,
      CommitteeInfo: () => import_validator.CommitteeInfo,
      Contents: () => import_validator2.Contents,
      ContentsFields: () => import_validator2.ContentsFields,
      ContentsFieldsWithdraw: () => import_validator2.ContentsFieldsWithdraw,
      DelegatedStake: () => import_validator.DelegatedStake,
      DelegationStakingPool: () => import_validator2.DelegationStakingPool,
      DelegationStakingPoolFields: () => import_validator2.DelegationStakingPoolFields,
      DevInspectResults: () => import_transactions2.DevInspectResults,
      DisplayFieldsBackwardCompatibleResponse: () => import_objects.DisplayFieldsBackwardCompatibleResponse,
      DisplayFieldsResponse: () => import_objects.DisplayFieldsResponse,
      DryRunTransactionBlockResponse: () => import_transactions2.DryRunTransactionBlockResponse,
      DynamicFieldInfo: () => import_dynamic_fields.DynamicFieldInfo,
      DynamicFieldName: () => import_dynamic_fields.DynamicFieldName,
      DynamicFieldPage: () => import_dynamic_fields.DynamicFieldPage,
      DynamicFieldType: () => import_dynamic_fields.DynamicFieldType,
      EndOfEpochData: () => import_checkpoints.EndOfEpochData,
      EndOfEpochInfo: () => import_epochs.EndOfEpochInfo,
      EpochId: () => import_transactions2.EpochId,
      EpochInfo: () => import_epochs.EpochInfo,
      EpochPage: () => import_epochs.EpochPage,
      EventId: () => import_events.EventId,
      ExecutionStatus: () => import_transactions2.ExecutionStatus,
      ExecutionStatusType: () => import_transactions2.ExecutionStatusType,
      GasCostSummary: () => import_checkpoints.GasCostSummary,
      Genesis: () => import_transactions2.Genesis,
      GetOwnedObjectsResponse: () => import_objects.GetOwnedObjectsResponse,
      MoveCallMetric: () => import_normalized.MoveCallMetric,
      MoveCallMetrics: () => import_normalized.MoveCallMetrics,
      MoveCallSuiTransaction: () => import_transactions2.MoveCallSuiTransaction,
      MovePackageContent: () => import_objects.MovePackageContent,
      NetworkMetrics: () => import_metrics.NetworkMetrics,
      ObjectContentFields: () => import_objects.ObjectContentFields,
      ObjectDigest: () => import_objects.ObjectDigest,
      ObjectId: () => import_common.ObjectId,
      ObjectOwner: () => import_common.ObjectOwner,
      ObjectRead: () => import_objects.ObjectRead,
      ObjectStatus: () => import_objects.ObjectStatus,
      ObjectType: () => import_objects.ObjectType,
      OwnedObjectRef: () => import_transactions2.OwnedObjectRef,
      PaginatedCoins: () => import_coin.PaginatedCoins,
      PaginatedEvents: () => import_events.PaginatedEvents,
      PaginatedObjectsResponse: () => import_objects.PaginatedObjectsResponse,
      PaginatedTransactionResponse: () => import_transactions2.PaginatedTransactionResponse,
      ProgrammableTransaction: () => import_transactions2.ProgrammableTransaction,
      ProtocolConfig: () => import_common.ProtocolConfig,
      ResolvedNameServiceNames: () => import_name_service.ResolvedNameServiceNames,
      SequenceNumber: () => import_common.SequenceNumber,
      StakeObject: () => import_validator.StakeObject,
      StakeSubsidy: () => import_validator2.StakeSubsidy,
      StakeSubsidyFields: () => import_validator2.StakeSubsidyFields,
      SuiAddress: () => import_common.SuiAddress,
      SuiArgument: () => import_transactions2.SuiArgument,
      SuiCallArg: () => import_transactions2.SuiCallArg,
      SuiChangeEpoch: () => import_transactions2.SuiChangeEpoch,
      SuiConsensusCommitPrologue: () => import_transactions2.SuiConsensusCommitPrologue,
      SuiEvent: () => import_events.SuiEvent,
      SuiGasData: () => import_objects.SuiGasData,
      SuiJsonValue: () => import_common.SuiJsonValue,
      SuiMoveAbilitySet: () => import_normalized.SuiMoveAbilitySet,
      SuiMoveFunctionArgType: () => import_normalized.SuiMoveFunctionArgType,
      SuiMoveFunctionArgTypes: () => import_normalized.SuiMoveFunctionArgTypes,
      SuiMoveModuleId: () => import_normalized.SuiMoveModuleId,
      SuiMoveNormalizedField: () => import_normalized.SuiMoveNormalizedField,
      SuiMoveNormalizedFunction: () => import_normalized.SuiMoveNormalizedFunction,
      SuiMoveNormalizedModule: () => import_normalized.SuiMoveNormalizedModule,
      SuiMoveNormalizedModules: () => import_normalized.SuiMoveNormalizedModules,
      SuiMoveNormalizedStruct: () => import_normalized.SuiMoveNormalizedStruct,
      SuiMoveNormalizedStructType: () => import_normalized.SuiMoveNormalizedStructType,
      SuiMoveNormalizedType: () => import_normalized.SuiMoveNormalizedType,
      SuiMoveNormalizedTypeParameterType: () => import_normalized.SuiMoveNormalizedTypeParameterType,
      SuiMoveObject: () => import_objects.SuiMoveObject,
      SuiMovePackage: () => import_objects.SuiMovePackage,
      SuiMoveStructTypeParameter: () => import_normalized.SuiMoveStructTypeParameter,
      SuiMoveVisibility: () => import_normalized.SuiMoveVisibility,
      SuiObjectChange: () => import_transactions2.SuiObjectChange,
      SuiObjectChangeCreated: () => import_transactions2.SuiObjectChangeCreated,
      SuiObjectChangeDeleted: () => import_transactions2.SuiObjectChangeDeleted,
      SuiObjectChangeMutated: () => import_transactions2.SuiObjectChangeMutated,
      SuiObjectChangePublished: () => import_transactions2.SuiObjectChangePublished,
      SuiObjectChangeTransferred: () => import_transactions2.SuiObjectChangeTransferred,
      SuiObjectChangeWrapped: () => import_transactions2.SuiObjectChangeWrapped,
      SuiObjectData: () => import_objects.SuiObjectData,
      SuiObjectDataOptions: () => import_objects.SuiObjectDataOptions,
      SuiObjectInfo: () => import_objects.SuiObjectInfo,
      SuiObjectRef: () => import_objects.SuiObjectRef,
      SuiObjectResponse: () => import_objects.SuiObjectResponse,
      SuiObjectResponseError: () => import_objects.SuiObjectResponseError,
      SuiParsedData: () => import_objects.SuiParsedData,
      SuiRawData: () => import_objects.SuiRawData,
      SuiRawMoveObject: () => import_objects.SuiRawMoveObject,
      SuiRawMovePackage: () => import_objects.SuiRawMovePackage,
      SuiSupplyFields: () => import_validator2.SuiSupplyFields,
      SuiSystemStateSummary: () => import_validator.SuiSystemStateSummary,
      SuiTransaction: () => import_transactions2.SuiTransaction,
      SuiTransactionBlock: () => import_transactions2.SuiTransactionBlock,
      SuiTransactionBlockData: () => import_transactions2.SuiTransactionBlockData,
      SuiTransactionBlockResponse: () => import_transactions2.SuiTransactionBlockResponse,
      SuiTransactionBlockResponseOptions: () => import_transactions2.SuiTransactionBlockResponseOptions,
      SuiValidatorSummary: () => import_validator.SuiValidatorSummary,
      TransactionDigest: () => import_common.TransactionDigest,
      TransactionEffects: () => import_transactions2.TransactionEffects,
      TransactionEffectsDigest: () => import_common.TransactionEffectsDigest,
      TransactionEffectsModifiedAtVersions: () => import_transactions2.TransactionEffectsModifiedAtVersions,
      TransactionEventDigest: () => import_common.TransactionEventDigest,
      TransactionEvents: () => import_transactions2.TransactionEvents,
      ValidatorSignature: () => import_checkpoints.ValidatorSignature,
      Validators: () => import_validator.Validators,
      ValidatorsApy: () => import_validator.ValidatorsApy,
      extractMutableReference: () => import_normalized.extractMutableReference,
      extractReference: () => import_normalized.extractReference,
      extractStructTag: () => import_normalized.extractStructTag,
      getChangeEpochTransaction: () => import_transactions2.getChangeEpochTransaction,
      getConsensusCommitPrologueTransaction: () => import_transactions2.getConsensusCommitPrologueTransaction,
      getCreatedObjects: () => import_transactions2.getCreatedObjects,
      getEventPackage: () => import_events.getEventPackage,
      getEventSender: () => import_events.getEventSender,
      getEvents: () => import_transactions2.getEvents,
      getExecutionStatus: () => import_transactions2.getExecutionStatus,
      getExecutionStatusError: () => import_transactions2.getExecutionStatusError,
      getExecutionStatusGasSummary: () => import_transactions2.getExecutionStatusGasSummary,
      getExecutionStatusType: () => import_transactions2.getExecutionStatusType,
      getGasData: () => import_transactions2.getGasData,
      getMoveObject: () => import_objects.getMoveObject,
      getMoveObjectType: () => import_objects.getMoveObjectType,
      getMovePackageContent: () => import_objects.getMovePackageContent,
      getNewlyCreatedCoinRefsAfterSplit: () => import_transactions2.getNewlyCreatedCoinRefsAfterSplit,
      getObjectChanges: () => import_transactions2.getObjectChanges,
      getObjectDeletedResponse: () => import_objects.getObjectDeletedResponse,
      getObjectDisplay: () => import_objects.getObjectDisplay,
      getObjectFields: () => import_objects.getObjectFields,
      getObjectId: () => import_objects.getObjectId,
      getObjectNotExistsResponse: () => import_objects.getObjectNotExistsResponse,
      getObjectOwner: () => import_objects.getObjectOwner,
      getObjectPreviousTransactionDigest: () => import_objects.getObjectPreviousTransactionDigest,
      getObjectReference: () => import_objects.getObjectReference,
      getObjectType: () => import_objects.getObjectType,
      getObjectVersion: () => import_objects.getObjectVersion,
      getProgrammableTransaction: () => import_transactions2.getProgrammableTransaction,
      getPublishedObjectChanges: () => import_transactions2.getPublishedObjectChanges,
      getSharedObjectInitialVersion: () => import_objects.getSharedObjectInitialVersion,
      getSuiObjectData: () => import_objects.getSuiObjectData,
      getTimestampFromTransactionResponse: () => import_transactions2.getTimestampFromTransactionResponse,
      getTotalGasUsed: () => import_transactions2.getTotalGasUsed,
      getTotalGasUsedUpperBound: () => import_transactions2.getTotalGasUsedUpperBound,
      getTransaction: () => import_transactions2.getTransaction,
      getTransactionDigest: () => import_transactions2.getTransactionDigest,
      getTransactionEffects: () => import_transactions2.getTransactionEffects,
      getTransactionGasBudget: () => import_transactions2.getTransactionGasBudget,
      getTransactionGasObject: () => import_transactions2.getTransactionGasObject,
      getTransactionGasPrice: () => import_transactions2.getTransactionGasPrice,
      getTransactionKind: () => import_transactions2.getTransactionKind,
      getTransactionKindName: () => import_transactions2.getTransactionKindName,
      getTransactionSender: () => import_transactions2.getTransactionSender,
      getTransactionSignature: () => import_transactions2.getTransactionSignature,
      hasPublicTransfer: () => import_objects.hasPublicTransfer,
      isImmutableObject: () => import_objects.isImmutableObject,
      isSharedObject: () => import_objects.isSharedObject,
      isSuiObjectResponse: () => import_objects.isSuiObjectResponse
    });
    module2.exports = __toCommonJS(types_exports);
    var import_common = require_common();
    var import_objects = require_objects();
    var import_events = require_events();
    var import_transactions2 = require_transactions();
    var import_normalized = require_normalized();
    var import_validator = require_validator();
    var import_coin = require_coin();
    var import_epochs = require_epochs();
    var import_name_service = require_name_service();
    var import_dynamic_fields = require_dynamic_fields();
    var import_checkpoints = require_checkpoints();
    var import_metrics = require_metrics();
    var import_validator2 = require_validator();
  }
});

// node_modules/@mysten/sui.js/dist/cjs/types/option.js
var require_option = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/types/option.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var option_exports = {};
    __export2(option_exports, {
      getOption: () => getOption
    });
    module2.exports = __toCommonJS(option_exports);
    function getOption(option) {
      if (typeof option === "object" && option !== null && "type" in option && option.type.startsWith("0x1::option::Option<")) {
        return void 0;
      }
      return option;
    }
  }
});

// node_modules/@mysten/sui.js/dist/cjs/framework/framework.js
var require_framework = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/framework/framework.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var framework_exports = {};
    __export2(framework_exports, {
      COIN_TYPE_ARG_REGEX: () => COIN_TYPE_ARG_REGEX,
      Coin: () => Coin,
      CoinMetadataStruct: () => CoinMetadataStruct,
      Delegation: () => Delegation,
      ID_STRUCT_NAME: () => ID_STRUCT_NAME,
      MOVE_STDLIB_ADDRESS: () => MOVE_STDLIB_ADDRESS,
      OBJECT_MODULE_NAME: () => OBJECT_MODULE_NAME,
      PAY_JOIN_COIN_FUNC_NAME: () => PAY_JOIN_COIN_FUNC_NAME,
      PAY_MODULE_NAME: () => PAY_MODULE_NAME,
      PAY_SPLIT_COIN_VEC_FUNC_NAME: () => PAY_SPLIT_COIN_VEC_FUNC_NAME,
      SUI_CLOCK_OBJECT_ID: () => SUI_CLOCK_OBJECT_ID,
      SUI_FRAMEWORK_ADDRESS: () => SUI_FRAMEWORK_ADDRESS,
      SUI_SYSTEM_ADDRESS: () => SUI_SYSTEM_ADDRESS,
      SUI_TYPE_ARG: () => SUI_TYPE_ARG2,
      UID_STRUCT_NAME: () => UID_STRUCT_NAME,
      VALIDATORS_EVENTS_QUERY: () => VALIDATORS_EVENTS_QUERY,
      isObjectDataFull: () => isObjectDataFull
    });
    module2.exports = __toCommonJS(framework_exports);
    var import_objects = require_objects();
    var import_option = require_option();
    var import_superstruct = require_dist2();
    var import_sui_types = require_sui_types();
    var SUI_SYSTEM_ADDRESS = "0x3";
    var SUI_FRAMEWORK_ADDRESS = "0x2";
    var MOVE_STDLIB_ADDRESS = "0x1";
    var OBJECT_MODULE_NAME = "object";
    var UID_STRUCT_NAME = "UID";
    var ID_STRUCT_NAME = "ID";
    var SUI_TYPE_ARG2 = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;
    var VALIDATORS_EVENTS_QUERY = "0x3::validator_set::ValidatorEpochInfoEventV2";
    var SUI_CLOCK_OBJECT_ID = (0, import_sui_types.normalizeSuiObjectId)("0x6");
    var PAY_MODULE_NAME = "pay";
    var PAY_SPLIT_COIN_VEC_FUNC_NAME = "split_vec";
    var PAY_JOIN_COIN_FUNC_NAME = "join";
    var COIN_TYPE_ARG_REGEX = /^0x2::coin::Coin<(.+)>$/;
    function isObjectDataFull(resp) {
      return !!resp.data || !!resp.type;
    }
    var CoinMetadataStruct = (0, import_superstruct.object)({
      decimals: (0, import_superstruct.number)(),
      name: (0, import_superstruct.string)(),
      symbol: (0, import_superstruct.string)(),
      description: (0, import_superstruct.string)(),
      iconUrl: (0, import_superstruct.nullable)((0, import_superstruct.string)()),
      id: (0, import_superstruct.nullable)((0, import_superstruct.string)())
    });
    var Coin = class {
      static isCoin(data) {
        return Coin.getType(data)?.match(COIN_TYPE_ARG_REGEX) != null;
      }
      static getCoinType(type) {
        const [, res] = type.match(COIN_TYPE_ARG_REGEX) ?? [];
        return res || null;
      }
      static getCoinTypeArg(obj) {
        const type = Coin.getType(obj);
        return type ? Coin.getCoinType(type) : null;
      }
      static isSUI(obj) {
        const arg = Coin.getCoinTypeArg(obj);
        return arg ? Coin.getCoinSymbol(arg) === "SUI" : false;
      }
      static getCoinSymbol(coinTypeArg) {
        return coinTypeArg.substring(coinTypeArg.lastIndexOf(":") + 1);
      }
      static getCoinStructTag(coinTypeArg) {
        return {
          address: (0, import_sui_types.normalizeSuiObjectId)(coinTypeArg.split("::")[0]),
          module: coinTypeArg.split("::")[1],
          name: coinTypeArg.split("::")[2],
          typeParams: []
        };
      }
      static getID(obj) {
        if ("fields" in obj) {
          return obj.fields.id.id;
        }
        return (0, import_objects.getObjectId)(obj);
      }
      static totalBalance(coins) {
        return coins.reduce((partialSum, c) => partialSum + Coin.getBalanceFromCoinStruct(c), BigInt(0));
      }
      static sortByBalance(coins) {
        return [...coins].sort((a, b) => Coin.getBalanceFromCoinStruct(a) < Coin.getBalanceFromCoinStruct(b) ? -1 : Coin.getBalanceFromCoinStruct(a) > Coin.getBalanceFromCoinStruct(b) ? 1 : 0);
      }
      static getBalanceFromCoinStruct(coin) {
        return BigInt(coin.balance);
      }
      static getBalance(data) {
        if (!Coin.isCoin(data)) {
          return void 0;
        }
        const balance = (0, import_objects.getObjectFields)(data)?.balance;
        return BigInt(balance);
      }
      static getType(data) {
        if (isObjectDataFull(data)) {
          return (0, import_objects.getObjectType)(data);
        }
        return data.type;
      }
    };
    var _Delegation = class _Delegation2 {
      static isDelegationSuiObject(obj) {
        return "type" in obj && obj.type === _Delegation2.SUI_OBJECT_TYPE;
      }
      constructor(obj) {
        this.suiObject = obj;
      }
      nextRewardUnclaimedEpoch() {
        return this.suiObject.data.fields.next_reward_unclaimed_epoch;
      }
      activeDelegation() {
        return BigInt((0, import_option.getOption)(this.suiObject.data.fields.active_delegation) || 0);
      }
      delegateAmount() {
        return this.suiObject.data.fields.delegate_amount;
      }
      endingEpoch() {
        return (0, import_option.getOption)(this.suiObject.data.fields.ending_epoch);
      }
      validatorAddress() {
        return this.suiObject.data.fields.validator_address;
      }
      isActive() {
        return this.activeDelegation() > 0 && !this.endingEpoch();
      }
      hasUnclaimedRewards(epoch) {
        return this.nextRewardUnclaimedEpoch() <= epoch && (this.isActive() || (this.endingEpoch() || 0) > epoch);
      }
    };
    _Delegation.SUI_OBJECT_TYPE = "0x2::delegation::Delegation";
    var Delegation = _Delegation;
  }
});

// node_modules/@mysten/sui.js/dist/cjs/builder/serializer.js
var require_serializer = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/builder/serializer.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var serializer_exports = {};
    __export2(serializer_exports, {
      getPureSerializationType: () => getPureSerializationType,
      isTxContext: () => isTxContext
    });
    module2.exports = __toCommonJS(serializer_exports);
    var import_sui_types = require_sui_types();
    var import_types = require_types();
    var import_framework = require_framework();
    var STD_ASCII_MODULE_NAME = "ascii";
    var STD_ASCII_STRUCT_NAME = "String";
    var STD_UTF8_MODULE_NAME = "string";
    var STD_UTF8_STRUCT_NAME = "String";
    var STD_OPTION_MODULE_NAME = "option";
    var STD_OPTION_STRUCT_NAME = "Option";
    var RESOLVED_SUI_ID = {
      address: import_framework.SUI_FRAMEWORK_ADDRESS,
      module: import_framework.OBJECT_MODULE_NAME,
      name: import_framework.ID_STRUCT_NAME
    };
    var RESOLVED_ASCII_STR = {
      address: import_framework.MOVE_STDLIB_ADDRESS,
      module: STD_ASCII_MODULE_NAME,
      name: STD_ASCII_STRUCT_NAME
    };
    var RESOLVED_UTF8_STR = {
      address: import_framework.MOVE_STDLIB_ADDRESS,
      module: STD_UTF8_MODULE_NAME,
      name: STD_UTF8_STRUCT_NAME
    };
    var RESOLVED_STD_OPTION = {
      address: import_framework.MOVE_STDLIB_ADDRESS,
      module: STD_OPTION_MODULE_NAME,
      name: STD_OPTION_STRUCT_NAME
    };
    var isSameStruct = (a, b) => a.address === b.address && a.module === b.module && a.name === b.name;
    function isTxContext(param) {
      const struct = (0, import_types.extractStructTag)(param)?.Struct;
      return struct?.address === "0x2" && struct?.module === "tx_context" && struct?.name === "TxContext";
    }
    function expectType(typeName, argVal) {
      if (typeof argVal === "undefined") {
        return;
      }
      if (typeof argVal !== typeName) {
        throw new Error(`Expect ${argVal} to be ${typeName}, received ${typeof argVal}`);
      }
    }
    var allowedTypes = ["Address", "Bool", "U8", "U16", "U32", "U64", "U128", "U256"];
    function getPureSerializationType(normalizedType, argVal) {
      if (typeof normalizedType === "string" && allowedTypes.includes(normalizedType)) {
        if (normalizedType in ["U8", "U16", "U32", "U64", "U128", "U256"]) {
          expectType("number", argVal);
        } else if (normalizedType === "Bool") {
          expectType("boolean", argVal);
        } else if (normalizedType === "Address") {
          expectType("string", argVal);
          if (argVal && !(0, import_sui_types.isValidSuiAddress)(argVal)) {
            throw new Error("Invalid Sui Address");
          }
        }
        return normalizedType.toLowerCase();
      } else if (typeof normalizedType === "string") {
        throw new Error(`Unknown pure normalized type ${JSON.stringify(normalizedType, null, 2)}`);
      }
      if ("Vector" in normalizedType) {
        if ((argVal === void 0 || typeof argVal === "string") && normalizedType.Vector === "U8") {
          return "string";
        }
        if (argVal !== void 0 && !Array.isArray(argVal)) {
          throw new Error(`Expect ${argVal} to be a array, received ${typeof argVal}`);
        }
        const innerType = getPureSerializationType(normalizedType.Vector, argVal ? argVal[0] : void 0);
        if (innerType === void 0) {
          return;
        }
        return `vector<${innerType}>`;
      }
      if ("Struct" in normalizedType) {
        if (isSameStruct(normalizedType.Struct, RESOLVED_ASCII_STR)) {
          return "string";
        } else if (isSameStruct(normalizedType.Struct, RESOLVED_UTF8_STR)) {
          return "utf8string";
        } else if (isSameStruct(normalizedType.Struct, RESOLVED_SUI_ID)) {
          return "address";
        } else if (isSameStruct(normalizedType.Struct, RESOLVED_STD_OPTION)) {
          const optionToVec = {
            Vector: normalizedType.Struct.typeArguments[0]
          };
          return getPureSerializationType(optionToVec, argVal);
        }
      }
      return void 0;
    }
  }
});

// node_modules/@mysten/sui.js/dist/cjs/bcs/type-tag-serializer.js
var require_type_tag_serializer = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/bcs/type-tag-serializer.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var type_tag_serializer_exports = {};
    __export2(type_tag_serializer_exports, {
      TypeTagSerializer: () => TypeTagSerializer
    });
    module2.exports = __toCommonJS(type_tag_serializer_exports);
    var import_bcs = require_dist();
    var import_sui_types = require_sui_types();
    var VECTOR_REGEX = /^vector<(.+)>$/;
    var STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
    var TypeTagSerializer = class {
      static parseFromStr(str, normalizeAddress = false) {
        if (str === "address") {
          return {address: null};
        } else if (str === "bool") {
          return {bool: null};
        } else if (str === "u8") {
          return {u8: null};
        } else if (str === "u16") {
          return {u16: null};
        } else if (str === "u32") {
          return {u32: null};
        } else if (str === "u64") {
          return {u64: null};
        } else if (str === "u128") {
          return {u128: null};
        } else if (str === "u256") {
          return {u256: null};
        } else if (str === "signer") {
          return {signer: null};
        }
        const vectorMatch = str.match(VECTOR_REGEX);
        if (vectorMatch) {
          return {
            vector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress)
          };
        }
        const structMatch = str.match(STRUCT_REGEX);
        if (structMatch) {
          const address2 = normalizeAddress ? (0, import_sui_types.normalizeSuiAddress)(structMatch[1]) : structMatch[1];
          return {
            struct: {
              address: address2,
              module: structMatch[2],
              name: structMatch[3],
              typeParams: structMatch[5] === void 0 ? [] : TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)
            }
          };
        }
        throw new Error(`Encountered unexpected token when parsing type args for ${str}`);
      }
      static parseStructTypeArgs(str, normalizeAddress = false) {
        return (0, import_bcs.splitGenericParameters)(str).map((tok) => TypeTagSerializer.parseFromStr(tok, normalizeAddress));
      }
      static tagToString(tag) {
        if ("bool" in tag) {
          return "bool";
        }
        if ("u8" in tag) {
          return "u8";
        }
        if ("u16" in tag) {
          return "u16";
        }
        if ("u32" in tag) {
          return "u32";
        }
        if ("u64" in tag) {
          return "u64";
        }
        if ("u128" in tag) {
          return "u128";
        }
        if ("u256" in tag) {
          return "u256";
        }
        if ("address" in tag) {
          return "address";
        }
        if ("signer" in tag) {
          return "signer";
        }
        if ("vector" in tag) {
          return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;
        }
        if ("struct" in tag) {
          const struct = tag.struct;
          const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(", ");
          return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
        }
        throw new Error("Invalid TypeTag");
      }
    };
  }
});

// node_modules/@mysten/sui.js/dist/cjs/bcs/index.js
var require_bcs = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/bcs/index.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var bcs_exports = {};
    __export2(bcs_exports, {
      TypeTagSerializer: () => import_type_tag_serializer.TypeTagSerializer,
      bcs: () => bcs,
      isPureArg: () => isPureArg
    });
    module2.exports = __toCommonJS(bcs_exports);
    var import_bcs = require_dist();
    var import_type_tag_serializer = require_type_tag_serializer();
    function isPureArg(arg) {
      return arg.Pure !== void 0;
    }
    var VECTOR = "vector";
    var TransactionDataV1 = {
      kind: "TransactionKind",
      sender: import_bcs.BCS.ADDRESS,
      gasData: "GasData",
      expiration: "TransactionExpiration"
    };
    var BCS_SPEC = {
      enums: {
        "Option<T>": {
          None: null,
          Some: "T"
        },
        ObjectArg: {
          ImmOrOwned: "SuiObjectRef",
          Shared: "SharedObjectRef"
        },
        CallArg: {
          Pure: [VECTOR, import_bcs.BCS.U8],
          Object: "ObjectArg",
          ObjVec: [VECTOR, "ObjectArg"]
        },
        TypeTag: {
          bool: null,
          u8: null,
          u64: null,
          u128: null,
          address: null,
          signer: null,
          vector: "TypeTag",
          struct: "StructTag",
          u16: null,
          u32: null,
          u256: null
        },
        TransactionKind: {
          ProgrammableTransaction: "ProgrammableTransaction",
          ChangeEpoch: null,
          Genesis: null,
          ConsensusCommitPrologue: null
        },
        TransactionExpiration: {
          None: null,
          Epoch: "unsafe_u64"
        },
        TransactionData: {
          V1: "TransactionDataV1"
        }
      },
      structs: {
        SuiObjectRef: {
          objectId: import_bcs.BCS.ADDRESS,
          version: import_bcs.BCS.U64,
          digest: "ObjectDigest"
        },
        SharedObjectRef: {
          objectId: import_bcs.BCS.ADDRESS,
          initialSharedVersion: import_bcs.BCS.U64,
          mutable: import_bcs.BCS.BOOL
        },
        StructTag: {
          address: import_bcs.BCS.ADDRESS,
          module: import_bcs.BCS.STRING,
          name: import_bcs.BCS.STRING,
          typeParams: [VECTOR, "TypeTag"]
        },
        GasData: {
          payment: [VECTOR, "SuiObjectRef"],
          owner: import_bcs.BCS.ADDRESS,
          price: import_bcs.BCS.U64,
          budget: import_bcs.BCS.U64
        },
        SenderSignedData: {
          data: "TransactionData",
          txSignatures: [VECTOR, [VECTOR, import_bcs.BCS.U8]]
        },
        TransactionDataV1
      },
      aliases: {
        ObjectDigest: import_bcs.BCS.BASE58
      }
    };
    var bcs = new import_bcs.BCS({...(0, import_bcs.getSuiMoveConfig)(), types: BCS_SPEC});
    bcs.registerType("utf8string", (writer, str) => {
      const bytes = Array.from(new TextEncoder().encode(str));
      return writer.writeVec(bytes, (writer2, el) => writer2.write8(el));
    }, (reader) => {
      let bytes = reader.readVec((reader2) => reader2.read8());
      return new TextDecoder().decode(new Uint8Array(bytes));
    });
    bcs.registerType("unsafe_u64", (writer, data) => writer.write64(data), (reader) => Number.parseInt(reader.read64(), 10));
  }
});

// node_modules/@mysten/sui.js/dist/cjs/builder/bcs.js
var require_bcs2 = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/builder/bcs.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var bcs_exports = {};
    __export2(bcs_exports, {
      ARGUMENT: () => ARGUMENT,
      ARGUMENT_INNER: () => ARGUMENT_INNER,
      CALL_ARG: () => CALL_ARG,
      COMPRESSED_SIGNATURE: () => COMPRESSED_SIGNATURE,
      ENUM_KIND: () => ENUM_KIND,
      MULTISIG: () => MULTISIG,
      MULTISIG_PK_MAP: () => MULTISIG_PK_MAP,
      MULTISIG_PUBLIC_KEY: () => MULTISIG_PUBLIC_KEY,
      OBJECT_ARG: () => OBJECT_ARG,
      OPTION: () => OPTION,
      PROGRAMMABLE_CALL: () => PROGRAMMABLE_CALL,
      PROGRAMMABLE_CALL_INNER: () => PROGRAMMABLE_CALL_INNER,
      PROGRAMMABLE_TX_BLOCK: () => PROGRAMMABLE_TX_BLOCK,
      PUBLIC_KEY: () => PUBLIC_KEY,
      TRANSACTION: () => TRANSACTION,
      TRANSACTION_INNER: () => TRANSACTION_INNER,
      TYPE_TAG: () => TYPE_TAG,
      VECTOR: () => VECTOR,
      builder: () => builder
    });
    module2.exports = __toCommonJS(bcs_exports);
    var import_bcs = require_dist();
    var import_bcs2 = require_bcs();
    var import_bcs3 = require_bcs();
    var import_sui_types = require_sui_types();
    var ARGUMENT_INNER = "Argument";
    var VECTOR = "vector";
    var OPTION = "Option";
    var CALL_ARG = "CallArg";
    var TYPE_TAG = "TypeTag";
    var OBJECT_ARG = "ObjectArg";
    var PROGRAMMABLE_TX_BLOCK = "ProgrammableTransaction";
    var PROGRAMMABLE_CALL_INNER = "ProgrammableMoveCall";
    var TRANSACTION_INNER = "Transaction";
    var COMPRESSED_SIGNATURE = "CompressedSignature";
    var PUBLIC_KEY = "PublicKey";
    var MULTISIG_PUBLIC_KEY = "MultiSigPublicKey";
    var MULTISIG_PK_MAP = "MultiSigPkMap";
    var MULTISIG = "MultiSig";
    var ENUM_KIND = "EnumKind";
    var TRANSACTION = [ENUM_KIND, TRANSACTION_INNER];
    var ARGUMENT = [ENUM_KIND, ARGUMENT_INNER];
    var PROGRAMMABLE_CALL = "SimpleProgrammableMoveCall";
    var builder = new import_bcs.BCS(import_bcs2.bcs);
    registerFixedArray(builder, "FixedArray[64]", 64);
    registerFixedArray(builder, "FixedArray[33]", 33);
    registerFixedArray(builder, "FixedArray[32]", 32);
    builder.registerStructType(PROGRAMMABLE_TX_BLOCK, {
      inputs: [VECTOR, CALL_ARG],
      transactions: [VECTOR, TRANSACTION]
    }).registerEnumType(ARGUMENT_INNER, {
      GasCoin: null,
      Input: {index: import_bcs.BCS.U16},
      Result: {index: import_bcs.BCS.U16},
      NestedResult: {index: import_bcs.BCS.U16, resultIndex: import_bcs.BCS.U16}
    }).registerStructType(PROGRAMMABLE_CALL_INNER, {
      package: import_bcs.BCS.ADDRESS,
      module: import_bcs.BCS.STRING,
      function: import_bcs.BCS.STRING,
      type_arguments: [VECTOR, TYPE_TAG],
      arguments: [VECTOR, ARGUMENT]
    }).registerEnumType(TRANSACTION_INNER, {
      MoveCall: PROGRAMMABLE_CALL,
      TransferObjects: {
        objects: [VECTOR, ARGUMENT],
        address: ARGUMENT
      },
      SplitCoins: {coin: ARGUMENT, amounts: [VECTOR, ARGUMENT]},
      MergeCoins: {destination: ARGUMENT, sources: [VECTOR, ARGUMENT]},
      Publish: {
        modules: [VECTOR, [VECTOR, import_bcs.BCS.U8]],
        dependencies: [VECTOR, import_bcs.BCS.ADDRESS]
      },
      MakeMoveVec: {
        type: [OPTION, TYPE_TAG],
        objects: [VECTOR, ARGUMENT]
      },
      Upgrade: {
        modules: [VECTOR, [VECTOR, import_bcs.BCS.U8]],
        dependencies: [VECTOR, import_bcs.BCS.ADDRESS],
        packageId: import_bcs.BCS.ADDRESS,
        ticket: ARGUMENT
      }
    }).registerEnumType(COMPRESSED_SIGNATURE, {
      ED25519: ["FixedArray[64]", "u8"],
      Secp256k1: ["FixedArray[64]", "u8"],
      Secp256r1: ["FixedArray[64]", "u8"]
    }).registerEnumType(PUBLIC_KEY, {
      ED25519: ["FixedArray[32]", "u8"],
      Secp256k1: ["FixedArray[33]", "u8"],
      Secp256r1: ["FixedArray[33]", "u8"]
    }).registerStructType(MULTISIG_PK_MAP, {
      pubKey: PUBLIC_KEY,
      weight: import_bcs.BCS.U8
    }).registerStructType(MULTISIG_PUBLIC_KEY, {
      pk_map: [VECTOR, MULTISIG_PK_MAP],
      threshold: import_bcs.BCS.U16
    }).registerStructType(MULTISIG, {
      sigs: [VECTOR, COMPRESSED_SIGNATURE],
      bitmap: import_bcs.BCS.U16,
      multisig_pk: MULTISIG_PUBLIC_KEY
    });
    builder.registerType([ENUM_KIND, "T"], function encode(writer, data, typeParams, typeMap) {
      const kind = data.kind;
      const invariant = {[kind]: data};
      const [enumType] = typeParams;
      return this.getTypeInterface(enumType)._encodeRaw.call(this, writer, invariant, typeParams, typeMap);
    }, function decode(reader, typeParams, typeMap) {
      const [enumType] = typeParams;
      const data = this.getTypeInterface(enumType)._decodeRaw.call(this, reader, typeParams, typeMap);
      const kind = Object.keys(data)[0];
      return {kind, ...data[kind]};
    }, (data) => {
      if (typeof data !== "object" && !("kind" in data)) {
        throw new Error(`EnumKind: Missing property "kind" in the input ${JSON.stringify(data)}`);
      }
      return true;
    });
    builder.registerType(PROGRAMMABLE_CALL, function encodeProgrammableTx(writer, data, typeParams, typeMap) {
      const [pkg, module22, fun] = data.target.split("::");
      const type_arguments = data.typeArguments.map((tag) => import_bcs3.TypeTagSerializer.parseFromStr(tag, true));
      return this.getTypeInterface(PROGRAMMABLE_CALL_INNER)._encodeRaw.call(this, writer, {
        package: (0, import_sui_types.normalizeSuiAddress)(pkg),
        module: module22,
        function: fun,
        type_arguments,
        arguments: data.arguments
      }, typeParams, typeMap);
    }, function decodeProgrammableTx(reader, typeParams, typeMap) {
      let data = builder.getTypeInterface(PROGRAMMABLE_CALL_INNER)._decodeRaw.call(this, reader, typeParams, typeMap);
      return {
        target: [data.package, data.module, data.function].join("::"),
        arguments: data.arguments,
        typeArguments: data.type_arguments.map(import_bcs3.TypeTagSerializer.tagToString)
      };
    }, (data) => {
      return data.target.split("::").length === 3;
    });
    function registerFixedArray(bcs2, name, length) {
      bcs2.registerType(name, function encode2(writer, data, typeParams, typeMap) {
        if (data.length !== length) {
          throw new Error(`Expected fixed array of length ${length}, got ${data.length}`);
        }
        if (typeParams.length !== 1) {
          throw new Error(`Expected one type parameter in a fixed array, got ${typeParams.length}`);
        }
        let [type] = typeof typeParams[0] === "string" ? [typeParams[0], []] : typeParams[0];
        for (let piece of data) {
          this.getTypeInterface(type)._encodeRaw.call(this, writer, piece, typeParams, typeMap);
        }
        return writer;
      }, function decode2(reader, typeParams, typeMap) {
        if (typeParams.length !== 1) {
          throw new Error(`Expected one type parameter in a fixed array, got ${typeParams.length}`);
        }
        let result = [];
        let [type] = typeof typeParams[0] === "string" ? [typeParams[0], []] : typeParams[0];
        for (let i = 0; i < length; i++) {
          result.push(this.getTypeInterface(type)._decodeRaw.call(this, reader, typeParams, typeMap));
        }
        return result;
      });
    }
  }
});

// node_modules/@mysten/sui.js/dist/cjs/builder/Inputs.js
var require_Inputs = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/builder/Inputs.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var Inputs_exports = {};
    __export2(Inputs_exports, {
      BuilderCallArg: () => BuilderCallArg,
      Inputs: () => Inputs,
      ObjectCallArg: () => ObjectCallArg,
      PureCallArg: () => PureCallArg,
      getIdFromCallArg: () => getIdFromCallArg,
      getSharedObjectInput: () => getSharedObjectInput,
      isMutableSharedObjectInput: () => isMutableSharedObjectInput,
      isSharedObjectInput: () => isSharedObjectInput
    });
    module2.exports = __toCommonJS(Inputs_exports);
    var import_superstruct = require_dist2();
    var import_types = require_types();
    var import_bcs = require_bcs2();
    var import_sui_types = require_sui_types();
    var ObjectArg = (0, import_superstruct.union)([
      (0, import_superstruct.object)({ImmOrOwned: import_types.SuiObjectRef}),
      (0, import_superstruct.object)({
        Shared: (0, import_superstruct.object)({
          objectId: (0, import_superstruct.string)(),
          initialSharedVersion: (0, import_superstruct.union)([(0, import_superstruct.integer)(), (0, import_superstruct.string)()]),
          mutable: (0, import_superstruct.boolean)()
        })
      })
    ]);
    var PureCallArg = (0, import_superstruct.object)({Pure: (0, import_superstruct.array)((0, import_superstruct.integer)())});
    var ObjectCallArg = (0, import_superstruct.object)({Object: ObjectArg});
    var BuilderCallArg = (0, import_superstruct.union)([PureCallArg, ObjectCallArg]);
    var Inputs = {
      Pure(data, type) {
        return {
          Pure: Array.from(data instanceof Uint8Array ? data : import_bcs.builder.ser(type, data, {maxSize: Infinity}).toBytes())
        };
      },
      ObjectRef({objectId, digest, version}) {
        return {
          Object: {
            ImmOrOwned: {
              digest,
              version,
              objectId: (0, import_sui_types.normalizeSuiAddress)(objectId)
            }
          }
        };
      },
      SharedObjectRef({objectId, mutable, initialSharedVersion}) {
        return {
          Object: {
            Shared: {
              mutable,
              initialSharedVersion,
              objectId: (0, import_sui_types.normalizeSuiAddress)(objectId)
            }
          }
        };
      }
    };
    function getIdFromCallArg(arg) {
      if (typeof arg === "string") {
        return (0, import_sui_types.normalizeSuiAddress)(arg);
      }
      if ("ImmOrOwned" in arg.Object) {
        return (0, import_sui_types.normalizeSuiAddress)(arg.Object.ImmOrOwned.objectId);
      }
      return (0, import_sui_types.normalizeSuiAddress)(arg.Object.Shared.objectId);
    }
    function getSharedObjectInput(arg) {
      return typeof arg === "object" && "Object" in arg && "Shared" in arg.Object ? arg.Object.Shared : void 0;
    }
    function isSharedObjectInput(arg) {
      return !!getSharedObjectInput(arg);
    }
    function isMutableSharedObjectInput(arg) {
      return getSharedObjectInput(arg)?.mutable ?? false;
    }
  }
});

// node_modules/@mysten/sui.js/dist/cjs/builder/utils.js
var require_utils = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/builder/utils.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var utils_exports = {};
    __export2(utils_exports, {
      TRANSACTION_TYPE: () => TRANSACTION_TYPE,
      create: () => create
    });
    module2.exports = __toCommonJS(utils_exports);
    var import_superstruct = require_dist2();
    function create(value, struct) {
      return (0, import_superstruct.create)(value, struct);
    }
    var TRANSACTION_TYPE = Symbol("transaction-argument-type");
  }
});

// node_modules/@mysten/sui.js/dist/cjs/builder/Transactions.js
var require_Transactions = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/builder/Transactions.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var Transactions_exports = {};
    __export2(Transactions_exports, {
      MakeMoveVecTransaction: () => MakeMoveVecTransaction,
      MergeCoinsTransaction: () => MergeCoinsTransaction,
      MoveCallTransaction: () => MoveCallTransaction,
      ObjectTransactionArgument: () => ObjectTransactionArgument,
      PublishTransaction: () => PublishTransaction,
      PureTransactionArgument: () => PureTransactionArgument,
      SplitCoinsTransaction: () => SplitCoinsTransaction,
      TransactionArgument: () => TransactionArgument,
      TransactionBlockInput: () => TransactionBlockInput,
      TransactionType: () => TransactionType,
      Transactions: () => Transactions,
      TransferObjectsTransaction: () => TransferObjectsTransaction,
      UpgradePolicy: () => UpgradePolicy,
      UpgradeTransaction: () => UpgradeTransaction,
      getTransactionType: () => getTransactionType
    });
    module2.exports = __toCommonJS(Transactions_exports);
    var import_bcs = require_dist();
    var import_superstruct = require_dist2();
    var import_utils2 = require_utils();
    var import_type_tag_serializer = require_type_tag_serializer();
    var import_sui_types = require_sui_types();
    var option = (some) => (0, import_superstruct.union)([(0, import_superstruct.object)({None: (0, import_superstruct.union)([(0, import_superstruct.literal)(true), (0, import_superstruct.literal)(null)])}), (0, import_superstruct.object)({Some: some})]);
    var TransactionBlockInput = (0, import_superstruct.object)({
      kind: (0, import_superstruct.literal)("Input"),
      index: (0, import_superstruct.integer)(),
      value: (0, import_superstruct.optional)((0, import_superstruct.any)()),
      type: (0, import_superstruct.optional)((0, import_superstruct.union)([(0, import_superstruct.literal)("pure"), (0, import_superstruct.literal)("object")]))
    });
    var TransactionArgumentTypes = [
      TransactionBlockInput,
      (0, import_superstruct.object)({kind: (0, import_superstruct.literal)("GasCoin")}),
      (0, import_superstruct.object)({kind: (0, import_superstruct.literal)("Result"), index: (0, import_superstruct.integer)()}),
      (0, import_superstruct.object)({
        kind: (0, import_superstruct.literal)("NestedResult"),
        index: (0, import_superstruct.integer)(),
        resultIndex: (0, import_superstruct.integer)()
      })
    ];
    var TransactionArgument = (0, import_superstruct.union)([...TransactionArgumentTypes]);
    var ObjectTransactionArgument = (0, import_superstruct.union)([...TransactionArgumentTypes]);
    ObjectTransactionArgument[import_utils2.TRANSACTION_TYPE] = {
      kind: "object"
    };
    var PureTransactionArgument = (type) => {
      const struct = (0, import_superstruct.union)([...TransactionArgumentTypes]);
      struct[import_utils2.TRANSACTION_TYPE] = {
        kind: "pure",
        type
      };
      return struct;
    };
    var MoveCallTransaction = (0, import_superstruct.object)({
      kind: (0, import_superstruct.literal)("MoveCall"),
      target: (0, import_superstruct.define)("target", (0, import_superstruct.string)().validator),
      typeArguments: (0, import_superstruct.array)((0, import_superstruct.string)()),
      arguments: (0, import_superstruct.array)(TransactionArgument)
    });
    var TransferObjectsTransaction = (0, import_superstruct.object)({
      kind: (0, import_superstruct.literal)("TransferObjects"),
      objects: (0, import_superstruct.array)(ObjectTransactionArgument),
      address: PureTransactionArgument(import_bcs.BCS.ADDRESS)
    });
    var SplitCoinsTransaction = (0, import_superstruct.object)({
      kind: (0, import_superstruct.literal)("SplitCoins"),
      coin: ObjectTransactionArgument,
      amounts: (0, import_superstruct.array)(PureTransactionArgument("u64"))
    });
    var MergeCoinsTransaction = (0, import_superstruct.object)({
      kind: (0, import_superstruct.literal)("MergeCoins"),
      destination: ObjectTransactionArgument,
      sources: (0, import_superstruct.array)(ObjectTransactionArgument)
    });
    var MakeMoveVecTransaction = (0, import_superstruct.object)({
      kind: (0, import_superstruct.literal)("MakeMoveVec"),
      type: (0, import_superstruct.optional)(option((0, import_superstruct.record)((0, import_superstruct.string)(), (0, import_superstruct.unknown)()))),
      objects: (0, import_superstruct.array)(ObjectTransactionArgument)
    });
    var PublishTransaction = (0, import_superstruct.object)({
      kind: (0, import_superstruct.literal)("Publish"),
      modules: (0, import_superstruct.array)((0, import_superstruct.array)((0, import_superstruct.integer)())),
      dependencies: (0, import_superstruct.array)((0, import_superstruct.string)())
    });
    var UpgradePolicy = /* @__PURE__ */ ((UpgradePolicy2) => {
      UpgradePolicy2[UpgradePolicy2["COMPATIBLE"] = 0] = "COMPATIBLE";
      UpgradePolicy2[UpgradePolicy2["ADDITIVE"] = 128] = "ADDITIVE";
      UpgradePolicy2[UpgradePolicy2["DEP_ONLY"] = 192] = "DEP_ONLY";
      return UpgradePolicy2;
    })(UpgradePolicy || {});
    var UpgradeTransaction = (0, import_superstruct.object)({
      kind: (0, import_superstruct.literal)("Upgrade"),
      modules: (0, import_superstruct.array)((0, import_superstruct.array)((0, import_superstruct.integer)())),
      dependencies: (0, import_superstruct.array)((0, import_superstruct.string)()),
      packageId: (0, import_superstruct.string)(),
      ticket: ObjectTransactionArgument
    });
    var TransactionTypes = [
      MoveCallTransaction,
      TransferObjectsTransaction,
      SplitCoinsTransaction,
      MergeCoinsTransaction,
      PublishTransaction,
      UpgradeTransaction,
      MakeMoveVecTransaction
    ];
    var TransactionType = (0, import_superstruct.union)([...TransactionTypes]);
    function getTransactionType(data) {
      (0, import_superstruct.assert)(data, TransactionType);
      return TransactionTypes.find((schema) => (0, import_superstruct.is)(data, schema));
    }
    var Transactions = {
      MoveCall(input) {
        return (0, import_utils2.create)({
          kind: "MoveCall",
          target: input.target,
          arguments: input.arguments ?? [],
          typeArguments: input.typeArguments ?? []
        }, MoveCallTransaction);
      },
      TransferObjects(objects, address2) {
        return (0, import_utils2.create)({kind: "TransferObjects", objects, address: address2}, TransferObjectsTransaction);
      },
      SplitCoins(coin, amounts) {
        return (0, import_utils2.create)({kind: "SplitCoins", coin, amounts}, SplitCoinsTransaction);
      },
      MergeCoins(destination, sources) {
        return (0, import_utils2.create)({kind: "MergeCoins", destination, sources}, MergeCoinsTransaction);
      },
      Publish({
        modules,
        dependencies
      }) {
        return (0, import_utils2.create)({
          kind: "Publish",
          modules: modules.map((module22) => typeof module22 === "string" ? Array.from((0, import_bcs.fromB64)(module22)) : module22),
          dependencies: dependencies.map((dep) => (0, import_sui_types.normalizeSuiObjectId)(dep))
        }, PublishTransaction);
      },
      Upgrade({
        modules,
        dependencies,
        packageId,
        ticket
      }) {
        return (0, import_utils2.create)({
          kind: "Upgrade",
          modules: modules.map((module22) => typeof module22 === "string" ? Array.from((0, import_bcs.fromB64)(module22)) : module22),
          dependencies: dependencies.map((dep) => (0, import_sui_types.normalizeSuiObjectId)(dep)),
          packageId,
          ticket
        }, UpgradeTransaction);
      },
      MakeMoveVec({
        type,
        objects
      }) {
        return (0, import_utils2.create)({
          kind: "MakeMoveVec",
          type: type ? {Some: import_type_tag_serializer.TypeTagSerializer.parseFromStr(type)} : {None: null},
          objects
        }, MakeMoveVecTransaction);
      }
    };
  }
});

// node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool;
    function bytes(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(hash2) {
      if (typeof hash2 !== "function" || typeof hash2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash2.outputLen);
      number(hash2.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = {
      number,
      bool,
      bytes,
      hash,
      exists,
      output
    };
    exports.default = assert;
  }
});

// node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils2 = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto();
    var u8a = (a) => a instanceof Uint8Array;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = Array.from({length: 256}, (v, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const len = hex.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
      let pad = 0;
      arrays.forEach((a) => {
        if (!u8a(a))
          throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
      });
      return r;
    }
    exports.concatBytes = concatBytes;
    var Hash2 = class {
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash2;
    var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@noble/hashes/_blake2.js
var require_blake2 = __commonJS({
  "node_modules/@noble/hashes/_blake2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.BLAKE2 = exports.SIGMA = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils2();
    exports.SIGMA = new Uint8Array([
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3
    ]);
    var BLAKE2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.length = 0;
        this.pos = 0;
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.number(blockLen);
        _assert_js_1.default.number(outputLen);
        _assert_js_1.default.number(keyLen);
        if (outputLen < 0 || outputLen > keyLen)
          throw new Error("outputLen bigger than keyLen");
        if (opts.key !== void 0 && (opts.key.length < 1 || opts.key.length > keyLen))
          throw new Error(`key must be up 1..${keyLen} byte long or undefined`);
        if (opts.salt !== void 0 && opts.salt.length !== saltLen)
          throw new Error(`salt must be ${saltLen} byte long or undefined`);
        if (opts.personalization !== void 0 && opts.personalization.length !== persLen)
          throw new Error(`personalization must be ${persLen} byte long or undefined`);
        this.buffer32 = (0, utils_js_1.u32)(this.buffer = new Uint8Array(blockLen));
      }
      update(data) {
        _assert_js_1.default.exists(this);
        const {blockLen, buffer, buffer32} = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        const offset = data.byteOffset;
        const buf = data.buffer;
        for (let pos = 0; pos < len; ) {
          if (this.pos === blockLen) {
            this.compress(buffer32, 0, false);
            this.pos = 0;
          }
          const take = Math.min(blockLen - this.pos, len - pos);
          const dataOffset = offset + pos;
          if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
            const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
            for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
              this.length += blockLen;
              this.compress(data32, pos32, false);
            }
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          this.length += take;
          pos += take;
        }
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        const {pos, buffer32} = this;
        this.finished = true;
        this.buffer.subarray(pos).fill(0);
        this.compress(buffer32, 0, true);
        const out32 = (0, utils_js_1.u32)(out);
        this.get().forEach((v, i) => out32[i] = v);
      }
      digest() {
        const {buffer, outputLen} = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        const {buffer, length, finished, destroyed, outputLen, pos} = this;
        to || (to = new this.constructor({dkLen: outputLen}));
        to.set(...this.get());
        to.length = length;
        to.finished = finished;
        to.destroyed = destroyed;
        to.outputLen = outputLen;
        to.buffer.set(buffer);
        to.pos = pos;
        return to;
      }
    };
    exports.BLAKE2 = BLAKE2;
  }
});

// node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return {h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64)};
      return {h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0};
    }
    exports.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const {h, l} = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, l, s) => h >>> s;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    var rotr32H = (h, l) => l;
    var rotr32L = (h, l) => h;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return {h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0};
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    var u64 = {
      fromBig,
      split,
      toBig: exports.toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/@noble/hashes/blake2b.js
var require_blake2b = __commonJS({
  "node_modules/@noble/hashes/blake2b.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.blake2b = void 0;
    var _blake2_js_1 = require_blake2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils2();
    var IV = new Uint32Array([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    var BUF = new Uint32Array(32);
    function G1(a, b, c, d, msg, x) {
      const Xl = msg[x], Xh = msg[x + 1];
      let Al = BUF[2 * a], Ah = BUF[2 * a + 1];
      let Bl = BUF[2 * b], Bh = BUF[2 * b + 1];
      let Cl = BUF[2 * c], Ch = BUF[2 * c + 1];
      let Dl = BUF[2 * d], Dh = BUF[2 * d + 1];
      let ll = _u64_js_1.default.add3L(Al, Bl, Xl);
      Ah = _u64_js_1.default.add3H(ll, Ah, Bh, Xh);
      Al = ll | 0;
      ({Dh, Dl} = {Dh: Dh ^ Ah, Dl: Dl ^ Al});
      ({Dh, Dl} = {Dh: _u64_js_1.default.rotr32H(Dh, Dl), Dl: _u64_js_1.default.rotr32L(Dh, Dl)});
      ({h: Ch, l: Cl} = _u64_js_1.default.add(Ch, Cl, Dh, Dl));
      ({Bh, Bl} = {Bh: Bh ^ Ch, Bl: Bl ^ Cl});
      ({Bh, Bl} = {Bh: _u64_js_1.default.rotrSH(Bh, Bl, 24), Bl: _u64_js_1.default.rotrSL(Bh, Bl, 24)});
      BUF[2 * a] = Al, BUF[2 * a + 1] = Ah;
      BUF[2 * b] = Bl, BUF[2 * b + 1] = Bh;
      BUF[2 * c] = Cl, BUF[2 * c + 1] = Ch;
      BUF[2 * d] = Dl, BUF[2 * d + 1] = Dh;
    }
    function G2(a, b, c, d, msg, x) {
      const Xl = msg[x], Xh = msg[x + 1];
      let Al = BUF[2 * a], Ah = BUF[2 * a + 1];
      let Bl = BUF[2 * b], Bh = BUF[2 * b + 1];
      let Cl = BUF[2 * c], Ch = BUF[2 * c + 1];
      let Dl = BUF[2 * d], Dh = BUF[2 * d + 1];
      let ll = _u64_js_1.default.add3L(Al, Bl, Xl);
      Ah = _u64_js_1.default.add3H(ll, Ah, Bh, Xh);
      Al = ll | 0;
      ({Dh, Dl} = {Dh: Dh ^ Ah, Dl: Dl ^ Al});
      ({Dh, Dl} = {Dh: _u64_js_1.default.rotrSH(Dh, Dl, 16), Dl: _u64_js_1.default.rotrSL(Dh, Dl, 16)});
      ({h: Ch, l: Cl} = _u64_js_1.default.add(Ch, Cl, Dh, Dl));
      ({Bh, Bl} = {Bh: Bh ^ Ch, Bl: Bl ^ Cl});
      ({Bh, Bl} = {Bh: _u64_js_1.default.rotrBH(Bh, Bl, 63), Bl: _u64_js_1.default.rotrBL(Bh, Bl, 63)});
      BUF[2 * a] = Al, BUF[2 * a + 1] = Ah;
      BUF[2 * b] = Bl, BUF[2 * b + 1] = Bh;
      BUF[2 * c] = Cl, BUF[2 * c + 1] = Ch;
      BUF[2 * d] = Dl, BUF[2 * d + 1] = Dh;
    }
    var BLAKE2b = class extends _blake2_js_1.BLAKE2 {
      constructor(opts = {}) {
        super(128, opts.dkLen === void 0 ? 64 : opts.dkLen, opts, 64, 16, 16);
        this.v0l = IV[0] | 0;
        this.v0h = IV[1] | 0;
        this.v1l = IV[2] | 0;
        this.v1h = IV[3] | 0;
        this.v2l = IV[4] | 0;
        this.v2h = IV[5] | 0;
        this.v3l = IV[6] | 0;
        this.v3h = IV[7] | 0;
        this.v4l = IV[8] | 0;
        this.v4h = IV[9] | 0;
        this.v5l = IV[10] | 0;
        this.v5h = IV[11] | 0;
        this.v6l = IV[12] | 0;
        this.v6h = IV[13] | 0;
        this.v7l = IV[14] | 0;
        this.v7h = IV[15] | 0;
        const keyLength = opts.key ? opts.key.length : 0;
        this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
        if (opts.salt) {
          const salt = (0, utils_js_1.u32)((0, utils_js_1.toBytes)(opts.salt));
          this.v4l ^= salt[0];
          this.v4h ^= salt[1];
          this.v5l ^= salt[2];
          this.v5h ^= salt[3];
        }
        if (opts.personalization) {
          const pers = (0, utils_js_1.u32)((0, utils_js_1.toBytes)(opts.personalization));
          this.v6l ^= pers[0];
          this.v6h ^= pers[1];
          this.v7l ^= pers[2];
          this.v7h ^= pers[3];
        }
        if (opts.key) {
          const tmp = new Uint8Array(this.blockLen);
          tmp.set((0, utils_js_1.toBytes)(opts.key));
          this.update(tmp);
        }
      }
      get() {
        let {v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h} = this;
        return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
      }
      set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
        this.v0l = v0l | 0;
        this.v0h = v0h | 0;
        this.v1l = v1l | 0;
        this.v1h = v1h | 0;
        this.v2l = v2l | 0;
        this.v2h = v2h | 0;
        this.v3l = v3l | 0;
        this.v3h = v3h | 0;
        this.v4l = v4l | 0;
        this.v4h = v4h | 0;
        this.v5l = v5l | 0;
        this.v5h = v5h | 0;
        this.v6l = v6l | 0;
        this.v6h = v6h | 0;
        this.v7l = v7l | 0;
        this.v7h = v7h | 0;
      }
      compress(msg, offset, isLast) {
        this.get().forEach((v, i) => BUF[i] = v);
        BUF.set(IV, 16);
        let {h, l} = _u64_js_1.default.fromBig(BigInt(this.length));
        BUF[24] = IV[8] ^ l;
        BUF[25] = IV[9] ^ h;
        if (isLast) {
          BUF[28] = ~BUF[28];
          BUF[29] = ~BUF[29];
        }
        let j = 0;
        const s = _blake2_js_1.SIGMA;
        for (let i = 0; i < 12; i++) {
          G1(0, 4, 8, 12, msg, offset + 2 * s[j++]);
          G2(0, 4, 8, 12, msg, offset + 2 * s[j++]);
          G1(1, 5, 9, 13, msg, offset + 2 * s[j++]);
          G2(1, 5, 9, 13, msg, offset + 2 * s[j++]);
          G1(2, 6, 10, 14, msg, offset + 2 * s[j++]);
          G2(2, 6, 10, 14, msg, offset + 2 * s[j++]);
          G1(3, 7, 11, 15, msg, offset + 2 * s[j++]);
          G2(3, 7, 11, 15, msg, offset + 2 * s[j++]);
          G1(0, 5, 10, 15, msg, offset + 2 * s[j++]);
          G2(0, 5, 10, 15, msg, offset + 2 * s[j++]);
          G1(1, 6, 11, 12, msg, offset + 2 * s[j++]);
          G2(1, 6, 11, 12, msg, offset + 2 * s[j++]);
          G1(2, 7, 8, 13, msg, offset + 2 * s[j++]);
          G2(2, 7, 8, 13, msg, offset + 2 * s[j++]);
          G1(3, 4, 9, 14, msg, offset + 2 * s[j++]);
          G2(3, 4, 9, 14, msg, offset + 2 * s[j++]);
        }
        this.v0l ^= BUF[0] ^ BUF[16];
        this.v0h ^= BUF[1] ^ BUF[17];
        this.v1l ^= BUF[2] ^ BUF[18];
        this.v1h ^= BUF[3] ^ BUF[19];
        this.v2l ^= BUF[4] ^ BUF[20];
        this.v2h ^= BUF[5] ^ BUF[21];
        this.v3l ^= BUF[6] ^ BUF[22];
        this.v3h ^= BUF[7] ^ BUF[23];
        this.v4l ^= BUF[8] ^ BUF[24];
        this.v4h ^= BUF[9] ^ BUF[25];
        this.v5l ^= BUF[10] ^ BUF[26];
        this.v5h ^= BUF[11] ^ BUF[27];
        this.v6l ^= BUF[12] ^ BUF[28];
        this.v6h ^= BUF[13] ^ BUF[29];
        this.v7l ^= BUF[14] ^ BUF[30];
        this.v7h ^= BUF[15] ^ BUF[31];
        BUF.fill(0);
      }
      destroy() {
        this.destroyed = true;
        this.buffer32.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports.blake2b = (0, utils_js_1.wrapConstructorWithOpts)((opts) => new BLAKE2b(opts));
  }
});

// node_modules/@mysten/sui.js/dist/cjs/builder/hash.js
var require_hash = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/builder/hash.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var hash_exports = {};
    __export2(hash_exports, {
      hashTypedData: () => hashTypedData
    });
    module2.exports = __toCommonJS(hash_exports);
    var import_blake2b = require_blake2b();
    function hashTypedData(typeTag, data) {
      const typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));
      const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);
      dataWithTag.set(typeTagBytes);
      dataWithTag.set(data, typeTagBytes.length);
      return (0, import_blake2b.blake2b)(dataWithTag, {dkLen: 32});
    }
  }
});

// node_modules/@mysten/sui.js/dist/cjs/builder/TransactionBlockData.js
var require_TransactionBlockData = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/builder/TransactionBlockData.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var TransactionBlockData_exports = {};
    __export2(TransactionBlockData_exports, {
      SerializedTransactionDataBuilder: () => SerializedTransactionDataBuilder,
      TransactionBlockDataBuilder: () => TransactionBlockDataBuilder,
      TransactionExpiration: () => TransactionExpiration
    });
    module2.exports = __toCommonJS(TransactionBlockData_exports);
    var import_bcs = require_dist();
    var import_superstruct = require_dist2();
    var import_hash = require_hash();
    var import_types = require_types();
    var import_bcs2 = require_bcs2();
    var import_Transactions = require_Transactions();
    var import_Inputs = require_Inputs();
    var import_utils2 = require_utils();
    var import_sui_types = require_sui_types();
    var TransactionExpiration = (0, import_superstruct.optional)((0, import_superstruct.nullable)((0, import_superstruct.union)([(0, import_superstruct.object)({Epoch: (0, import_superstruct.integer)()}), (0, import_superstruct.object)({None: (0, import_superstruct.union)([(0, import_superstruct.literal)(true), (0, import_superstruct.literal)(null)])})])));
    var StringEncodedBigint = (0, import_superstruct.define)("StringEncodedBigint", (val) => {
      if (!["string", "number", "bigint"].includes(typeof val))
        return false;
      try {
        BigInt(val);
        return true;
      } catch {
        return false;
      }
    });
    var GasConfig = (0, import_superstruct.object)({
      budget: (0, import_superstruct.optional)(StringEncodedBigint),
      price: (0, import_superstruct.optional)(StringEncodedBigint),
      payment: (0, import_superstruct.optional)((0, import_superstruct.array)(import_types.SuiObjectRef)),
      owner: (0, import_superstruct.optional)((0, import_superstruct.string)())
    });
    var SerializedTransactionDataBuilder = (0, import_superstruct.object)({
      version: (0, import_superstruct.literal)(1),
      sender: (0, import_superstruct.optional)((0, import_superstruct.string)()),
      expiration: TransactionExpiration,
      gasConfig: GasConfig,
      inputs: (0, import_superstruct.array)(import_Transactions.TransactionBlockInput),
      transactions: (0, import_superstruct.array)(import_Transactions.TransactionType)
    });
    function prepareSuiAddress(address2) {
      return (0, import_sui_types.normalizeSuiAddress)(address2).replace("0x", "");
    }
    var TransactionBlockDataBuilder = class {
      constructor(clone) {
        this.version = 1;
        this.sender = clone?.sender;
        this.expiration = clone?.expiration;
        this.gasConfig = clone?.gasConfig ?? {};
        this.inputs = clone?.inputs ?? [];
        this.transactions = clone?.transactions ?? [];
      }
      static fromKindBytes(bytes) {
        const kind = import_bcs2.builder.de("TransactionKind", bytes);
        const programmableTx = kind?.ProgrammableTransaction;
        if (!programmableTx) {
          throw new Error("Unable to deserialize from bytes.");
        }
        const serialized = (0, import_utils2.create)({
          version: 1,
          gasConfig: {},
          inputs: programmableTx.inputs.map((value, index) => (0, import_utils2.create)({
            kind: "Input",
            value,
            index,
            type: (0, import_superstruct.is)(value, import_Inputs.PureCallArg) ? "pure" : "object"
          }, import_Transactions.TransactionBlockInput)),
          transactions: programmableTx.transactions
        }, SerializedTransactionDataBuilder);
        return TransactionBlockDataBuilder.restore(serialized);
      }
      static fromBytes(bytes) {
        const rawData = import_bcs2.builder.de("TransactionData", bytes);
        const data = rawData?.V1;
        const programmableTx = data?.kind?.ProgrammableTransaction;
        if (!data || !programmableTx) {
          throw new Error("Unable to deserialize from bytes.");
        }
        const serialized = (0, import_utils2.create)({
          version: 1,
          sender: data.sender,
          expiration: data.expiration,
          gasConfig: data.gasData,
          inputs: programmableTx.inputs.map((value, index) => (0, import_utils2.create)({
            kind: "Input",
            value,
            index,
            type: (0, import_superstruct.is)(value, import_Inputs.PureCallArg) ? "pure" : "object"
          }, import_Transactions.TransactionBlockInput)),
          transactions: programmableTx.transactions
        }, SerializedTransactionDataBuilder);
        return TransactionBlockDataBuilder.restore(serialized);
      }
      static restore(data) {
        (0, import_superstruct.assert)(data, SerializedTransactionDataBuilder);
        const transactionData = new TransactionBlockDataBuilder();
        Object.assign(transactionData, data);
        return transactionData;
      }
      static getDigestFromBytes(bytes) {
        const hash = (0, import_hash.hashTypedData)("TransactionData", bytes);
        return (0, import_bcs.toB58)(hash);
      }
      build({
        maxSizeBytes = Infinity,
        overrides,
        onlyTransactionKind
      } = {}) {
        const inputs = this.inputs.map((input) => {
          (0, import_superstruct.assert)(input.value, import_Inputs.BuilderCallArg);
          return input.value;
        });
        const kind = {
          ProgrammableTransaction: {
            inputs,
            transactions: this.transactions
          }
        };
        if (onlyTransactionKind) {
          return import_bcs2.builder.ser("TransactionKind", kind, {maxSize: maxSizeBytes}).toBytes();
        }
        const expiration = overrides?.expiration ?? this.expiration;
        const sender = overrides?.sender ?? this.sender;
        const gasConfig = {...this.gasConfig, ...overrides?.gasConfig};
        if (!sender) {
          throw new Error("Missing transaction sender");
        }
        if (!gasConfig.budget) {
          throw new Error("Missing gas budget");
        }
        if (!gasConfig.payment) {
          throw new Error("Missing gas payment");
        }
        if (!gasConfig.price) {
          throw new Error("Missing gas price");
        }
        const transactionData = {
          sender: prepareSuiAddress(sender),
          expiration: expiration ? expiration : {None: true},
          gasData: {
            payment: gasConfig.payment,
            owner: prepareSuiAddress(this.gasConfig.owner ?? sender),
            price: BigInt(gasConfig.price),
            budget: BigInt(gasConfig.budget)
          },
          kind: {
            ProgrammableTransaction: {
              inputs,
              transactions: this.transactions
            }
          }
        };
        return import_bcs2.builder.ser("TransactionData", {V1: transactionData}, {maxSize: maxSizeBytes}).toBytes();
      }
      getDigest() {
        const bytes = this.build({onlyTransactionKind: false});
        return TransactionBlockDataBuilder.getDigestFromBytes(bytes);
      }
      snapshot() {
        return (0, import_utils2.create)(this, SerializedTransactionDataBuilder);
      }
    };
  }
});

// node_modules/@mysten/sui.js/dist/cjs/builder/TransactionBlock.js
var require_TransactionBlock = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/builder/TransactionBlock.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var __accessCheck = (obj, member, msg) => {
      if (!member.has(obj))
        throw TypeError("Cannot " + msg);
    };
    var __privateGet = (obj, member, getter) => {
      __accessCheck(obj, member, "read from private field");
      return getter ? getter.call(obj) : member.get(obj);
    };
    var __privateAdd = (obj, member, value) => {
      if (member.has(obj))
        throw TypeError("Cannot add the same private member more than once");
      member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    };
    var __privateSet = (obj, member, value, setter) => {
      __accessCheck(obj, member, "write to private field");
      setter ? setter.call(obj, value) : member.set(obj, value);
      return value;
    };
    var __privateMethod = (obj, member, method) => {
      __accessCheck(obj, member, "access private method");
      return method;
    };
    var TransactionBlock_exports = {};
    __export2(TransactionBlock_exports, {
      TransactionBlock: () => TransactionBlock2,
      isTransactionBlock: () => isTransactionBlock
    });
    module2.exports = __toCommonJS(TransactionBlock_exports);
    var import_bcs = require_dist();
    var import_superstruct = require_dist2();
    var import_types = require_types();
    var import_Transactions = require_Transactions();
    var import_Inputs = require_Inputs();
    var import_serializer = require_serializer();
    var import_TransactionBlockData = require_TransactionBlockData();
    var import_utils2 = require_utils();
    var import_sui_types = require_sui_types();
    var import_framework = require_framework();
    var _blockData;
    var _input;
    var input_fn;
    var _getConfig;
    var getConfig_fn;
    var _validate;
    var validate_fn;
    var _prepareGasPayment;
    var prepareGasPayment_fn;
    var _prepareGasPrice;
    var prepareGasPrice_fn;
    var _prepareTransactions;
    var prepareTransactions_fn;
    var _prepare;
    var prepare_fn;
    var DefaultOfflineLimits = {
      maxPureArgumentSize: 16 * 1024,
      maxTxGas: 5e10,
      maxGasObjects: 256,
      maxTxSizeBytes: 128 * 1024
    };
    function createTransactionResult(index) {
      const baseResult = {kind: "Result", index};
      const nestedResults = [];
      const nestedResultFor = (resultIndex) => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {
        kind: "NestedResult",
        index,
        resultIndex
      });
      return new Proxy(baseResult, {
        set() {
          throw new Error("The transaction result is a proxy, and does not support setting properties directly");
        },
        get(target, property) {
          if (property in target) {
            return Reflect.get(target, property);
          }
          if (property === Symbol.iterator) {
            return function* () {
              let i = 0;
              while (true) {
                yield nestedResultFor(i);
                i++;
              }
            };
          }
          if (typeof property === "symbol")
            return;
          const resultIndex = parseInt(property, 10);
          if (Number.isNaN(resultIndex) || resultIndex < 0)
            return;
          return nestedResultFor(resultIndex);
        }
      });
    }
    function expectClient(options) {
      if (!options.client && !options.provider) {
        throw new Error(`No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`);
      }
      return options.client ?? options.provider;
    }
    var TRANSACTION_BRAND = Symbol.for("@mysten/transaction");
    var LIMITS = {
      maxTxGas: "max_tx_gas",
      maxGasObjects: "max_gas_payment_objects",
      maxTxSizeBytes: "max_tx_size_bytes",
      maxPureArgumentSize: "max_pure_argument_size"
    };
    var GAS_SAFE_OVERHEAD = 1000n;
    var MAX_OBJECTS_PER_FETCH = 50;
    var chunk = (arr, size) => Array.from({length: Math.ceil(arr.length / size)}, (_, i) => arr.slice(i * size, i * size + size));
    function isTransactionBlock(obj) {
      return !!obj && typeof obj === "object" && obj[TRANSACTION_BRAND] === true;
    }
    var _TransactionBlock = class _TransactionBlock2 {
      constructor(transaction) {
        __privateAdd(this, _input);
        __privateAdd(this, _getConfig);
        __privateAdd(this, _validate);
        __privateAdd(this, _prepareGasPayment);
        __privateAdd(this, _prepareGasPrice);
        __privateAdd(this, _prepareTransactions);
        __privateAdd(this, _prepare);
        __privateAdd(this, _blockData, void 0);
        __privateSet(this, _blockData, new import_TransactionBlockData.TransactionBlockDataBuilder(transaction ? transaction.blockData : void 0));
      }
      static is(obj) {
        return !!obj && typeof obj === "object" && obj[TRANSACTION_BRAND] === true;
      }
      static fromKind(serialized) {
        const tx = new _TransactionBlock2();
        __privateSet(tx, _blockData, import_TransactionBlockData.TransactionBlockDataBuilder.fromKindBytes(typeof serialized === "string" ? (0, import_bcs.fromB64)(serialized) : serialized));
        return tx;
      }
      static from(serialized) {
        const tx = new _TransactionBlock2();
        if (typeof serialized !== "string" || !serialized.startsWith("{")) {
          __privateSet(tx, _blockData, import_TransactionBlockData.TransactionBlockDataBuilder.fromBytes(typeof serialized === "string" ? (0, import_bcs.fromB64)(serialized) : serialized));
        } else {
          __privateSet(tx, _blockData, import_TransactionBlockData.TransactionBlockDataBuilder.restore(JSON.parse(serialized)));
        }
        return tx;
      }
      static get Transactions() {
        return import_Transactions.Transactions;
      }
      static get Inputs() {
        return import_Inputs.Inputs;
      }
      setSender(sender) {
        __privateGet(this, _blockData).sender = sender;
      }
      setSenderIfNotSet(sender) {
        if (!__privateGet(this, _blockData).sender) {
          __privateGet(this, _blockData).sender = sender;
        }
      }
      setExpiration(expiration) {
        __privateGet(this, _blockData).expiration = expiration;
      }
      setGasPrice(price) {
        __privateGet(this, _blockData).gasConfig.price = String(price);
      }
      setGasBudget(budget) {
        __privateGet(this, _blockData).gasConfig.budget = String(budget);
      }
      setGasOwner(owner) {
        __privateGet(this, _blockData).gasConfig.owner = owner;
      }
      setGasPayment(payments) {
        __privateGet(this, _blockData).gasConfig.payment = payments.map((payment) => (0, import_superstruct.mask)(payment, import_types.SuiObjectRef));
      }
      get blockData() {
        return __privateGet(this, _blockData).snapshot();
      }
      get [TRANSACTION_BRAND]() {
        return true;
      }
      get gas() {
        return {kind: "GasCoin"};
      }
      object(value) {
        const id = (0, import_Inputs.getIdFromCallArg)(value);
        const inserted = __privateGet(this, _blockData).inputs.find((i) => i.type === "object" && id === (0, import_Inputs.getIdFromCallArg)(i.value));
        return inserted ?? __privateMethod(this, _input, input_fn).call(this, "object", value);
      }
      objectRef(...args) {
        return this.object(import_Inputs.Inputs.ObjectRef(...args));
      }
      sharedObjectRef(...args) {
        return this.object(import_Inputs.Inputs.SharedObjectRef(...args));
      }
      pure(value, type) {
        return __privateMethod(this, _input, input_fn).call(this, "pure", value instanceof Uint8Array ? import_Inputs.Inputs.Pure(value) : type ? import_Inputs.Inputs.Pure(value, type) : value);
      }
      add(transaction) {
        const index = __privateGet(this, _blockData).transactions.push(transaction);
        return createTransactionResult(index - 1);
      }
      splitCoins(...args) {
        return this.add(import_Transactions.Transactions.SplitCoins(...args));
      }
      mergeCoins(...args) {
        return this.add(import_Transactions.Transactions.MergeCoins(...args));
      }
      publish(...args) {
        return this.add(import_Transactions.Transactions.Publish(...args));
      }
      upgrade(...args) {
        return this.add(import_Transactions.Transactions.Upgrade(...args));
      }
      moveCall(...args) {
        return this.add(import_Transactions.Transactions.MoveCall(...args));
      }
      transferObjects(...args) {
        return this.add(import_Transactions.Transactions.TransferObjects(...args));
      }
      makeMoveVec(...args) {
        return this.add(import_Transactions.Transactions.MakeMoveVec(...args));
      }
      serialize() {
        return JSON.stringify(__privateGet(this, _blockData).snapshot());
      }
      async sign(options) {
        const {signer, ...buildOptions} = options;
        const bytes = await this.build(buildOptions);
        return signer.signTransactionBlock(bytes);
      }
      async build(options = {}) {
        await __privateMethod(this, _prepare, prepare_fn).call(this, options);
        return __privateGet(this, _blockData).build({
          maxSizeBytes: __privateMethod(this, _getConfig, getConfig_fn).call(this, "maxTxSizeBytes", options),
          onlyTransactionKind: options.onlyTransactionKind
        });
      }
      async getDigest(options = {}) {
        await __privateMethod(this, _prepare, prepare_fn).call(this, options);
        return __privateGet(this, _blockData).getDigest();
      }
    };
    _blockData = new WeakMap();
    _input = new WeakSet();
    input_fn = function(type, value) {
      const index = __privateGet(this, _blockData).inputs.length;
      const input = (0, import_utils2.create)({
        kind: "Input",
        value: typeof value === "bigint" ? String(value) : value,
        index,
        type
      }, import_Transactions.TransactionBlockInput);
      __privateGet(this, _blockData).inputs.push(input);
      return input;
    };
    _getConfig = new WeakSet();
    getConfig_fn = function(key, {protocolConfig, limits}) {
      if (limits && typeof limits[key] === "number") {
        return limits[key];
      }
      if (!protocolConfig) {
        return DefaultOfflineLimits[key];
      }
      const attribute = protocolConfig?.attributes[LIMITS[key]];
      if (!attribute) {
        throw new Error(`Missing expected protocol config: "${LIMITS[key]}"`);
      }
      const value = "u64" in attribute ? attribute.u64 : "u32" in attribute ? attribute.u32 : attribute.f64;
      if (!value) {
        throw new Error(`Unexpected protocol config value found for: "${LIMITS[key]}"`);
      }
      return Number(value);
    };
    _validate = new WeakSet();
    validate_fn = function(options) {
      const maxPureArgumentSize = __privateMethod(this, _getConfig, getConfig_fn).call(this, "maxPureArgumentSize", options);
      __privateGet(this, _blockData).inputs.forEach((input, index) => {
        if ((0, import_superstruct.is)(input.value, import_Inputs.PureCallArg)) {
          if (input.value.Pure.length > maxPureArgumentSize) {
            throw new Error(`Input at index ${index} is too large, max pure input size is ${maxPureArgumentSize} bytes, got ${input.value.Pure.length} bytes`);
          }
        }
      });
    };
    _prepareGasPayment = new WeakSet();
    prepareGasPayment_fn = async function(options) {
      if (__privateGet(this, _blockData).gasConfig.payment) {
        const maxGasObjects = __privateMethod(this, _getConfig, getConfig_fn).call(this, "maxGasObjects", options);
        if (__privateGet(this, _blockData).gasConfig.payment.length > maxGasObjects) {
          throw new Error(`Payment objects exceed maximum amount: ${maxGasObjects}`);
        }
      }
      if (options.onlyTransactionKind || __privateGet(this, _blockData).gasConfig.payment) {
        return;
      }
      const gasOwner = __privateGet(this, _blockData).gasConfig.owner ?? __privateGet(this, _blockData).sender;
      const coins = await expectClient(options).getCoins({
        owner: gasOwner,
        coinType: import_framework.SUI_TYPE_ARG
      });
      const paymentCoins = coins.data.filter((coin) => {
        const matchingInput = __privateGet(this, _blockData).inputs.find((input) => {
          if ((0, import_superstruct.is)(input.value, import_Inputs.BuilderCallArg) && "Object" in input.value && "ImmOrOwned" in input.value.Object) {
            return coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;
          }
          return false;
        });
        return !matchingInput;
      }).slice(0, __privateMethod(this, _getConfig, getConfig_fn).call(this, "maxGasObjects", options) - 1).map((coin) => ({
        objectId: coin.coinObjectId,
        digest: coin.digest,
        version: coin.version
      }));
      if (!paymentCoins.length) {
        throw new Error("No valid gas coins found for the transaction.");
      }
      this.setGasPayment(paymentCoins);
    };
    _prepareGasPrice = new WeakSet();
    prepareGasPrice_fn = async function(options) {
      if (options.onlyTransactionKind || __privateGet(this, _blockData).gasConfig.price) {
        return;
      }
      this.setGasPrice(await expectClient(options).getReferenceGasPrice());
    };
    _prepareTransactions = new WeakSet();
    prepareTransactions_fn = async function(options) {
      const {inputs, transactions} = __privateGet(this, _blockData);
      const moveModulesToResolve = [];
      const objectsToResolve = [];
      transactions.forEach((transaction) => {
        if (transaction.kind === "MoveCall") {
          const needsResolution = transaction.arguments.some((arg) => arg.kind === "Input" && !(0, import_superstruct.is)(inputs[arg.index].value, import_Inputs.BuilderCallArg));
          if (needsResolution) {
            moveModulesToResolve.push(transaction);
          }
          return;
        }
        const transactionType = (0, import_Transactions.getTransactionType)(transaction);
        if (!transactionType.schema)
          return;
        Object.entries(transaction).forEach(([key, value]) => {
          if (key === "kind")
            return;
          const keySchema = transactionType.schema[key];
          const isArray2 = keySchema.type === "array";
          const wellKnownEncoding = isArray2 ? keySchema.schema[import_utils2.TRANSACTION_TYPE] : keySchema[import_utils2.TRANSACTION_TYPE];
          if (!wellKnownEncoding)
            return;
          const encodeInput = (index) => {
            const input = inputs[index];
            if (!input) {
              throw new Error(`Missing input ${value.index}`);
            }
            if ((0, import_superstruct.is)(input.value, import_Inputs.BuilderCallArg))
              return;
            if (wellKnownEncoding.kind === "object" && typeof input.value === "string") {
              objectsToResolve.push({id: input.value, input});
            } else if (wellKnownEncoding.kind === "pure") {
              input.value = import_Inputs.Inputs.Pure(input.value, wellKnownEncoding.type);
            } else {
              throw new Error("Unexpected input format.");
            }
          };
          if (isArray2) {
            value.forEach((arrayItem) => {
              if (arrayItem.kind !== "Input")
                return;
              encodeInput(arrayItem.index);
            });
          } else {
            if (value.kind !== "Input")
              return;
            encodeInput(value.index);
          }
        });
      });
      if (moveModulesToResolve.length) {
        await Promise.all(moveModulesToResolve.map(async (moveCall) => {
          const [packageId, moduleName, functionName] = moveCall.target.split("::");
          const normalized = await expectClient(options).getNormalizedMoveFunction({
            package: (0, import_sui_types.normalizeSuiObjectId)(packageId),
            module: moduleName,
            function: functionName
          });
          const hasTxContext = normalized.parameters.length > 0 && (0, import_serializer.isTxContext)(normalized.parameters.at(-1));
          const params = hasTxContext ? normalized.parameters.slice(0, normalized.parameters.length - 1) : normalized.parameters;
          if (params.length !== moveCall.arguments.length) {
            throw new Error("Incorrect number of arguments.");
          }
          params.forEach((param, i) => {
            const arg = moveCall.arguments[i];
            if (arg.kind !== "Input")
              return;
            const input = inputs[arg.index];
            if ((0, import_superstruct.is)(input.value, import_Inputs.BuilderCallArg))
              return;
            const inputValue = input.value;
            const serType = (0, import_serializer.getPureSerializationType)(param, inputValue);
            if (serType) {
              input.value = import_Inputs.Inputs.Pure(inputValue, serType);
              return;
            }
            const structVal = (0, import_types.extractStructTag)(param);
            if (structVal != null || typeof param === "object" && "TypeParameter" in param) {
              if (typeof inputValue !== "string") {
                throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(inputValue, null, 2)}`);
              }
              objectsToResolve.push({
                id: inputValue,
                input,
                normalizedType: param
              });
              return;
            }
            throw new Error(`Unknown call arg type ${JSON.stringify(param, null, 2)} for value ${JSON.stringify(inputValue, null, 2)}`);
          });
        }));
      }
      if (objectsToResolve.length) {
        const dedupedIds = [...new Set(objectsToResolve.map(({id}) => id))];
        const objectChunks = chunk(dedupedIds, MAX_OBJECTS_PER_FETCH);
        const objects = (await Promise.all(objectChunks.map((chunk2) => expectClient(options).multiGetObjects({
          ids: chunk2,
          options: {showOwner: true}
        })))).flat();
        let objectsById = new Map(dedupedIds.map((id, index) => {
          return [id, objects[index]];
        }));
        const invalidObjects = Array.from(objectsById).filter(([_, obj]) => obj.error).map(([id, _]) => id);
        if (invalidObjects.length) {
          throw new Error(`The following input objects are invalid: ${invalidObjects.join(", ")}`);
        }
        objectsToResolve.forEach(({id, input, normalizedType}) => {
          const object = objectsById.get(id);
          const owner = object.data?.owner;
          const initialSharedVersion = owner && typeof owner === "object" && "Shared" in owner ? owner.Shared.initial_shared_version : void 0;
          if (initialSharedVersion) {
            const mutable = (0, import_Inputs.isMutableSharedObjectInput)(input.value) || normalizedType != null && (0, import_types.extractMutableReference)(normalizedType) != null;
            input.value = import_Inputs.Inputs.SharedObjectRef({
              objectId: id,
              initialSharedVersion,
              mutable
            });
          } else {
            input.value = import_Inputs.Inputs.ObjectRef((0, import_types.getObjectReference)(object));
          }
        });
      }
    };
    _prepare = new WeakSet();
    prepare_fn = async function(options) {
      if (!options.onlyTransactionKind && !__privateGet(this, _blockData).sender) {
        throw new Error("Missing transaction sender");
      }
      const client = options.client || options.provider;
      if (!options.protocolConfig && !options.limits && client) {
        options.protocolConfig = await client.getProtocolConfig();
      }
      await Promise.all([__privateMethod(this, _prepareGasPrice, prepareGasPrice_fn).call(this, options), __privateMethod(this, _prepareTransactions, prepareTransactions_fn).call(this, options)]);
      if (!options.onlyTransactionKind) {
        await __privateMethod(this, _prepareGasPayment, prepareGasPayment_fn).call(this, options);
        if (!__privateGet(this, _blockData).gasConfig.budget) {
          const dryRunResult = await expectClient(options).dryRunTransactionBlock({
            transactionBlock: __privateGet(this, _blockData).build({
              maxSizeBytes: __privateMethod(this, _getConfig, getConfig_fn).call(this, "maxTxSizeBytes", options),
              overrides: {
                gasConfig: {
                  budget: String(__privateMethod(this, _getConfig, getConfig_fn).call(this, "maxTxGas", options)),
                  payment: []
                }
              }
            })
          });
          if (dryRunResult.effects.status.status !== "success") {
            throw new Error(`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`, {cause: dryRunResult});
          }
          const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(this.blockData.gasConfig.price || 1n);
          const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;
          const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);
          this.setGasBudget(gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead);
        }
      }
      __privateMethod(this, _validate, validate_fn).call(this, options);
    };
    var TransactionBlock2 = _TransactionBlock;
  }
});

// node_modules/@mysten/sui.js/dist/cjs/builder/export.js
var require_export = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/builder/export.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var export_exports = {};
    __export2(export_exports, {
      Inputs: () => import_Inputs.Inputs,
      TransactionBlock: () => import_TransactionBlock.TransactionBlock,
      Transactions: () => import_Transactions.Transactions,
      UpgradePolicy: () => import_Transactions.UpgradePolicy,
      getPureSerializationType: () => import_serializer.getPureSerializationType,
      isTransactionBlock: () => import_TransactionBlock.isTransactionBlock
    });
    module2.exports = __toCommonJS(export_exports);
    var import_serializer = require_serializer();
    var import_Inputs = require_Inputs();
    var import_Transactions = require_Transactions();
    var import_TransactionBlock = require_TransactionBlock();
  }
});

// node_modules/store2/dist/store2.js
var require_store2 = __commonJS({
  "node_modules/store2/dist/store2.js"(exports, module2) {
    (function(window2, define2) {
      var _ = {
        version: "2.14.2",
        areas: {},
        apis: {},
        nsdelim: ".",
        inherit: function(api, o) {
          for (var p in api) {
            if (!o.hasOwnProperty(p)) {
              Object.defineProperty(o, p, Object.getOwnPropertyDescriptor(api, p));
            }
          }
          return o;
        },
        stringify: function(d, fn) {
          return d === void 0 || typeof d === "function" ? d + "" : JSON.stringify(d, fn || _.replace);
        },
        parse: function(s, fn) {
          try {
            return JSON.parse(s, fn || _.revive);
          } catch (e) {
            return s;
          }
        },
        fn: function(name, fn) {
          _.storeAPI[name] = fn;
          for (var api in _.apis) {
            _.apis[api][name] = fn;
          }
        },
        get: function(area, key) {
          return area.getItem(key);
        },
        set: function(area, key, string) {
          area.setItem(key, string);
        },
        remove: function(area, key) {
          area.removeItem(key);
        },
        key: function(area, i) {
          return area.key(i);
        },
        length: function(area) {
          return area.length;
        },
        clear: function(area) {
          area.clear();
        },
        Store: function(id, area, namespace) {
          var store11 = _.inherit(_.storeAPI, function(key, data, overwrite) {
            if (arguments.length === 0) {
              return store11.getAll();
            }
            if (typeof data === "function") {
              return store11.transact(key, data, overwrite);
            }
            if (data !== void 0) {
              return store11.set(key, data, overwrite);
            }
            if (typeof key === "string" || typeof key === "number") {
              return store11.get(key);
            }
            if (typeof key === "function") {
              return store11.each(key);
            }
            if (!key) {
              return store11.clear();
            }
            return store11.setAll(key, data);
          });
          store11._id = id;
          try {
            var testKey = "__store2_test";
            area.setItem(testKey, "ok");
            store11._area = area;
            area.removeItem(testKey);
          } catch (e) {
            store11._area = _.storage("fake");
          }
          store11._ns = namespace || "";
          if (!_.areas[id]) {
            _.areas[id] = store11._area;
          }
          if (!_.apis[store11._ns + store11._id]) {
            _.apis[store11._ns + store11._id] = store11;
          }
          return store11;
        },
        storeAPI: {
          area: function(id, area) {
            var store11 = this[id];
            if (!store11 || !store11.area) {
              store11 = _.Store(id, area, this._ns);
              if (!this[id]) {
                this[id] = store11;
              }
            }
            return store11;
          },
          namespace: function(namespace, singleArea, delim) {
            delim = delim || this._delim || _.nsdelim;
            if (!namespace) {
              return this._ns ? this._ns.substring(0, this._ns.length - delim.length) : "";
            }
            var ns = namespace, store11 = this[ns];
            if (!store11 || !store11.namespace) {
              store11 = _.Store(this._id, this._area, this._ns + ns + delim);
              store11._delim = delim;
              if (!this[ns]) {
                this[ns] = store11;
              }
              if (!singleArea) {
                for (var name in _.areas) {
                  store11.area(name, _.areas[name]);
                }
              }
            }
            return store11;
          },
          isFake: function(force) {
            if (force) {
              this._real = this._area;
              this._area = _.storage("fake");
            } else if (force === false) {
              this._area = this._real || this._area;
            }
            return this._area.name === "fake";
          },
          toString: function() {
            return "store" + (this._ns ? "." + this.namespace() : "") + "[" + this._id + "]";
          },
          has: function(key) {
            if (this._area.has) {
              return this._area.has(this._in(key));
            }
            return !!(this._in(key) in this._area);
          },
          size: function() {
            return this.keys().length;
          },
          each: function(fn, fill) {
            for (var i = 0, m = _.length(this._area); i < m; i++) {
              var key = this._out(_.key(this._area, i));
              if (key !== void 0) {
                if (fn.call(this, key, this.get(key), fill) === false) {
                  break;
                }
              }
              if (m > _.length(this._area)) {
                m--;
                i--;
              }
            }
            return fill || this;
          },
          keys: function(fillList) {
            return this.each(function(k, v, list) {
              list.push(k);
            }, fillList || []);
          },
          get: function(key, alt) {
            var s = _.get(this._area, this._in(key)), fn;
            if (typeof alt === "function") {
              fn = alt;
              alt = null;
            }
            return s !== null ? _.parse(s, fn) : alt != null ? alt : s;
          },
          getAll: function(fillObj) {
            return this.each(function(k, v, all) {
              all[k] = v;
            }, fillObj || {});
          },
          transact: function(key, fn, alt) {
            var val = this.get(key, alt), ret = fn(val);
            this.set(key, ret === void 0 ? val : ret);
            return this;
          },
          set: function(key, data, overwrite) {
            var d = this.get(key), replacer;
            if (d != null && overwrite === false) {
              return data;
            }
            if (typeof overwrite === "function") {
              replacer = overwrite;
              overwrite = void 0;
            }
            return _.set(this._area, this._in(key), _.stringify(data, replacer), overwrite) || d;
          },
          setAll: function(data, overwrite) {
            var changed, val;
            for (var key in data) {
              val = data[key];
              if (this.set(key, val, overwrite) !== val) {
                changed = true;
              }
            }
            return changed;
          },
          add: function(key, data, replacer) {
            var d = this.get(key);
            if (d instanceof Array) {
              data = d.concat(data);
            } else if (d !== null) {
              var type = typeof d;
              if (type === typeof data && type === "object") {
                for (var k in data) {
                  d[k] = data[k];
                }
                data = d;
              } else {
                data = d + data;
              }
            }
            _.set(this._area, this._in(key), _.stringify(data, replacer));
            return data;
          },
          remove: function(key, alt) {
            var d = this.get(key, alt);
            _.remove(this._area, this._in(key));
            return d;
          },
          clear: function() {
            if (!this._ns) {
              _.clear(this._area);
            } else {
              this.each(function(k) {
                _.remove(this._area, this._in(k));
              }, 1);
            }
            return this;
          },
          clearAll: function() {
            var area = this._area;
            for (var id in _.areas) {
              if (_.areas.hasOwnProperty(id)) {
                this._area = _.areas[id];
                this.clear();
              }
            }
            this._area = area;
            return this;
          },
          _in: function(k) {
            if (typeof k !== "string") {
              k = _.stringify(k);
            }
            return this._ns ? this._ns + k : k;
          },
          _out: function(k) {
            return this._ns ? k && k.indexOf(this._ns) === 0 ? k.substring(this._ns.length) : void 0 : k;
          }
        },
        storage: function(name) {
          return _.inherit(_.storageAPI, {items: {}, name});
        },
        storageAPI: {
          length: 0,
          has: function(k) {
            return this.items.hasOwnProperty(k);
          },
          key: function(i) {
            var c = 0;
            for (var k in this.items) {
              if (this.has(k) && i === c++) {
                return k;
              }
            }
          },
          setItem: function(k, v) {
            if (!this.has(k)) {
              this.length++;
            }
            this.items[k] = v;
          },
          removeItem: function(k) {
            if (this.has(k)) {
              delete this.items[k];
              this.length--;
            }
          },
          getItem: function(k) {
            return this.has(k) ? this.items[k] : null;
          },
          clear: function() {
            for (var k in this.items) {
              this.removeItem(k);
            }
          }
        }
      };
      var store10 = _.Store("local", function() {
        try {
          return localStorage;
        } catch (e) {
        }
      }());
      store10.local = store10;
      store10._ = _;
      store10.area("session", function() {
        try {
          return sessionStorage;
        } catch (e) {
        }
      }());
      store10.area("page", _.storage("page"));
      if (typeof define2 === "function" && define2.amd !== void 0) {
        define2("store2", [], function() {
          return store10;
        });
      } else if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = store10;
      } else {
        if (window2.store) {
          _.conflict = window2.store;
        }
        window2.store = store10;
      }
    })(exports, exports && exports.define);
  }
});

// node_modules/@mysten/sui.js/dist/cjs/utils/format.js
var require_format = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/utils/format.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var format_exports = {};
    __export2(format_exports, {
      formatAddress: () => formatAddress,
      formatDigest: () => formatDigest
    });
    module2.exports = __toCommonJS(format_exports);
    var ELLIPSIS = "\u2026";
    function formatAddress(address2) {
      if (address2.length <= 6) {
        return address2;
      }
      const offset = address2.startsWith("0x") ? 2 : 0;
      return `0x${address2.slice(offset, offset + 4)}${ELLIPSIS}${address2.slice(-4)}`;
    }
    function formatDigest(digest) {
      return `${digest.slice(0, 10)}${ELLIPSIS}`;
    }
  }
});

// node_modules/@mysten/sui.js/dist/cjs/utils/index.js
var require_utils3 = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/utils/index.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var utils_exports = {};
    __export2(utils_exports, {
      MIST_PER_SUI: () => MIST_PER_SUI,
      MOVE_STDLIB_ADDRESS: () => MOVE_STDLIB_ADDRESS,
      SUI_ADDRESS_LENGTH: () => import_sui_types.SUI_ADDRESS_LENGTH,
      SUI_CLOCK_OBJECT_ID: () => SUI_CLOCK_OBJECT_ID,
      SUI_DECIMALS: () => SUI_DECIMALS,
      SUI_FRAMEWORK_ADDRESS: () => SUI_FRAMEWORK_ADDRESS,
      SUI_SYSTEM_ADDRESS: () => SUI_SYSTEM_ADDRESS,
      SUI_SYSTEM_MODULE_NAME: () => SUI_SYSTEM_MODULE_NAME,
      SUI_SYSTEM_STATE_OBJECT_ID: () => SUI_SYSTEM_STATE_OBJECT_ID,
      SUI_TYPE_ARG: () => SUI_TYPE_ARG2,
      assert: () => import_superstruct.assert,
      formatAddress: () => import_format.formatAddress,
      formatDigest: () => import_format.formatDigest,
      fromB64: () => import_bcs.fromB64,
      fromHEX: () => import_bcs.fromHEX,
      is: () => import_superstruct.is,
      isValidSuiAddress: () => import_sui_types.isValidSuiAddress,
      isValidSuiObjectId: () => import_sui_types.isValidSuiObjectId,
      isValidTransactionDigest: () => import_sui_types.isValidTransactionDigest,
      normalizeStructTag: () => import_sui_types.normalizeStructTag,
      normalizeSuiAddress: () => import_sui_types.normalizeSuiAddress,
      normalizeSuiObjectId: () => import_sui_types.normalizeSuiObjectId,
      parseStructTag: () => import_sui_types.parseStructTag,
      toB64: () => import_bcs.toB64,
      toHEX: () => import_bcs.toHEX
    });
    module2.exports = __toCommonJS(utils_exports);
    var import_format = require_format();
    var import_sui_types = require_sui_types();
    var import_bcs = require_dist();
    var import_superstruct = require_dist2();
    var SUI_DECIMALS = 9;
    var MIST_PER_SUI = BigInt(1e9);
    var MOVE_STDLIB_ADDRESS = "0x1";
    var SUI_FRAMEWORK_ADDRESS = "0x2";
    var SUI_SYSTEM_ADDRESS = "0x3";
    var SUI_CLOCK_OBJECT_ID = (0, import_sui_types.normalizeSuiObjectId)("0x6");
    var SUI_SYSTEM_MODULE_NAME = "sui_system";
    var SUI_TYPE_ARG2 = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;
    var SUI_SYSTEM_STATE_OBJECT_ID = (0, import_sui_types.normalizeSuiObjectId)("0x5");
  }
});

// node_modules/@mysten/sui.js/dist/cjs/rpc/errors.js
var require_errors = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/rpc/errors.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var errors_exports = {};
    __export2(errors_exports, {
      RPCValidationError: () => RPCValidationError
    });
    module2.exports = __toCommonJS(errors_exports);
    var RPCValidationError = class extends Error {
      constructor(options) {
        super("RPC Validation Error: The response returned from RPC server does not match the TypeScript definition. This is likely because the SDK version is not compatible with the RPC server.", {cause: options.cause});
        this.req = options.req;
        this.result = options.result;
        this.message = this.toString();
      }
      toString() {
        let str = super.toString();
        if (this.cause) {
          str += `
Cause: ${this.cause}`;
        }
        if (this.result) {
          str += `
Reponse Received: ${JSON.stringify(this.result, null, 2)}`;
        }
        return str;
      }
    };
  }
});

// node_modules/events/events.js
var require_events2 = __commonJS({
  "node_modules/events/events.js"(exports, module2) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module2.exports = EventEmitter;
    module2.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners2 = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners2[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit("newListener", type, listener.listener ? listener.listener : listener);
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = {fired: false, wrapFn: void 0, target, type, listener};
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners2, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type];
      if (typeof listeners2 === "function") {
        this.removeListener(type, listeners2);
      } else if (listeners2 !== void 0) {
        for (i = listeners2.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners2[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners2(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, {once: true});
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, {once: true});
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/@open-rpc/client-js/build/RequestManager.js
var require_RequestManager = __commonJS({
  "node_modules/@open-rpc/client-js/build/RequestManager.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: []}, f, y, t, g;
      return g = {next: verb(0), "throw": verb(1), "return": verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {value: op[1], done: false};
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {value: op[0] ? op[1] : void 0, done: true};
      }
    };
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.defaultNextRequest = void 0;
    var events_1 = require_events2();
    exports.defaultNextRequest = function() {
      var lastId = -1;
      return function() {
        return ++lastId;
      };
    };
    var RequestManager = function() {
      function RequestManager2(transports, nextID) {
        if (nextID === void 0) {
          nextID = exports.defaultNextRequest();
        }
        this.batch = [];
        this.batchStarted = false;
        this.lastId = -1;
        this.transports = transports;
        this.requests = {};
        this.connectPromise = this.connect();
        this.requestChannel = new events_1.EventEmitter();
        this.nextID = nextID;
      }
      RequestManager2.prototype.connect = function() {
        var _this = this;
        return Promise.all(this.transports.map(function(transport) {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  transport.subscribe("error", this.handleError.bind(this));
                  transport.subscribe("notification", this.handleNotification.bind(this));
                  return [4, transport.connect()];
                case 1:
                  _a.sent();
                  return [2];
              }
            });
          });
        }));
      };
      RequestManager2.prototype.getPrimaryTransport = function() {
        return this.transports[0];
      };
      RequestManager2.prototype.request = function(requestObject, notification, timeout) {
        if (notification === void 0) {
          notification = false;
        }
        return __awaiter(this, void 0, void 0, function() {
          var internalID, id, payload, result;
          var _this = this;
          return __generator(this, function(_a) {
            internalID = this.nextID().toString();
            id = notification ? null : internalID;
            payload = {request: this.makeRequest(requestObject.method, requestObject.params || [], id), internalID};
            if (this.batchStarted) {
              result = new Promise(function(resolve, reject) {
                _this.batch.push({resolve, reject, request: payload});
              });
              return [2, result];
            }
            return [2, this.getPrimaryTransport().sendData(payload, timeout)];
          });
        });
      };
      RequestManager2.prototype.close = function() {
        this.requestChannel.removeAllListeners();
        this.transports.forEach(function(transport) {
          transport.unsubscribe();
          transport.close();
        });
      };
      RequestManager2.prototype.startBatch = function() {
        this.batchStarted = true;
      };
      RequestManager2.prototype.stopBatch = function() {
        if (this.batchStarted === false) {
          throw new Error("cannot end that which has never started");
        }
        if (this.batch.length === 0) {
          this.batchStarted = false;
          return;
        }
        this.getPrimaryTransport().sendData(this.batch);
        this.batch = [];
        this.batchStarted = false;
      };
      RequestManager2.prototype.makeRequest = function(method, params, id) {
        if (id) {
          return {jsonrpc: "2.0", id, method, params};
        }
        return {jsonrpc: "2.0", method, params};
      };
      RequestManager2.prototype.handleError = function(data) {
        this.requestChannel.emit("error", data);
      };
      RequestManager2.prototype.handleNotification = function(data) {
        this.requestChannel.emit("notification", data);
      };
      return RequestManager2;
    }();
    exports.default = RequestManager;
  }
});

// node_modules/@open-rpc/client-js/build/Error.js
var require_Error = __commonJS({
  "node_modules/@open-rpc/client-js/build/Error.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.convertJSONToRPCError = exports.JSONRPCError = exports.ERR_UNKNOWN = exports.ERR_MISSIING_ID = exports.ERR_TIMEOUT = void 0;
    exports.ERR_TIMEOUT = 7777;
    exports.ERR_MISSIING_ID = 7878;
    exports.ERR_UNKNOWN = 7979;
    var JSONRPCError = function(_super) {
      __extends(JSONRPCError2, _super);
      function JSONRPCError2(message, code, data) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.code = code;
        _this.data = data;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
      }
      return JSONRPCError2;
    }(Error);
    exports.JSONRPCError = JSONRPCError;
    exports.convertJSONToRPCError = function(payload) {
      if (payload.error) {
        var _a = payload.error, message = _a.message, code = _a.code, data = _a.data;
        return new JSONRPCError(message, code, data);
      }
      return new JSONRPCError("Unknown error", exports.ERR_UNKNOWN, payload);
    };
  }
});

// node_modules/@open-rpc/client-js/build/transports/TransportRequestManager.js
var require_TransportRequestManager = __commonJS({
  "node_modules/@open-rpc/client-js/build/transports/TransportRequestManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.TransportRequestManager = void 0;
    var events_1 = require_events2();
    var Error_1 = require_Error();
    var TransportRequestManager = function() {
      function TransportRequestManager2() {
        this.pendingRequest = {};
        this.pendingBatchRequest = {};
        this.transportEventChannel = new events_1.EventEmitter();
      }
      TransportRequestManager2.prototype.addRequest = function(data, timeout) {
        this.transportEventChannel.emit("pending", data);
        if (data instanceof Array) {
          this.addBatchReq(data, timeout);
          return Promise.resolve();
        }
        return this.addReq(data.internalID, timeout);
      };
      TransportRequestManager2.prototype.settlePendingRequest = function(request, error) {
        var _this = this;
        request.forEach(function(req) {
          var resolver = _this.pendingRequest[req.internalID];
          delete _this.pendingBatchRequest[req.internalID];
          if (resolver === void 0) {
            return;
          }
          if (error) {
            resolver.reject(error);
            return;
          }
          resolver.resolve();
          if (req.request.id === null || req.request.id === void 0) {
            delete _this.pendingRequest[req.internalID];
          }
        });
      };
      TransportRequestManager2.prototype.isPendingRequest = function(id) {
        return this.pendingRequest.hasOwnProperty(id);
      };
      TransportRequestManager2.prototype.resolveResponse = function(payload, emitError) {
        if (emitError === void 0) {
          emitError = true;
        }
        var data = payload;
        try {
          data = JSON.parse(payload);
          if (this.checkJSONRPC(data) === false) {
            return;
          }
          if (data instanceof Array) {
            return this.resolveBatch(data, emitError);
          }
          return this.resolveRes(data, emitError);
        } catch (e) {
          var err = new Error_1.JSONRPCError("Bad response format", Error_1.ERR_UNKNOWN, payload);
          if (emitError) {
            this.transportEventChannel.emit("error", err);
          }
          return err;
        }
      };
      TransportRequestManager2.prototype.addBatchReq = function(batches, timeout) {
        var _this = this;
        batches.forEach(function(batch) {
          var resolve = batch.resolve, reject = batch.reject;
          var internalID = batch.request.internalID;
          _this.pendingBatchRequest[internalID] = true;
          _this.pendingRequest[internalID] = {resolve, reject};
        });
        return Promise.resolve();
      };
      TransportRequestManager2.prototype.addReq = function(id, timeout) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          if (timeout !== null && timeout) {
            _this.setRequestTimeout(id, timeout, reject);
          }
          _this.pendingRequest[id] = {resolve, reject};
        });
      };
      TransportRequestManager2.prototype.checkJSONRPC = function(data) {
        var payload = [data];
        if (data instanceof Array) {
          payload = data;
        }
        return payload.every(function(datum) {
          return datum.result !== void 0 || datum.error !== void 0 || datum.method !== void 0;
        });
      };
      TransportRequestManager2.prototype.processResult = function(payload, prom) {
        if (payload.error) {
          var err = Error_1.convertJSONToRPCError(payload);
          prom.reject(err);
          return;
        }
        prom.resolve(payload.result);
      };
      TransportRequestManager2.prototype.resolveBatch = function(payload, emitError) {
        var _this = this;
        var results = payload.map(function(datum) {
          return _this.resolveRes(datum, emitError);
        });
        var errors = results.filter(function(result) {
          return result;
        });
        if (errors.length > 0) {
          return errors[0];
        }
        return void 0;
      };
      TransportRequestManager2.prototype.resolveRes = function(data, emitError) {
        var id = data.id, error = data.error;
        var status = this.pendingRequest[id];
        if (status) {
          delete this.pendingRequest[id];
          this.processResult(data, status);
          this.transportEventChannel.emit("response", data);
          return;
        }
        if (id === void 0 && error === void 0) {
          this.transportEventChannel.emit("notification", data);
          return;
        }
        var err;
        if (error) {
          err = Error_1.convertJSONToRPCError(data);
        }
        if (emitError && error && err) {
          this.transportEventChannel.emit("error", err);
        }
        return err;
      };
      TransportRequestManager2.prototype.setRequestTimeout = function(id, timeout, reject) {
        var _this = this;
        setTimeout(function() {
          delete _this.pendingRequest[id];
          reject(new Error_1.JSONRPCError("Request timeout request took longer than " + timeout + " ms to resolve", Error_1.ERR_TIMEOUT));
        }, timeout);
      };
      return TransportRequestManager2;
    }();
    exports.TransportRequestManager = TransportRequestManager;
  }
});

// node_modules/@open-rpc/client-js/build/transports/Transport.js
var require_Transport = __commonJS({
  "node_modules/@open-rpc/client-js/build/transports/Transport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.Transport = void 0;
    var TransportRequestManager_1 = require_TransportRequestManager();
    var Transport = function() {
      function Transport2() {
        this.transportRequestManager = new TransportRequestManager_1.TransportRequestManager();
        this.transportRequestManager.transportEventChannel.on("error", function() {
        });
      }
      Transport2.prototype.subscribe = function(event2, handler) {
        this.transportRequestManager.transportEventChannel.addListener(event2, handler);
      };
      Transport2.prototype.unsubscribe = function(event2, handler) {
        if (!event2) {
          return this.transportRequestManager.transportEventChannel.removeAllListeners();
        }
        if (event2 && handler) {
          this.transportRequestManager.transportEventChannel.removeListener(event2, handler);
        }
      };
      Transport2.prototype.parseData = function(data) {
        if (data instanceof Array) {
          return data.map(function(batch) {
            return batch.request.request;
          });
        }
        return data.request;
      };
      return Transport2;
    }();
    exports.Transport = Transport;
  }
});

// node_modules/@open-rpc/client-js/build/Request.js
var require_Request = __commonJS({
  "node_modules/@open-rpc/client-js/build/Request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.getNotifications = exports.getBatchRequests = exports.isNotification = void 0;
    exports.isNotification = function(data) {
      return data.request.id === void 0 || data.request.id === null;
    };
    exports.getBatchRequests = function(data) {
      if (data instanceof Array) {
        return data.filter(function(datum) {
          var id = datum.request.request.id;
          return id !== null && id !== void 0;
        }).map(function(batchRequest) {
          return batchRequest.request;
        });
      }
      return [];
    };
    exports.getNotifications = function(data) {
      if (data instanceof Array) {
        return data.filter(function(datum) {
          return exports.isNotification(datum.request);
        }).map(function(batchRequest) {
          return batchRequest.request;
        });
      }
      if (exports.isNotification(data)) {
        return [data];
      }
      return [];
    };
  }
});

// node_modules/@open-rpc/client-js/build/transports/EventEmitterTransport.js
var require_EventEmitterTransport = __commonJS({
  "node_modules/@open-rpc/client-js/build/transports/EventEmitterTransport.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {value: true});
    var Transport_1 = require_Transport();
    var Request_1 = require_Request();
    var Error_1 = require_Error();
    var EventEmitterTransport = function(_super) {
      __extends(EventEmitterTransport2, _super);
      function EventEmitterTransport2(destEmitter, reqUri, resUri) {
        var _this = _super.call(this) || this;
        _this.connection = destEmitter;
        _this.reqUri = reqUri;
        _this.resUri = resUri;
        return _this;
      }
      EventEmitterTransport2.prototype.connect = function() {
        var _this = this;
        this.connection.on(this.resUri, function(data) {
          _this.transportRequestManager.resolveResponse(data);
        });
        return Promise.resolve();
      };
      EventEmitterTransport2.prototype.sendData = function(data, timeout) {
        if (timeout === void 0) {
          timeout = null;
        }
        var prom = this.transportRequestManager.addRequest(data, timeout);
        var notifications = Request_1.getNotifications(data);
        var parsedData = this.parseData(data);
        try {
          this.connection.emit(this.reqUri, parsedData);
          this.transportRequestManager.settlePendingRequest(notifications);
          return prom;
        } catch (e) {
          var responseErr = new Error_1.JSONRPCError(e.message, Error_1.ERR_UNKNOWN, e);
          this.transportRequestManager.settlePendingRequest(notifications, responseErr);
          return Promise.reject(responseErr);
        }
      };
      EventEmitterTransport2.prototype.close = function() {
        this.connection.removeAllListeners();
      };
      return EventEmitterTransport2;
    }(Transport_1.Transport);
    exports.default = EventEmitterTransport;
  }
});

// node_modules/whatwg-fetch/dist/fetch.umd.js
var require_fetch_umd = __commonJS({
  "node_modules/whatwg-fetch/dist/fetch.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.WHATWGFetch = {});
    })(exports, function(exports2) {
      "use strict";
      var global2 = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global2 !== "undefined" && global2;
      var support = {
        searchParams: "URLSearchParams" in global2,
        iterable: "Symbol" in global2 && "iterator" in Symbol,
        blob: "FileReader" in global2 && "Blob" in global2 && function() {
          try {
            new Blob();
            return true;
          } catch (e) {
            return false;
          }
        }(),
        formData: "FormData" in global2,
        arrayBuffer: "ArrayBuffer" in global2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name) {
        if (typeof name !== "string") {
          name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
          throw new TypeError('Invalid character in header field name: "' + name + '"');
        }
        return name.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items) {
        var iterator = {
          next: function() {
            var value = items.shift();
            return {done: value === void 0, value};
          }
        };
        if (support.iterable) {
          iterator[Symbol.iterator] = function() {
            return iterator;
          };
        }
        return iterator;
      }
      function Headers2(headers) {
        this.map = {};
        if (headers instanceof Headers2) {
          headers.forEach(function(value, name) {
            this.append(name, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
          }, this);
        }
      }
      Headers2.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ", " + value : value;
      };
      Headers2.prototype["delete"] = function(name) {
        delete this.map[normalizeName(name)];
      };
      Headers2.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
      };
      Headers2.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
      };
      Headers2.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
      };
      Headers2.prototype.forEach = function(callback, thisArg) {
        for (var name in this.map) {
          if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
          }
        }
      };
      Headers2.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push(name);
        });
        return iteratorFor(items);
      };
      Headers2.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers2.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push([name, value]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
      }
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise;
      }
      function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i = 0; i < view.length; i++) {
          chars[i] = String.fromCharCode(view[i]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this.bodyUsed = this.bodyUsed;
          this._bodyInit = body;
          if (!body) {
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              }
              if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request(input, options) {
        if (!(this instanceof Request)) {
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        }
        options = options || {};
        var body = options.body;
        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers2(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers2(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
        if (this.method === "GET" || this.method === "HEAD") {
          if (options.cache === "no-store" || options.cache === "no-cache") {
            var reParamSearch = /([?&])_=[^&]*/;
            if (reParamSearch.test(this.url)) {
              this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
            } else {
              var reQueryString = /\?/;
              this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
            }
          }
        }
      }
      Request.prototype.clone = function() {
        return new Request(this, {body: this._bodyInit});
      };
      function decode(body) {
        var form = new FormData();
        body.trim().split("&").forEach(function(bytes) {
          if (bytes) {
            var split = bytes.split("=");
            var name = split.shift().replace(/\+/g, " ");
            var value = split.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers = new Headers2();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split("\r").map(function(header) {
          return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
        }).forEach(function(line2) {
          var parts = line2.split(":");
          var key = parts.shift().trim();
          if (key) {
            var value = parts.join(":").trim();
            headers.append(key, value);
          }
        });
        return headers;
      }
      Body.call(Request.prototype);
      function Response(bodyInit, options) {
        if (!(this instanceof Response)) {
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        }
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === void 0 ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
        this.headers = new Headers2(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response.prototype);
      Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers2(this.headers),
          url: this.url
        });
      };
      Response.error = function() {
        var response = new Response(null, {status: 0, statusText: ""});
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response(null, {status, headers: {location: url}});
      };
      exports2.DOMException = global2.DOMException;
      try {
        new exports2.DOMException();
      } catch (err) {
        exports2.DOMException = function(message, name) {
          this.message = message;
          this.name = name;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports2.DOMException.prototype = Object.create(Error.prototype);
        exports2.DOMException.prototype.constructor = exports2.DOMException;
      }
      function fetch2(input, init) {
        return new Promise(function(resolve, reject) {
          var request = new Request(input, init);
          if (request.signal && request.signal.aborted) {
            return reject(new exports2.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest();
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            setTimeout(function() {
              resolve(new Response(body, options));
            }, 0);
          };
          xhr.onerror = function() {
            setTimeout(function() {
              reject(new TypeError("Network request failed"));
            }, 0);
          };
          xhr.ontimeout = function() {
            setTimeout(function() {
              reject(new TypeError("Network request failed"));
            }, 0);
          };
          xhr.onabort = function() {
            setTimeout(function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            }, 0);
          };
          function fixUrl(url) {
            try {
              return url === "" && global2.location.href ? global2.location.href : url;
            } catch (e) {
              return url;
            }
          }
          xhr.open(request.method, fixUrl(request.url), true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if ("responseType" in xhr) {
            if (support.blob) {
              xhr.responseType = "blob";
            } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
              xhr.responseType = "arraybuffer";
            }
          }
          if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2)) {
            Object.getOwnPropertyNames(init.headers).forEach(function(name) {
              xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
            });
          } else {
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
          }
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch2.polyfill = true;
      if (!global2.fetch) {
        global2.fetch = fetch2;
        global2.Headers = Headers2;
        global2.Request = Request;
        global2.Response = Response;
      }
      exports2.Headers = Headers2;
      exports2.Request = Request;
      exports2.Response = Response;
      exports2.fetch = fetch2;
      Object.defineProperty(exports2, "__esModule", {value: true});
    });
  }
});

// node_modules/isomorphic-fetch/fetch-npm-browserify.js
var require_fetch_npm_browserify = __commonJS({
  "node_modules/isomorphic-fetch/fetch-npm-browserify.js"(exports, module2) {
    require_fetch_umd();
    module2.exports = self.fetch.bind(self);
  }
});

// node_modules/@open-rpc/client-js/build/transports/HTTPTransport.js
var require_HTTPTransport = __commonJS({
  "node_modules/@open-rpc/client-js/build/transports/HTTPTransport.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: []}, f, y, t, g;
      return g = {next: verb(0), "throw": verb(1), "return": verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {value: op[1], done: false};
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {value: op[0] ? op[1] : void 0, done: true};
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.HTTPTransport = void 0;
    var isomorphic_fetch_1 = __importDefault(require_fetch_npm_browserify());
    var Transport_1 = require_Transport();
    var Request_1 = require_Request();
    var Error_1 = require_Error();
    var HTTPTransport = function(_super) {
      __extends(HTTPTransport2, _super);
      function HTTPTransport2(uri, options) {
        var _this = _super.call(this) || this;
        _this.onlyNotifications = function(data) {
          if (data instanceof Array) {
            return data.every(function(datum) {
              return datum.request.request.id === null || datum.request.request.id === void 0;
            });
          }
          return data.request.id === null || data.request.id === void 0;
        };
        _this.uri = uri;
        _this.credentials = options && options.credentials;
        _this.headers = HTTPTransport2.setupHeaders(options && options.headers);
        _this.injectedFetcher = options === null || options === void 0 ? void 0 : options.fetcher;
        return _this;
      }
      HTTPTransport2.prototype.connect = function() {
        return Promise.resolve();
      };
      HTTPTransport2.prototype.sendData = function(data, timeout) {
        if (timeout === void 0) {
          timeout = null;
        }
        return __awaiter(this, void 0, void 0, function() {
          var prom, notifications, batch, fetcher, result, body, responseErr, e_1, responseErr;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                prom = this.transportRequestManager.addRequest(data, timeout);
                notifications = Request_1.getNotifications(data);
                batch = Request_1.getBatchRequests(data);
                fetcher = this.injectedFetcher || isomorphic_fetch_1.default;
                _a.label = 1;
              case 1:
                _a.trys.push([1, 4, , 5]);
                return [4, fetcher(this.uri, {
                  method: "POST",
                  headers: this.headers,
                  body: JSON.stringify(this.parseData(data)),
                  credentials: this.credentials
                })];
              case 2:
                result = _a.sent();
                this.transportRequestManager.settlePendingRequest(notifications);
                if (this.onlyNotifications(data)) {
                  return [2, Promise.resolve()];
                }
                return [4, result.text()];
              case 3:
                body = _a.sent();
                responseErr = this.transportRequestManager.resolveResponse(body);
                if (responseErr) {
                  this.transportRequestManager.settlePendingRequest(batch, responseErr);
                  return [2, Promise.reject(responseErr)];
                }
                return [3, 5];
              case 4:
                e_1 = _a.sent();
                responseErr = new Error_1.JSONRPCError(e_1.message, Error_1.ERR_UNKNOWN, e_1);
                this.transportRequestManager.settlePendingRequest(notifications, responseErr);
                this.transportRequestManager.settlePendingRequest(Request_1.getBatchRequests(data), responseErr);
                return [2, Promise.reject(responseErr)];
              case 5:
                return [2, prom];
            }
          });
        });
      };
      HTTPTransport2.prototype.close = function() {
      };
      HTTPTransport2.setupHeaders = function(headerOptions) {
        var headers = new Headers(headerOptions);
        headers.set("Content-Type", "application/json");
        return headers;
      };
      return HTTPTransport2;
    }(Transport_1.Transport);
    exports.HTTPTransport = HTTPTransport;
    exports.default = HTTPTransport;
  }
});

// node_modules/isomorphic-ws/browser.js
var browser_exports = {};
__export(browser_exports, {
  default: () => browser_default
});
var ws, browser_default;
var init_browser = __esm({
  "node_modules/isomorphic-ws/browser.js"() {
    ws = null;
    if (typeof WebSocket !== "undefined") {
      ws = WebSocket;
    } else if (typeof MozWebSocket !== "undefined") {
      ws = MozWebSocket;
    } else if (typeof global !== "undefined") {
      ws = global.WebSocket || global.MozWebSocket;
    } else if (typeof window !== "undefined") {
      ws = window.WebSocket || window.MozWebSocket;
    } else if (typeof self !== "undefined") {
      ws = self.WebSocket || self.MozWebSocket;
    }
    browser_default = ws;
  }
});

// node_modules/@open-rpc/client-js/build/transports/WebSocketTransport.js
var require_WebSocketTransport = __commonJS({
  "node_modules/@open-rpc/client-js/build/transports/WebSocketTransport.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: []}, f, y, t, g;
      return g = {next: verb(0), "throw": verb(1), "return": verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {value: op[1], done: false};
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {value: op[0] ? op[1] : void 0, done: true};
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports, "__esModule", {value: true});
    var isomorphic_ws_1 = __importDefault((init_browser(), browser_exports));
    var Transport_1 = require_Transport();
    var Request_1 = require_Request();
    var Error_1 = require_Error();
    var WebSocketTransport = function(_super) {
      __extends(WebSocketTransport2, _super);
      function WebSocketTransport2(uri) {
        var _this = _super.call(this) || this;
        _this.uri = uri;
        _this.connection = new isomorphic_ws_1.default(uri);
        return _this;
      }
      WebSocketTransport2.prototype.connect = function() {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var cb = function() {
            _this.connection.removeEventListener("open", cb);
            resolve();
          };
          _this.connection.addEventListener("open", cb);
          _this.connection.addEventListener("message", function(message) {
            var data = message.data;
            _this.transportRequestManager.resolveResponse(data);
          });
        });
      };
      WebSocketTransport2.prototype.sendData = function(data, timeout) {
        if (timeout === void 0) {
          timeout = 5e3;
        }
        return __awaiter(this, void 0, void 0, function() {
          var prom, notifications, jsonError;
          return __generator(this, function(_a) {
            prom = this.transportRequestManager.addRequest(data, timeout);
            notifications = Request_1.getNotifications(data);
            try {
              this.connection.send(JSON.stringify(this.parseData(data)));
              this.transportRequestManager.settlePendingRequest(notifications);
            } catch (err) {
              jsonError = new Error_1.JSONRPCError(err.message, Error_1.ERR_UNKNOWN, err);
              this.transportRequestManager.settlePendingRequest(notifications, jsonError);
              this.transportRequestManager.settlePendingRequest(Request_1.getBatchRequests(data), jsonError);
              prom = Promise.reject(jsonError);
            }
            return [2, prom];
          });
        });
      };
      WebSocketTransport2.prototype.close = function() {
        this.connection.close();
      };
      return WebSocketTransport2;
    }(Transport_1.Transport);
    exports.default = WebSocketTransport;
  }
});

// node_modules/@open-rpc/client-js/build/transports/PostMessageWindowTransport.js
var require_PostMessageWindowTransport = __commonJS({
  "node_modules/@open-rpc/client-js/build/transports/PostMessageWindowTransport.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: []}, f, y, t, g;
      return g = {next: verb(0), "throw": verb(1), "return": verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {value: op[1], done: false};
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {value: op[0] ? op[1] : void 0, done: true};
      }
    };
    Object.defineProperty(exports, "__esModule", {value: true});
    var Transport_1 = require_Transport();
    var Request_1 = require_Request();
    var openPopup = function(url) {
      var width = 400;
      var height = window.screen.height;
      var left = 0;
      var top = 0;
      return window.open(url, "inspector:popup", "left=" + left + ",top=" + top + ",width=" + width + ",height=" + height + ",resizable,scrollbars=yes,status=1");
    };
    var PostMessageTransport = function(_super) {
      __extends(PostMessageTransport2, _super);
      function PostMessageTransport2(uri) {
        var _this = _super.call(this) || this;
        _this.messageHandler = function(ev) {
          _this.transportRequestManager.resolveResponse(JSON.stringify(ev.data));
        };
        _this.uri = uri;
        _this.postMessageID = "post-message-transport-" + Math.random();
        return _this;
      }
      PostMessageTransport2.prototype.createWindow = function(uri) {
        return new Promise(function(resolve, reject) {
          var frame;
          frame = openPopup(uri);
          setTimeout(function() {
            resolve(frame);
          }, 3e3);
        });
      };
      PostMessageTransport2.prototype.connect = function() {
        var _this = this;
        var urlRegex = /^(http|https):\/\/.*$/;
        return new Promise(function(resolve, reject) {
          return __awaiter(_this, void 0, void 0, function() {
            var _a;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (!urlRegex.test(this.uri)) {
                    reject(new Error("Bad URI"));
                  }
                  _a = this;
                  return [4, this.createWindow(this.uri)];
                case 1:
                  _a.frame = _b.sent();
                  window.addEventListener("message", this.messageHandler);
                  resolve();
                  return [2];
              }
            });
          });
        });
      };
      PostMessageTransport2.prototype.sendData = function(data, timeout) {
        if (timeout === void 0) {
          timeout = 5e3;
        }
        return __awaiter(this, void 0, void 0, function() {
          var prom, notifications;
          return __generator(this, function(_a) {
            prom = this.transportRequestManager.addRequest(data, null);
            notifications = Request_1.getNotifications(data);
            if (this.frame) {
              this.frame.postMessage(data.request, this.uri);
              this.transportRequestManager.settlePendingRequest(notifications);
            }
            return [2, prom];
          });
        });
      };
      PostMessageTransport2.prototype.close = function() {
        if (this.frame) {
          window.removeEventListener("message", this.messageHandler);
          this.frame.close();
        }
      };
      return PostMessageTransport2;
    }(Transport_1.Transport);
    exports.default = PostMessageTransport;
  }
});

// node_modules/@open-rpc/client-js/build/transports/PostMessageIframeTransport.js
var require_PostMessageIframeTransport = __commonJS({
  "node_modules/@open-rpc/client-js/build/transports/PostMessageIframeTransport.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: []}, f, y, t, g;
      return g = {next: verb(0), "throw": verb(1), "return": verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {value: op[1], done: false};
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {value: op[0] ? op[1] : void 0, done: true};
      }
    };
    Object.defineProperty(exports, "__esModule", {value: true});
    var Transport_1 = require_Transport();
    var Request_1 = require_Request();
    var PostMessageIframeTransport = function(_super) {
      __extends(PostMessageIframeTransport2, _super);
      function PostMessageIframeTransport2(uri) {
        var _this = _super.call(this) || this;
        _this.messageHandler = function(ev) {
          _this.transportRequestManager.resolveResponse(JSON.stringify(ev.data));
        };
        _this.uri = uri;
        _this.postMessageID = "post-message-transport-" + Math.random();
        return _this;
      }
      PostMessageIframeTransport2.prototype.createWindow = function(uri) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var frame;
          var iframe = document.createElement("iframe");
          iframe.setAttribute("id", _this.postMessageID);
          iframe.setAttribute("width", "0px");
          iframe.setAttribute("height", "0px");
          iframe.setAttribute("style", "visiblity:hidden;border:none;outline:none;");
          iframe.addEventListener("load", function() {
            resolve(frame);
          });
          iframe.setAttribute("src", uri);
          window.document.body.appendChild(iframe);
          frame = iframe.contentWindow;
        });
      };
      PostMessageIframeTransport2.prototype.connect = function() {
        var _this = this;
        var urlRegex = /^(http|https):\/\/.*$/;
        return new Promise(function(resolve, reject) {
          return __awaiter(_this, void 0, void 0, function() {
            var _a;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (!urlRegex.test(this.uri)) {
                    reject(new Error("Bad URI"));
                  }
                  _a = this;
                  return [4, this.createWindow(this.uri)];
                case 1:
                  _a.frame = _b.sent();
                  window.addEventListener("message", this.messageHandler);
                  resolve();
                  return [2];
              }
            });
          });
        });
      };
      PostMessageIframeTransport2.prototype.sendData = function(data, timeout) {
        if (timeout === void 0) {
          timeout = 5e3;
        }
        return __awaiter(this, void 0, void 0, function() {
          var prom, notifications;
          return __generator(this, function(_a) {
            prom = this.transportRequestManager.addRequest(data, null);
            notifications = Request_1.getNotifications(data);
            if (this.frame) {
              this.frame.postMessage(data.request, "*");
              this.transportRequestManager.settlePendingRequest(notifications);
            }
            return [2, prom];
          });
        });
      };
      PostMessageIframeTransport2.prototype.close = function() {
        var el = document.getElementById(this.postMessageID);
        el === null || el === void 0 ? void 0 : el.remove();
        window.removeEventListener("message", this.messageHandler);
      };
      return PostMessageIframeTransport2;
    }(Transport_1.Transport);
    exports.default = PostMessageIframeTransport;
  }
});

// node_modules/@open-rpc/client-js/build/Client.js
var require_Client = __commonJS({
  "node_modules/@open-rpc/client-js/build/Client.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: []}, f, y, t, g;
      return g = {next: verb(0), "throw": verb(1), "return": verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {value: op[1], done: false};
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {value: op[0] ? op[1] : void 0, done: true};
      }
    };
    Object.defineProperty(exports, "__esModule", {value: true});
    var Client = function() {
      function Client2(requestManager) {
        this.requestManager = requestManager;
      }
      Client2.prototype.startBatch = function() {
        return this.requestManager.startBatch();
      };
      Client2.prototype.stopBatch = function() {
        return this.requestManager.stopBatch();
      };
      Client2.prototype.request = function(requestObject, timeout) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!this.requestManager.connectPromise)
                  return [3, 2];
                return [4, this.requestManager.connectPromise];
              case 1:
                _a.sent();
                _a.label = 2;
              case 2:
                return [2, this.requestManager.request(requestObject, false, timeout)];
            }
          });
        });
      };
      Client2.prototype.notify = function(requestObject) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!this.requestManager.connectPromise)
                  return [3, 2];
                return [4, this.requestManager.connectPromise];
              case 1:
                _a.sent();
                _a.label = 2;
              case 2:
                return [2, this.requestManager.request(requestObject, true, null)];
            }
          });
        });
      };
      Client2.prototype.onNotification = function(callback) {
        this.requestManager.requestChannel.addListener("notification", callback);
      };
      Client2.prototype.onError = function(callback) {
        this.requestManager.requestChannel.addListener("error", callback);
      };
      Client2.prototype.close = function() {
        this.requestManager.close();
      };
      return Client2;
    }();
    exports.default = Client;
  }
});

// node_modules/@open-rpc/client-js/build/index.js
var require_build = __commonJS({
  "node_modules/@open-rpc/client-js/build/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.PostMessageIframeTransport = exports.PostMessageWindowTransport = exports.JSONRPCError = exports.WebSocketTransport = exports.EventEmitterTransport = exports.HTTPTransport = exports.RequestManager = exports.Client = void 0;
    var RequestManager_1 = __importDefault(require_RequestManager());
    exports.RequestManager = RequestManager_1.default;
    var EventEmitterTransport_1 = __importDefault(require_EventEmitterTransport());
    exports.EventEmitterTransport = EventEmitterTransport_1.default;
    var HTTPTransport_1 = __importDefault(require_HTTPTransport());
    exports.HTTPTransport = HTTPTransport_1.default;
    var WebSocketTransport_1 = __importDefault(require_WebSocketTransport());
    exports.WebSocketTransport = WebSocketTransport_1.default;
    var PostMessageWindowTransport_1 = __importDefault(require_PostMessageWindowTransport());
    exports.PostMessageWindowTransport = PostMessageWindowTransport_1.default;
    var PostMessageIframeTransport_1 = __importDefault(require_PostMessageIframeTransport());
    exports.PostMessageIframeTransport = PostMessageIframeTransport_1.default;
    var Error_1 = require_Error();
    Object.defineProperty(exports, "JSONRPCError", {enumerable: true, get: function() {
      return Error_1.JSONRPCError;
    }});
    var Client_1 = __importDefault(require_Client());
    exports.Client = Client_1.default;
    exports.default = Client_1.default;
  }
});

// node_modules/@mysten/sui.js/dist/cjs/version.js
var require_version = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/version.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var version_exports = {};
    __export2(version_exports, {
      PACKAGE_VERSION: () => PACKAGE_VERSION,
      TARGETED_RPC_VERSION: () => TARGETED_RPC_VERSION
    });
    module2.exports = __toCommonJS(version_exports);
    var PACKAGE_VERSION = "0.42.0";
    var TARGETED_RPC_VERSION = "1.10.0";
  }
});

// node_modules/@mysten/sui.js/dist/cjs/rpc/websocket-client.js
var require_websocket_client = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/rpc/websocket-client.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var __accessCheck = (obj, member, msg) => {
      if (!member.has(obj))
        throw TypeError("Cannot " + msg);
    };
    var __privateGet = (obj, member, getter) => {
      __accessCheck(obj, member, "read from private field");
      return getter ? getter.call(obj) : member.get(obj);
    };
    var __privateAdd = (obj, member, value) => {
      if (member.has(obj))
        throw TypeError("Cannot add the same private member more than once");
      member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    };
    var __privateSet = (obj, member, value, setter) => {
      __accessCheck(obj, member, "write to private field");
      setter ? setter.call(obj, value) : member.set(obj, value);
      return value;
    };
    var __privateWrapper = (obj, member, setter, getter) => ({
      set _(value) {
        __privateSet(obj, member, value, setter);
      },
      get _() {
        return __privateGet(obj, member, getter);
      }
    });
    var __privateMethod = (obj, member, method) => {
      __accessCheck(obj, member, "access private method");
      return method;
    };
    var websocket_client_exports = {};
    __export2(websocket_client_exports, {
      DEFAULT_CLIENT_OPTIONS: () => DEFAULT_CLIENT_OPTIONS,
      WebsocketClient: () => WebsocketClient,
      getWebsocketUrl: () => getWebsocketUrl
    });
    module2.exports = __toCommonJS(websocket_client_exports);
    var import_client_js = require_build();
    var _client;
    var _subscriptions;
    var _disconnects;
    var _setupClient;
    var setupClient_fn;
    var _reconnect;
    var reconnect_fn;
    var getWebsocketUrl = (httpUrl, port) => {
      const url = new URL(httpUrl);
      url.protocol = url.protocol.replace("http", "ws");
      if (port) {
        url.port = port.toString();
      }
      return url.toString();
    };
    var DEFAULT_CLIENT_OPTIONS = {
      callTimeout: 3e4,
      reconnectTimeout: 3e3,
      maxReconnects: 5
    };
    var WebsocketClient = class {
      constructor(endpoint, options = {}) {
        __privateAdd(this, _setupClient);
        __privateAdd(this, _reconnect);
        __privateAdd(this, _client, void 0);
        __privateAdd(this, _subscriptions, void 0);
        __privateAdd(this, _disconnects, void 0);
        this.endpoint = endpoint;
        this.options = {...DEFAULT_CLIENT_OPTIONS, ...options};
        if (this.endpoint.startsWith("http")) {
          this.endpoint = getWebsocketUrl(this.endpoint);
        }
        __privateSet(this, _client, null);
        __privateSet(this, _subscriptions, /* @__PURE__ */ new Map());
        __privateSet(this, _disconnects, 0);
      }
      async request(input) {
        const client = __privateMethod(this, _setupClient, setupClient_fn).call(this);
        const id = await client.request({method: input.method, params: input.params}, this.options.callTimeout);
        const initialId = input.initialId || id;
        __privateGet(this, _subscriptions).set(initialId, {
          ...input,
          id,
          initialId
        });
        return async () => {
          const client2 = __privateMethod(this, _setupClient, setupClient_fn).call(this);
          const subscription = __privateGet(this, _subscriptions).get(initialId);
          if (!subscription)
            return false;
          __privateGet(this, _subscriptions).delete(initialId);
          return client2.request({method: input.unsubscribe, params: [subscription.id]}, this.options.callTimeout);
        };
      }
    };
    _client = new WeakMap();
    _subscriptions = new WeakMap();
    _disconnects = new WeakMap();
    _setupClient = new WeakSet();
    setupClient_fn = function() {
      if (__privateGet(this, _client)) {
        return __privateGet(this, _client);
      }
      const transport = new import_client_js.WebSocketTransport(this.endpoint);
      const requestManager = new import_client_js.RequestManager([transport]);
      __privateSet(this, _client, new import_client_js.Client(requestManager));
      transport.connection.addEventListener("open", () => {
        __privateSet(this, _disconnects, 0);
      });
      transport.connection.addEventListener("close", () => {
        __privateWrapper(this, _disconnects)._++;
        if (__privateGet(this, _disconnects) <= this.options.maxReconnects) {
          setTimeout(() => {
            __privateMethod(this, _reconnect, reconnect_fn).call(this);
          }, this.options.reconnectTimeout);
        }
      });
      __privateGet(this, _client).onNotification((data) => {
        const params = data.params;
        __privateGet(this, _subscriptions).forEach((subscription) => {
          if (subscription.method === data.method && params.subscription === subscription.id) {
            subscription.onMessage(params.result);
          }
        });
      });
      return __privateGet(this, _client);
    };
    _reconnect = new WeakSet();
    reconnect_fn = function() {
      __privateGet(this, _client)?.close();
      __privateSet(this, _client, null);
      __privateGet(this, _subscriptions).forEach((subscription) => this.request(subscription));
    };
  }
});

// node_modules/@mysten/sui.js/dist/cjs/client/http-transport.js
var require_http_transport = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/client/http-transport.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var http_transport_exports = {};
    __export2(http_transport_exports, {
      SuiHTTPTransport: () => SuiHTTPTransport
    });
    module2.exports = __toCommonJS(http_transport_exports);
    var import_client_js = require_build();
    var import_version = require_version();
    var import_websocket_client = require_websocket_client();
    var SuiHTTPTransport = class {
      constructor({
        url,
        websocket: {url: websocketUrl, ...websocketOptions} = {},
        rpc
      }) {
        const transport = new import_client_js.HTTPTransport(rpc?.url ?? url, {
          headers: {
            "Content-Type": "application/json",
            "Client-Sdk-Type": "typescript",
            "Client-Sdk-Version": import_version.PACKAGE_VERSION,
            "Client-Target-Api-Version": import_version.TARGETED_RPC_VERSION,
            ...rpc?.headers
          }
        });
        this.rpcClient = new import_client_js.Client(new import_client_js.RequestManager([transport]));
        this.websocketClient = new import_websocket_client.WebsocketClient(websocketUrl ?? url, websocketOptions);
      }
      async request(input) {
        return await this.rpcClient.request(input);
      }
      async subscribe(input) {
        const unsubscribe = await this.websocketClient.request(input);
        return async () => !!await unsubscribe();
      }
    };
  }
});

// node_modules/@mysten/sui.js/dist/cjs/client/network.js
var require_network = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/client/network.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var network_exports = {};
    __export2(network_exports, {
      getFullnodeUrl: () => getFullnodeUrl
    });
    module2.exports = __toCommonJS(network_exports);
    function getFullnodeUrl(network) {
      switch (network) {
        case "mainnet":
          return "https://fullnode.mainnet.sui.io:443";
        case "testnet":
          return "https://fullnode.testnet.sui.io:443";
        case "devnet":
          return "https://fullnode.devnet.sui.io:443";
        case "localnet":
          return "http://127.0.0.1:9000";
        default:
          throw new Error(`Unknown network: ${network}`);
      }
    }
  }
});

// node_modules/@mysten/sui.js/dist/cjs/client/types/chain.js
var require_chain = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/client/types/chain.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var chain_exports = {};
    module2.exports = __toCommonJS(chain_exports);
  }
});

// node_modules/@mysten/sui.js/dist/cjs/client/types/coins.js
var require_coins = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/client/types/coins.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var coins_exports = {};
    module2.exports = __toCommonJS(coins_exports);
  }
});

// node_modules/@mysten/sui.js/dist/cjs/client/types/common.js
var require_common2 = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/client/types/common.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var common_exports = {};
    module2.exports = __toCommonJS(common_exports);
  }
});

// node_modules/@mysten/sui.js/dist/cjs/client/types/changes.js
var require_changes = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/client/types/changes.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var changes_exports = {};
    module2.exports = __toCommonJS(changes_exports);
  }
});

// node_modules/@mysten/sui.js/dist/cjs/client/types/generated.js
var require_generated = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/client/types/generated.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var generated_exports = {};
    module2.exports = __toCommonJS(generated_exports);
  }
});

// node_modules/@mysten/sui.js/dist/cjs/client/types/params.js
var require_params = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/client/types/params.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var params_exports = {};
    module2.exports = __toCommonJS(params_exports);
  }
});

// node_modules/@mysten/sui.js/dist/cjs/client/types/index.js
var require_types2 = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/client/types/index.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __reExport2 = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var types_exports = {};
    module2.exports = __toCommonJS(types_exports);
    __reExport2(types_exports, require_chain(), module2.exports);
    __reExport2(types_exports, require_coins(), module2.exports);
    __reExport2(types_exports, require_common2(), module2.exports);
    __reExport2(types_exports, require_changes(), module2.exports);
    __reExport2(types_exports, require_generated(), module2.exports);
    __reExport2(types_exports, require_params(), module2.exports);
  }
});

// node_modules/@mysten/sui.js/dist/cjs/builder/index.js
var require_builder = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/builder/index.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __reExport2 = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var builder_exports = {};
    module2.exports = __toCommonJS(builder_exports);
    __reExport2(builder_exports, require_TransactionBlock(), module2.exports);
    __reExport2(builder_exports, require_Transactions(), module2.exports);
    __reExport2(builder_exports, require_Inputs(), module2.exports);
    __reExport2(builder_exports, require_bcs2(), module2.exports);
    __reExport2(builder_exports, require_serializer(), module2.exports);
  }
});

// node_modules/@mysten/sui.js/dist/cjs/client/client.js
var require_client = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/client/client.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var client_exports = {};
    __export2(client_exports, {
      SUI_CLIENT_BRAND: () => SUI_CLIENT_BRAND,
      SuiClient: () => SuiClient4,
      isSuiClient: () => isSuiClient
    });
    module2.exports = __toCommonJS(client_exports);
    var import_sui_types = require_sui_types();
    var import_bcs = require_dist();
    var import_builder = require_builder();
    var import_http_transport = require_http_transport();
    var SUI_CLIENT_BRAND = Symbol.for("@mysten/SuiClient");
    function isSuiClient(client) {
      return typeof client === "object" && client !== null && client[SUI_CLIENT_BRAND] === true;
    }
    var SuiClient4 = class {
      get [SUI_CLIENT_BRAND]() {
        return true;
      }
      constructor(options) {
        this.transport = options.transport ?? new import_http_transport.SuiHTTPTransport({url: options.url});
      }
      async getRpcApiVersion() {
        const resp = await this.transport.request({
          method: "rpc.discover",
          params: []
        });
        return resp.info.version;
      }
      async getCoins(input) {
        if (!input.owner || !(0, import_sui_types.isValidSuiAddress)((0, import_sui_types.normalizeSuiAddress)(input.owner))) {
          throw new Error("Invalid Sui address");
        }
        return await this.transport.request({
          method: "suix_getCoins",
          params: [input.owner, input.coinType, input.cursor, input.limit]
        });
      }
      async getAllCoins(input) {
        if (!input.owner || !(0, import_sui_types.isValidSuiAddress)((0, import_sui_types.normalizeSuiAddress)(input.owner))) {
          throw new Error("Invalid Sui address");
        }
        return await this.transport.request({
          method: "suix_getAllCoins",
          params: [input.owner, input.cursor, input.limit]
        });
      }
      async getBalance(input) {
        if (!input.owner || !(0, import_sui_types.isValidSuiAddress)((0, import_sui_types.normalizeSuiAddress)(input.owner))) {
          throw new Error("Invalid Sui address");
        }
        return await this.transport.request({
          method: "suix_getBalance",
          params: [input.owner, input.coinType]
        });
      }
      async getAllBalances(input) {
        if (!input.owner || !(0, import_sui_types.isValidSuiAddress)((0, import_sui_types.normalizeSuiAddress)(input.owner))) {
          throw new Error("Invalid Sui address");
        }
        return await this.transport.request({method: "suix_getAllBalances", params: [input.owner]});
      }
      async getCoinMetadata(input) {
        return await this.transport.request({
          method: "suix_getCoinMetadata",
          params: [input.coinType]
        });
      }
      async getTotalSupply(input) {
        return await this.transport.request({
          method: "suix_getTotalSupply",
          params: [input.coinType]
        });
      }
      async call(method, params) {
        return await this.transport.request({method, params});
      }
      async getMoveFunctionArgTypes(input) {
        return await this.transport.request({
          method: "sui_getMoveFunctionArgTypes",
          params: [input.package, input.module, input.function]
        });
      }
      async getNormalizedMoveModulesByPackage(input) {
        return await this.transport.request({
          method: "sui_getNormalizedMoveModulesByPackage",
          params: [input.package]
        });
      }
      async getNormalizedMoveModule(input) {
        return await this.transport.request({
          method: "sui_getNormalizedMoveModule",
          params: [input.package, input.module]
        });
      }
      async getNormalizedMoveFunction(input) {
        return await this.transport.request({
          method: "sui_getNormalizedMoveFunction",
          params: [input.package, input.module, input.function]
        });
      }
      async getNormalizedMoveStruct(input) {
        return await this.transport.request({
          method: "sui_getNormalizedMoveStruct",
          params: [input.package, input.module, input.struct]
        });
      }
      async getOwnedObjects(input) {
        if (!input.owner || !(0, import_sui_types.isValidSuiAddress)((0, import_sui_types.normalizeSuiAddress)(input.owner))) {
          throw new Error("Invalid Sui address");
        }
        return await this.transport.request({
          method: "suix_getOwnedObjects",
          params: [
            input.owner,
            {
              filter: input.filter,
              options: input.options
            },
            input.cursor,
            input.limit
          ]
        });
      }
      async getObject(input) {
        if (!input.id || !(0, import_sui_types.isValidSuiObjectId)((0, import_sui_types.normalizeSuiObjectId)(input.id))) {
          throw new Error("Invalid Sui Object id");
        }
        return await this.transport.request({
          method: "sui_getObject",
          params: [input.id, input.options]
        });
      }
      async tryGetPastObject(input) {
        return await this.transport.request({
          method: "sui_tryGetPastObject",
          params: [input.id, input.version, input.options]
        });
      }
      async multiGetObjects(input) {
        input.ids.forEach((id) => {
          if (!id || !(0, import_sui_types.isValidSuiObjectId)((0, import_sui_types.normalizeSuiObjectId)(id))) {
            throw new Error(`Invalid Sui Object id ${id}`);
          }
        });
        const hasDuplicates = input.ids.length !== new Set(input.ids).size;
        if (hasDuplicates) {
          throw new Error(`Duplicate object ids in batch call ${input.ids}`);
        }
        return await this.transport.request({
          method: "sui_multiGetObjects",
          params: [input.ids, input.options]
        });
      }
      async queryTransactionBlocks(input) {
        return await this.transport.request({
          method: "suix_queryTransactionBlocks",
          params: [
            {
              filter: input.filter,
              options: input.options
            },
            input.cursor,
            input.limit,
            (input.order || "descending") === "descending"
          ]
        });
      }
      async getTransactionBlock(input) {
        if (!(0, import_sui_types.isValidTransactionDigest)(input.digest)) {
          throw new Error("Invalid Transaction digest");
        }
        return await this.transport.request({
          method: "sui_getTransactionBlock",
          params: [input.digest, input.options]
        });
      }
      async multiGetTransactionBlocks(input) {
        input.digests.forEach((d) => {
          if (!(0, import_sui_types.isValidTransactionDigest)(d)) {
            throw new Error(`Invalid Transaction digest ${d}`);
          }
        });
        const hasDuplicates = input.digests.length !== new Set(input.digests).size;
        if (hasDuplicates) {
          throw new Error(`Duplicate digests in batch call ${input.digests}`);
        }
        return await this.transport.request({
          method: "sui_multiGetTransactionBlocks",
          params: [input.digests, input.options]
        });
      }
      async executeTransactionBlock(input) {
        return await this.transport.request({
          method: "sui_executeTransactionBlock",
          params: [
            typeof input.transactionBlock === "string" ? input.transactionBlock : (0, import_bcs.toB64)(input.transactionBlock),
            Array.isArray(input.signature) ? input.signature : [input.signature],
            input.options,
            input.requestType
          ]
        });
      }
      async signAndExecuteTransactionBlock({
        transactionBlock,
        signer,
        ...input
      }) {
        let transactionBytes;
        if (transactionBlock instanceof Uint8Array) {
          transactionBytes = transactionBlock;
        } else {
          transactionBlock.setSenderIfNotSet(await signer.getPublicKey().toSuiAddress());
          transactionBytes = await transactionBlock.build({client: this});
        }
        const {signature, bytes} = await signer.signTransactionBlock(transactionBytes);
        return this.executeTransactionBlock({
          transactionBlock: bytes,
          signature,
          ...input
        });
      }
      async getTotalTransactionBlocks() {
        const resp = await this.transport.request({
          method: "sui_getTotalTransactionBlocks",
          params: []
        });
        return BigInt(resp);
      }
      async getReferenceGasPrice() {
        const resp = await this.transport.request({
          method: "suix_getReferenceGasPrice",
          params: []
        });
        return BigInt(resp);
      }
      async getStakes(input) {
        if (!input.owner || !(0, import_sui_types.isValidSuiAddress)((0, import_sui_types.normalizeSuiAddress)(input.owner))) {
          throw new Error("Invalid Sui address");
        }
        return await this.transport.request({method: "suix_getStakes", params: [input.owner]});
      }
      async getStakesByIds(input) {
        input.stakedSuiIds.forEach((id) => {
          if (!id || !(0, import_sui_types.isValidSuiObjectId)((0, import_sui_types.normalizeSuiObjectId)(id))) {
            throw new Error(`Invalid Sui Stake id ${id}`);
          }
        });
        return await this.transport.request({
          method: "suix_getStakesByIds",
          params: [input.stakedSuiIds]
        });
      }
      async getLatestSuiSystemState() {
        return await this.transport.request({method: "suix_getLatestSuiSystemState", params: []});
      }
      async queryEvents(input) {
        return await this.transport.request({
          method: "suix_queryEvents",
          params: [
            input.query,
            input.cursor,
            input.limit,
            (input.order || "descending") === "descending"
          ]
        });
      }
      async subscribeEvent(input) {
        return this.transport.subscribe({
          method: "suix_subscribeEvent",
          unsubscribe: "suix_unsubscribeEvent",
          params: [input.filter],
          onMessage: input.onMessage
        });
      }
      async subscribeTransaction(input) {
        return this.transport.subscribe({
          method: "suix_subscribeTransaction",
          unsubscribe: "suix_unsubscribeTransaction",
          params: [input.filter],
          onMessage: input.onMessage
        });
      }
      async devInspectTransactionBlock(input) {
        let devInspectTxBytes;
        if ((0, import_builder.isTransactionBlock)(input.transactionBlock)) {
          input.transactionBlock.setSenderIfNotSet(input.sender);
          devInspectTxBytes = (0, import_bcs.toB64)(await input.transactionBlock.build({
            client: this,
            onlyTransactionKind: true
          }));
        } else if (typeof input.transactionBlock === "string") {
          devInspectTxBytes = input.transactionBlock;
        } else if (input.transactionBlock instanceof Uint8Array) {
          devInspectTxBytes = (0, import_bcs.toB64)(input.transactionBlock);
        } else {
          throw new Error("Unknown transaction block format.");
        }
        return await this.transport.request({
          method: "sui_devInspectTransactionBlock",
          params: [input.sender, devInspectTxBytes, input.gasPrice, input.epoch]
        });
      }
      async dryRunTransactionBlock(input) {
        return await this.transport.request({
          method: "sui_dryRunTransactionBlock",
          params: [
            typeof input.transactionBlock === "string" ? input.transactionBlock : (0, import_bcs.toB64)(input.transactionBlock)
          ]
        });
      }
      async getDynamicFields(input) {
        if (!input.parentId || !(0, import_sui_types.isValidSuiObjectId)((0, import_sui_types.normalizeSuiObjectId)(input.parentId))) {
          throw new Error("Invalid Sui Object id");
        }
        return await this.transport.request({
          method: "suix_getDynamicFields",
          params: [input.parentId, input.cursor, input.limit]
        });
      }
      async getDynamicFieldObject(input) {
        return await this.transport.request({
          method: "suix_getDynamicFieldObject",
          params: [input.parentId, input.name]
        });
      }
      async getLatestCheckpointSequenceNumber() {
        const resp = await this.transport.request({
          method: "sui_getLatestCheckpointSequenceNumber",
          params: []
        });
        return String(resp);
      }
      async getCheckpoint(input) {
        return await this.transport.request({method: "sui_getCheckpoint", params: [input.id]});
      }
      async getCheckpoints(input) {
        return await this.transport.request({
          method: "sui_getCheckpoints",
          params: [input.cursor, input?.limit, input.descendingOrder]
        });
      }
      async getCommitteeInfo(input) {
        return await this.transport.request({
          method: "suix_getCommitteeInfo",
          params: [input?.epoch]
        });
      }
      async getNetworkMetrics() {
        return await this.transport.request({method: "suix_getNetworkMetrics", params: []});
      }
      async getAddressMetrics() {
        return await this.transport.request({method: "suix_getLatestAddressMetrics", params: []});
      }
      async getAllEpochAddressMetrics(input) {
        return await this.transport.request({
          method: "suix_getAllEpochAddressMetrics",
          params: [input?.descendingOrder]
        });
      }
      async getEpochs(input) {
        return await this.transport.request({
          method: "suix_getEpochs",
          params: [input?.cursor, input?.limit, input?.descendingOrder]
        });
      }
      async getMoveCallMetrics() {
        return await this.transport.request({method: "suix_getMoveCallMetrics", params: []});
      }
      async getCurrentEpoch() {
        return await this.transport.request({method: "suix_getCurrentEpoch", params: []});
      }
      async getValidatorsApy() {
        return await this.transport.request({method: "suix_getValidatorsApy", params: []});
      }
      async getChainIdentifier() {
        const checkpoint = await this.getCheckpoint({id: "0"});
        const bytes = (0, import_bcs.fromB58)(checkpoint.digest);
        return (0, import_bcs.toHEX)(bytes.slice(0, 4));
      }
      async resolveNameServiceAddress(input) {
        return await this.transport.request({
          method: "suix_resolveNameServiceAddress",
          params: [input.name]
        });
      }
      async resolveNameServiceNames(input) {
        return await this.transport.request({
          method: "suix_resolveNameServiceNames",
          params: [input.address, input.cursor, input.limit]
        });
      }
      async getProtocolConfig(input) {
        return await this.transport.request({
          method: "sui_getProtocolConfig",
          params: [input?.version]
        });
      }
      async waitForTransactionBlock({
        signal,
        timeout = 60 * 1e3,
        pollInterval = 2 * 1e3,
        ...input
      }) {
        const timeoutSignal = AbortSignal.timeout(timeout);
        const timeoutPromise = new Promise((_, reject) => {
          timeoutSignal.addEventListener("abort", () => reject(timeoutSignal.reason));
        });
        timeoutPromise.catch(() => {
        });
        while (!timeoutSignal.aborted) {
          signal?.throwIfAborted();
          try {
            return await this.getTransactionBlock(input);
          } catch (e) {
            await Promise.race([
              new Promise((resolve) => setTimeout(resolve, pollInterval)),
              timeoutPromise
            ]);
          }
        }
        timeoutSignal.throwIfAborted();
        throw new Error("Unexpected error while waiting for transaction block.");
      }
    };
  }
});

// node_modules/@mysten/sui.js/dist/cjs/client/index.js
var require_client2 = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/client/index.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __reExport2 = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var client_exports = {};
    __export2(client_exports, {
      RPCValidationError: () => import_errors.RPCValidationError
    });
    module2.exports = __toCommonJS(client_exports);
    var import_errors = require_errors();
    __reExport2(client_exports, require_http_transport(), module2.exports);
    __reExport2(client_exports, require_network(), module2.exports);
    __reExport2(client_exports, require_types2(), module2.exports);
    __reExport2(client_exports, require_client(), module2.exports);
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports, module2) {
    (function(globalObject) {
      "use strict";
      var BigNumber2, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber3.prototype = {constructor: BigNumber3, toString: null, valueOf: null}, ONE = new BigNumber3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber3(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber3))
            return new BigNumber3(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++)
                  ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v)))
                return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0)
                e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber3(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0)
                return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber3.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            else
              e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++)
            ;
          for (len = str.length; str.charCodeAt(--len) === 48; )
            ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber3.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0)
                i += LOG_BASE;
              if (i < len) {
                if (i)
                  x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0")
                ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber3.clone = clone;
        BigNumber3.ROUND_UP = 0;
        BigNumber3.ROUND_DOWN = 1;
        BigNumber3.ROUND_CEIL = 2;
        BigNumber3.ROUND_FLOOR = 3;
        BigNumber3.ROUND_HALF_UP = 4;
        BigNumber3.ROUND_HALF_DOWN = 5;
        BigNumber3.ROUND_HALF_EVEN = 6;
        BigNumber3.ROUND_HALF_CEIL = 7;
        BigNumber3.ROUND_HALF_FLOOR = 8;
        BigNumber3.EUCLID = 9;
        BigNumber3.config = BigNumber3.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object")
                  FORMAT = v;
                else
                  throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber3.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true)
            return false;
          if (!BigNumber3.DEBUG)
            return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out:
            if ({}.toString.call(c) == "[object Array]") {
              if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                if (c[0] === 0) {
                  if (e === 0 && c.length === 1)
                    return true;
                  break out;
                }
                i = (e + 1) % LOG_BASE;
                if (i < 1)
                  i += LOG_BASE;
                if (String(c[0]).length == i) {
                  for (i = 0; i < c.length; i++) {
                    n = c[i];
                    if (n < 0 || n >= BASE || n !== mathfloor(n))
                      break out;
                  }
                  if (n !== 0)
                    return true;
                }
              }
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
              return true;
            }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber3.maximum = BigNumber3.max = function() {
          return maxOrMin(arguments, P.lt);
        };
        BigNumber3.minimum = BigNumber3.min = function() {
          return maxOrMin(arguments, P.gt);
        };
        BigNumber3.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber3(ONE);
            if (dp == null)
              dp = DECIMAL_PLACES;
            else
              intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15)
                  c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--)
              ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
                ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                ;
              if (i < LOG_BASE)
                e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber3.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber3(args[0]);
          for (; i < args.length; )
            sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null)
                    arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber3(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop())
              ;
            if (!xc[0])
              return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; )
                ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry)
              x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1))
              ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber3(!x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
            }
            q = new BigNumber3(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++)
              ;
            if (yc[i] > (xc[i] || 0))
              e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2)
                yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base)
                      n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0])
                qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          if (!n.c)
            return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber3(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++)
                ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0)
                  for (str += "."; i--; str += "0")
                    ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len)
                    str += ".";
                  for (; i--; str += "0")
                    ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, method) {
          var n, i = 1, m = new BigNumber3(args[0]);
          for (; i < args.length; i++) {
            n = new BigNumber3(args[i]);
            if (!n.s) {
              m = n;
              break;
            } else if (method.call(m, n)) {
              m = n;
            }
          }
          return m;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop())
            ;
          for (j = c[0]; j >= 10; j /= 10, i++)
            ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s)
                  return new BigNumber3(s, base);
              }
              if (BigNumber3.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = n / pows10[d - j - 1] % 10 | 0;
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++)
                    ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                }
              }
              r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                      ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++)
                      ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE)
                      break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop())
                ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null)
            return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber3(this);
          if (x.s < 0)
            x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber3(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber3(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c))
            return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v])
            for (; v % 10 == 0; v /= 10, n--)
              ;
          if (n < 0)
            n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber3(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber3(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber3(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null)
            m = new BigNumber3(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber3(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s)
              return new BigNumber3(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp)
              x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1)
              k = 1 / k;
            return new BigNumber3(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber3(0.5);
            if (nIsNeg)
              n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber3(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c)
                break;
              if (k) {
                if (y.c.length > k)
                  y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0)
                  break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k)
                x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp)
            return y;
          if (nIsNeg)
            y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber3(this);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber3(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber3(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber3(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber3(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber3(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber3(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber3(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y.s = -b, y) : new BigNumber3(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber3(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0))
              ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0)
            for (; b--; xc[i++] = 0)
              ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b)
                ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye)
            ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber3(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber3(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber3(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1)
            y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber3(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0))
            ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber3(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber3(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber3(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber3(a / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new BigNumber3(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0))
              ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber3(x), sd, rm);
          }
          if (!(c = x.c))
            return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--)
              ;
            for (v = c[0]; v >= 10; v /= 10, n++)
              ;
          }
          if (sd && x.e + 1 > n)
            n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber3("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber3(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0)
              n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber3(n);
          } else {
            r = new BigNumber3(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3)
              s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e)
                  --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1)
                intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0)
                intPart += groupSeparator + intDigits.slice(i);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber3(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc)
            return new BigNumber3(x);
          d = new BigNumber3(ONE);
          n1 = d0 = new BigNumber3(ONE);
          d1 = n0 = new BigNumber3(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber3(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1)
              break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null)
            intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0)
                str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber3(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0])
              str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null)
          BigNumber3.set(configObject);
        return BigNumber3;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s)
            ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; )
          ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j)
          return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b)
          return a ? b ? 0 : -j : i;
        if (i != j)
          return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc)
          return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b)
          return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++)
          if (xc[i] != yc[i])
            return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z)
            ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z)
              ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber2 = clone();
      BigNumber2["default"] = BigNumber2.BigNumber = BigNumber2;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber2;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber2;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber2;
      }
    })(exports);
  }
});

// node_modules/@mysten/sui.js/dist/cjs/faucet/index.js
var require_faucet = __commonJS({
  "node_modules/@mysten/sui.js/dist/cjs/faucet/index.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, {get: all[name], enumerable: true});
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, {get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable});
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", {value: true}), mod);
    var faucet_exports = {};
    __export2(faucet_exports, {
      FaucetRateLimitError: () => FaucetRateLimitError,
      getFaucetHost: () => getFaucetHost2,
      getFaucetRequestStatus: () => getFaucetRequestStatus,
      requestSuiFromFaucetV0: () => requestSuiFromFaucetV02,
      requestSuiFromFaucetV1: () => requestSuiFromFaucetV1
    });
    module2.exports = __toCommonJS(faucet_exports);
    var FaucetRateLimitError = class extends Error {
    };
    async function faucetRequest(host, path, body, headers) {
      const endpoint = new URL(path, host).toString();
      const res = await fetch(endpoint, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          "Content-Type": "application/json",
          ...headers || {}
        }
      });
      if (res.status === 429) {
        throw new FaucetRateLimitError(`Too many requests from this client have been sent to the faucet. Please retry later`);
      }
      try {
        const parsed = await res.json();
        if (parsed.error) {
          throw new Error(`Faucet returns error: ${parsed.error}`);
        }
        return parsed;
      } catch (e) {
        throw new Error(`Encountered error when parsing response from faucet, error: ${e}, status ${res.status}, response ${res}`);
      }
    }
    async function requestSuiFromFaucetV02(input) {
      return faucetRequest(input.host, "/gas", {
        FixedAmountRequest: {
          recipient: input.recipient
        }
      }, input.headers);
    }
    async function requestSuiFromFaucetV1(input) {
      return faucetRequest(input.host, "/v1/gas", {
        FixedAmountRequest: {
          recipient: input.recipient
        }
      }, input.headers);
    }
    async function getFaucetRequestStatus(input) {
      return faucetRequest(input.host, "/v1/status", {
        task_id: {
          task_id: input.taskId
        }
      }, input.headers);
    }
    function getFaucetHost2(network) {
      switch (network) {
        case "testnet":
          return "https://faucet.testnet.sui.io";
        case "devnet":
          return "https://faucet.devnet.sui.io";
        case "localnet":
          return "http://127.0.0.1:9123";
        default:
          throw new Error(`Unknown network: ${network}`);
      }
    }
  }
});

// src/index.ts
__markAsModule(exports);
__export(exports, {
  Chain: () => Chain,
  DetachedEthosConnectProvider: () => DetachedEthosConnectProvider_default,
  EthosConnectProvider: () => EthosConnectProvider_default,
  EthosConnectStatus: () => EthosConnectStatus,
  SignInButton: () => SignInButton_default,
  TransactionBlock: () => import_transactions.TransactionBlock,
  ethos: () => ethos
});
var import_transactions = __toModule(require_export());

// src/components/EthosConnectProvider.tsx
var import_react26 = __toModule(require("react"));

// src/components/styled/SignInModal.tsx
var import_react21 = __toModule(require("react"));

// src/components/svg/Loader.tsx
var import_react = __toModule(require("react"));
var Loader = ({width = 100, color = "#333"}) => /* @__PURE__ */ import_react.default.createElement("svg", {
  version: "1.1",
  id: "L4",
  xmlns: "http://www.w3.org/2000/svg",
  x: "0px",
  y: "0px",
  viewBox: "0 0 54 20",
  width,
  height: width * (20 / 54),
  enableBackground: "new 0 0 0 0"
}, /* @__PURE__ */ import_react.default.createElement("circle", {
  fill: color,
  stroke: "none",
  cx: "6",
  cy: "10",
  r: "6"
}, /* @__PURE__ */ import_react.default.createElement("animate", {
  attributeName: "opacity",
  dur: "1.5s",
  values: "0;1;0",
  repeatCount: "indefinite",
  begin: "0.1"
})), /* @__PURE__ */ import_react.default.createElement("circle", {
  fill: color,
  stroke: "none",
  cx: "26",
  cy: "10",
  r: "6"
}, /* @__PURE__ */ import_react.default.createElement("animate", {
  attributeName: "opacity",
  dur: "1.5s",
  values: "0;1;0",
  repeatCount: "indefinite",
  begin: "0.5"
})), /* @__PURE__ */ import_react.default.createElement("circle", {
  fill: color,
  stroke: "none",
  cx: "46",
  cy: "10",
  r: "6"
}, /* @__PURE__ */ import_react.default.createElement("animate", {
  attributeName: "opacity",
  dur: "1.5s",
  values: "0;1;0",
  repeatCount: "indefinite",
  begin: "1.0"
})));
var Loader_default = Loader;

// src/components/svg/WalletsIcon.tsx
var import_react2 = __toModule(require("react"));
var WalletsIcon = ({width = 32}) => /* @__PURE__ */ import_react2.default.createElement("img", {
  src: dataUri,
  width,
  height: width
});
var WalletsIcon_default = WalletsIcon;
var dataUri = `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAeGVYSWZNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQAAAAEAAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAAEgAAAABAAAASAAAAAEAAqACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAAAQdIdCAAAACXBIWXMAAAsTAAALEwEAmpwYAAACZmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjU2PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjU2PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiB3yYcAAAgwSURBVFgJrZddiJ1HGcefmXfe9z3n7G42yTYamy9sklZT0XilAeuFdwXxQrD4gVKwF6IXohdS8CYXJWJFwQvprXhTaOhVFakFjbGWioqItKYXprVda0OaNNnd8/F+jr//nN1k16RCwLM778w8M2f+//k/zzzzHme3+Zw+/Zuw+94TK7mvDucxHCws3h2ie19u9p68d3vy3kaFuYG3diH4We/9dJaF2SzLKG58xWfTyz4b/zvPJqsun6zW9eS1j2785ap76Gz333Buu+H0M2+OwrQ5Wzj/YBbNhWiWR2eAG+CxiJ6+WeijK5KNMWssy6YGCdWR4pwbWwgTbGNsam9QxtH5jSfqS6vfuv+hs/UW7g0C33l69WARu38GMx/Mxaw3l5uAXQypPScjQihgxSY51cE3mwQmAApY9Rx8Xs8JZNm6y/z6uCjHRw5+7GdXRMLr8bmnYtZZe6Hx0TdQalUYaVy02qKTjfpGUb/xLjbeotpdn1uMZey60vp+sFlKm/dxYJRddR77mC+0bfZyjKcTNhs221e89khjbhTZTc+DDbrAwmgWIx0sUMGgj6MbkQE3yOY8hTnWFy74HlB1OnOuTaXvW8BZ3eUOEtE5EQn73njxwleY+FMRcJ23M1BL6wQWjJDQ4n3sXX+TiAMSQoBDTNj84SAm43XYQqSkyZS+x9IB1lJvEaghUtOvWB8Sff6DRODrT720UFm717uMfTrWnxPp5VuBg8KSLnrUoEMcYmQO+8eDPMRHIokWoduVLkge1yXwmwTkkgqCBTVh7sPKhec/sxTqpeye2MKSBWPEsS5jB2wGcJFgYzBXu8MGCW1Wam0S2VJLdqbyBUK4G9CUC+SKDkAFacPUGn2IpjgDo3QL+cL7Q9O3xwnF6NmlAc6IdgtgFg/sLu3LJ1fcgeVCS+uTMObN2z53jM/GtV144YJV641IMFZBpKZdooACM9wXWl8fz5JgWfSA9z7AFAlQ5Esn73YXrkztr29xtFAjFThkYCM2tUs29jzvy0ZRX8d3tOjcoRNH7JUX1llPKtSclArwASoUwJTHyTHN0R4JCDnAgQDcm1c02PdffD1WtUAUIT7mSB9UEwvzXOBSPiixFXBWTijx2QAxKW5A0AyH5Jx+gd12gDeAb5EYupDNjobeNUcURYouoOZuYEGcZSujwj1y6qAd2lVK7y15t+rtPridzaYbnf3t3FWbrin4dCIatK6oZxAiX8TyMATa/TEpAAGCjJ0TTiLU2Vc/csxevrJmf740D3+FmcY0C0QiZu4WuUJp+0ZNWxlz12Kwwx9espfP1wQmIU1K0zH0viJTzmLXTvZLgZUEmBbPmCAAojLL4mN//LubNQJnaSnU4wg8zHFjVsAluAIg+bsg4AesgQtSe8isAbbdRWBmsEG3IAWso2RZzcGb4o7RXaHz7aLETwBKe0CwbgJZGZX2tQ/da0eWRtvltrcnjT3661f5SmYd5Fpi49EHD9reUUqsW+5wG+PWfnv+HZtWMCFdu3YXB4yk39aAJwUW2G49FKuOC2WzxN63Ue1vn/zALeBictcot6JouTMq7oTaFtnCJvgOoosLwT5+atnGxPaEUsXSte0ujuEuFFgiNS+XvnUtV3zDGaAA2rua01CTnmvbNxzsWHB75wv3v9f2LMRE5NP3LW8f2tFe2V0kAmOO9QTPVt3QmmY5EWm7xSKwW6U7PImL0pNZ8rfy/c3I37GoOg8cWEnlloHbGDa0lBJLRzzpr1s03yovVBbKjszEaJ/h+5TUcS2HheeWL2+z5J2Z1nRLEictSyrLKF35djdx0MQwaGrdXSRBT4Q6FXI+9wH1ncG8++w13VESgA2S7ri5kKHjZNV72jDqmoqoJxB1oyYCUoIY+N8ueHe4W0fGWU3A5rzgoIRncyDo7vTdoAnDtpr20Q+VfuZF11Jq/98UaMIYF5Sx4RqucUUdUJvXUw79LAyb9hqS7NXZl9vlfmKCE+Hj6vXL7uDyvlu3dAeWy7OpVdm6Zb7idJXWdgOrRQYNeO275kdVdWnU1kaJo7oylYWmjov1zD39p1/atcnaHcDtnHpx4x0789IfrM7XrQprbPe6zYprcZJfd1fyqb0Z2kth2NcX0fyUAkMxoIPCoZASce3tVffjZ35CctTdKGWQDWWSSvhQth7VFFyKGQq+9lw7ngSVWRMCL668H2WB3Sqd58R/4ZqsjDnvBE278I8wqGbnvPdf1GKQSGBC2GzLTyI1J5cIklXlrnRSAYXuZuyk+gYZEfEqEMnmZQaZJuSxznJXe37a+Py5EKb1s2WZ6fbV4dAjPclJMuEphkDTmKaIkKZIKeWt+Ty1PQTS24RebrFLFdRhXg8JyEglq7MM8GD8lLK1xp8XsHvyiW+us+ZIgHMeetObExGHBK7BTRLCTqQSmTkx2cQwqYUdYonknKyIY9h0JW7D6378jYfP7ArazJM/XPvgMC9f1wJbsFpbfX2SCKigQyLkZEqDEkZC6V/jtJMkvGGk9uZyvNUq/2HizYpET32tqk5gSotRm/388YcfKDN/PnW0fxoq+iCiFhbXTTt1wo2WycjZVl9trjjJqJd8ARF0OANb1ne8pDCgV+wufvKe7/3id/O1E8T88exjnz+0lGWvADwUqAIg1VKG72q3XFWprcX17qzzke4aEjpgAqSvObKnLwlUDX1/YzKLJ4796FdvbMFubXKrr9r9/rufPTwo4icG0T5F/yjy7WeHe1iIG94VLM7VlX6qCEgy8g9i1M9FXvzMJkhyFa5vMXiRS/D5qqueO/b4uX9p4naw/wDv1ZplvOGRpgAAAABJRU5ErkJggg==`;

// src/enums/Breakpoints.ts
var Breakpoints;
(function(Breakpoints2) {
  Breakpoints2[Breakpoints2["sm"] = 640] = "sm";
  Breakpoints2[Breakpoints2["md"] = 768] = "md";
  Breakpoints2[Breakpoints2["lg"] = 1024] = "lg";
  Breakpoints2[Breakpoints2["xl"] = 1280] = "xl";
  Breakpoints2[Breakpoints2["2xl"] = 1536] = "2xl";
})(Breakpoints || (Breakpoints = {}));

// src/components/styled/signInModalStyles.ts
var COLOR_LIGHT_TEXT_MEDIUM = "#74777C";
var ethosWalletTitleText = () => ({
  fontSize: "18px",
  lineHeight: "24px",
  fontWeight: "600",
  marginLeft: "10px"
});
var secondaryText = () => ({
  color: "#6B7280",
  fontSize: "0.875rem",
  lineHeight: "1.25rem",
  padding: "24px",
  display: "flex",
  flexDirection: "column",
  gap: "12px"
});
var dialog = (isOpen) => ({
  visibility: isOpen ? "" : "hidden",
  position: "relative",
  zIndex: "100"
});
var backdrop = (isOpen) => ({
  position: "fixed",
  top: "0px",
  right: "0px",
  bottom: "0px",
  left: "0px",
  backgroundColor: "rgb(107 114 128)",
  opacity: isOpen ? ".75" : "0",
  transition: "all 300ms ease-in-out"
});
var highlighted = () => ({
  color: "#6D28D9"
});
var modalOuterWrapper = (isOpen) => ({
  position: "fixed",
  zIndex: "99",
  top: "0px",
  right: "0px",
  bottom: "0px",
  left: "0px",
  overflowY: "auto",
  opacity: isOpen ? "1" : "0",
  scale: isOpen ? "1" : ".95",
  transition: "all 300ms ease-in-out"
});
var modalInnerWrapper = (width) => {
  const styles12 = {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    minHeight: "100%",
    padding: "1rem",
    textAlign: "center"
  };
  const sm = {
    padding: "0",
    alignItems: "center"
  };
  return width < Breakpoints.sm ? styles12 : {...styles12, ...sm};
};
var dialogPanel = (width) => {
  const styles12 = {
    overflow: "hidden",
    position: "relative",
    backgroundColor: "#ffffff",
    transitionProperty: "all",
    borderRadius: "0.5rem",
    boxShadow: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)"
  };
  const sm = {
    width: "360px"
  };
  return width < Breakpoints.sm ? styles12 : {...styles12, ...sm};
};
var topPanelStyle = () => ({
  padding: "24px 24px 0px",
  display: "flex",
  flexDirection: "row",
  justifyContent: "space-between",
  alignItems: "center"
});
var closeStyle = () => ({
  width: "24px",
  height: "24px",
  color: "#A0AEBA",
  cursor: "pointer"
});
var backStyle = () => ({
  color: COLOR_LIGHT_TEXT_MEDIUM,
  cursor: "pointer",
  display: "flex",
  gap: "6px",
  alignItems: "center"
});
var backStyleText = () => ({
  fontSize: "16px",
  lineHeight: "24px"
});
var headerStyle = (withIcon = false) => ({
  padding: withIcon ? "24px 24px 32px" : "0 24px 32px",
  display: "flex",
  flexDirection: "column",
  justifyContent: "center",
  gap: "12px"
});
var headerLogosStyle = () => ({
  display: "flex",
  justifyContent: "center",
  gap: "-6px"
});
var titleStyle = () => ({
  fontSize: "24px",
  fontWeight: "600",
  lineHeight: "32px",
  margin: "0"
});
var subTitleStyle = () => ({
  fontSize: "16px",
  fontWeight: "400",
  lineHeight: "24px",
  margin: "0",
  color: COLOR_LIGHT_TEXT_MEDIUM
});
var strikeThroughOrContainer = () => ({
  padding: "0px 24px 24px",
  display: "flex",
  flexDirection: "row",
  gap: "12px",
  justifyContent: "space-between",
  alignItems: "center",
  color: COLOR_LIGHT_TEXT_MEDIUM
});
var line = () => ({
  height: "1px",
  width: "100%",
  background: "rgba(0, 0, 0, 0.12)",
  borderRadius: "16px"
});
var emailInput = () => ({
  boxSizing: "border-box",
  border: "1px solid rgba(0, 0, 0, 0.08)",
  borderRadius: "16px",
  background: "#F2F2F2",
  padding: "20px",
  width: "100%"
});
var walletOptionContainer = (width) => {
  const styles12 = {
    padding: "0px 24px 24px",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    gap: "12px"
  };
  const sm = {};
  return width < Breakpoints.sm ? styles12 : {...styles12, ...sm};
};
var iconButton = (width, disabled = false, primary2 = false, noIcon = false) => {
  const styles12 = {
    textDecoration: "none",
    fontWeight: primary2 ? "500" : "400",
    boxSizing: "border-box",
    display: "flex",
    flexDirection: "row",
    gap: "12px",
    justifyContent: noIcon ? "center" : "space-between",
    alignItems: "center",
    padding: primary2 ? "20px 20px" : "16px 16px 16px 20px",
    width: "100%",
    background: primary2 ? "#6D28D9" : "#F2F2F2",
    color: primary2 ? "white" : "black",
    opacity: disabled ? 0.5 : 1,
    cursor: disabled ? "not-allowed" : "pointer",
    borderRadius: "16px",
    flex: "none",
    order: "0",
    flexGrow: "0",
    boxShadow: "0px 1px 2px rgba(0, 0, 0, 0.05)",
    border: "none",
    fontSize: "inherit"
  };
  const sm = {};
  return width < Breakpoints.sm ? styles12 : {...styles12, ...sm};
};
var submitButtonContainer = () => ({
  padding: "0px 24px 24px"
});
var loaderStyle = () => ({
  display: "flex",
  justifyContent: "center",
  padding: "45px 0"
});
var walletExplanation = () => ({
  padding: "6px 0",
  color: "#666",
  width: "100%",
  fontSize: "smaller",
  marginBottom: "12px"
});

// src/lib/useHandleElementWithIdClicked.ts
var import_react3 = __toModule(require("react"));
function useHandleElementWithIdClicked(clickId, onClickOutside) {
  (0, import_react3.useEffect)(() => {
    function handleClickOutside(event2) {
      if (event2.target.id === clickId) {
        onClickOutside();
      }
    }
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);
}

// src/components/styled/EmailSent.tsx
var import_react7 = __toModule(require("react"));

// src/components/svg/Ethos.tsx
var import_react4 = __toModule(require("react"));
var Ethos = ({width = 24, color = "#1e293b"}) => /* @__PURE__ */ import_react4.default.createElement("svg", {
  width,
  height: width * 65 / 47,
  viewBox: "0 0 47 65",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, /* @__PURE__ */ import_react4.default.createElement("path", {
  d: "M6.00471 1H40.0029C42.7644 1 45.0029 3.23858 45.0029 6V44.8425C45.0029 47.604 42.7643 49.8425 40.0029 49.8425H6.0047C3.24328 49.8425 1.0047 47.604 1.0047 44.8425V6C1.0047 3.23858 3.24329 1 6.00471 1Z",
  stroke: color,
  strokeWidth: "2"
}), /* @__PURE__ */ import_react4.default.createElement("path", {
  d: "M6.68764 3.64648L30.6631 14.8026C32.0736 15.4589 32.9756 16.8735 32.9756 18.4292V58.6799C32.9756 61.5743 29.9966 63.5105 27.3515 62.3353L3.37601 51.683C1.93126 51.0411 1.00013 49.6085 1.00013 48.0276V7.27309C1.00013 4.34854 4.03609 2.41268 6.68764 3.64648Z",
  fill: color
}));
var Ethos_default = Ethos;

// src/components/styled/Header.tsx
var import_react5 = __toModule(require("react"));
var Header = ({title, subTitle, dappIcon, showEthos = false, children}) => {
  return /* @__PURE__ */ import_react5.default.createElement("div", null, /* @__PURE__ */ import_react5.default.createElement("div", {
    style: headerStyle(!!dappIcon)
  }, /* @__PURE__ */ import_react5.default.createElement("div", {
    style: headerLogosStyle()
  }, dappIcon && (typeof dappIcon === "string" ? /* @__PURE__ */ import_react5.default.createElement("img", {
    src: dappIcon
  }) : dappIcon), showEthos && /* @__PURE__ */ import_react5.default.createElement(Ethos_default, null)), title && /* @__PURE__ */ import_react5.default.createElement("div", {
    style: titleStyle()
  }, title), subTitle && /* @__PURE__ */ import_react5.default.createElement("div", {
    style: subTitleStyle()
  }, subTitle)), children);
};
var Header_default = Header;

// src/components/svg/EthosWalletIcon.tsx
var import_react6 = __toModule(require("react"));
var EthosWalletIcon = ({width = 52}) => {
  return /* @__PURE__ */ import_react6.default.createElement("svg", {
    width,
    height: width * (64 / 52),
    viewBox: "0 0 52 64",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ import_react6.default.createElement("path", {
    d: "M4.27959 12.0559H33.346C35.7069 12.0559 37.6206 13.9982 37.6206 16.3941V50.095C37.6206 52.4909 35.7068 54.4331 33.346 54.4331H4.27958C1.91873 54.4331 0.00488281 52.4909 0.00488281 50.095V16.3941C0.00488281 13.9982 1.91874 12.0559 4.27959 12.0559Z",
    fill: "#D7B8FF"
  }), /* @__PURE__ */ import_react6.default.createElement("path", {
    d: "M4.86247 12.384L25.36 22.0634C26.5659 22.6328 27.3371 23.8602 27.3371 25.2099V60.1327C27.3371 62.6439 24.7902 64.3238 22.5288 63.3042L2.03123 54.0619C0.796059 53.505 0 52.262 0 50.8904V15.5306C0 12.9931 2.59556 11.3135 4.86247 12.384Z",
    fill: "#9A42FF"
  }), /* @__PURE__ */ import_react6.default.createElement("path", {
    d: "M43.9695 -0.000244141L44.3975 1.15648C45.4058 3.88145 47.5543 6.02993 50.2793 7.03826L51.436 7.46629L50.2793 7.89431C47.5543 8.90265 45.4058 11.0511 44.3975 13.7761L43.9695 14.9328L43.5414 13.7761C42.5331 11.0511 40.3846 8.90265 37.6596 7.89431L36.5029 7.46629L37.6597 7.03826C40.3846 6.02993 42.5331 3.88145 43.5414 1.15648L43.9695 -0.000244141Z",
    fill: "#9A42FF"
  }));
};
var EthosWalletIcon_default = EthosWalletIcon;

// src/components/styled/EmailSent.tsx
var EmailSent = () => {
  return /* @__PURE__ */ import_react7.default.createElement(Header_default, {
    title: "Ethos sent you an email",
    dappIcon: /* @__PURE__ */ import_react7.default.createElement(EthosWalletIcon_default, null)
  }, /* @__PURE__ */ import_react7.default.createElement("div", {
    style: secondaryText()
  }, /* @__PURE__ */ import_react7.default.createElement("p", {
    style: {whiteSpace: "nowrap"}
  }, "An email has been sent to you with a link to login."), /* @__PURE__ */ import_react7.default.createElement("p", null, "If you don't receive it, please check your spam folder or contact us at:"), /* @__PURE__ */ import_react7.default.createElement("p", null, "support@ethoswallet.xyz")));
};
var EmailSent_default = EmailSent;

// src/components/styled/Wallets.tsx
var import_react9 = __toModule(require("react"));

// src/components/styled/IconButton.tsx
var import_react8 = __toModule(require("react"));
var IconButton = (props) => {
  const {text, icon, width, disabled, primary: primary2, type, ...reactProps} = props;
  return /* @__PURE__ */ import_react8.default.createElement("button", {
    style: iconButton(width, disabled, primary2, !icon),
    ...reactProps,
    type
  }, /* @__PURE__ */ import_react8.default.createElement("div", null, text), icon);
};
var IconButton_default = IconButton;

// src/components/styled/Wallets.tsx
var Wallets = ({wallets: wallets2, selectWallet, width}) => {
  const _connectExtension = (0, import_react9.useCallback)((e) => {
    if (!selectWallet)
      return;
    let element = e.target;
    let name;
    while (!name && element.parentNode) {
      name = element.dataset.name;
      element = element.parentNode;
    }
    selectWallet(name);
  }, []);
  const icon = (0, import_react9.useCallback)((wallet) => {
    return /* @__PURE__ */ import_react9.default.createElement("img", {
      src: wallet.icon,
      height: 32,
      width: 32
    });
  }, []);
  return /* @__PURE__ */ import_react9.default.createElement("div", {
    role: "wallet-sign-in"
  }, /* @__PURE__ */ import_react9.default.createElement("div", {
    style: walletOptionContainer(width)
  }, wallets2?.map((wallet, index) => /* @__PURE__ */ import_react9.default.createElement(IconButton_default, {
    key: `select-wallet-${index}`,
    icon: icon(wallet),
    "data-name": wallet.name,
    text: wallet.name,
    onClick: _connectExtension,
    width
  }))));
};
var Wallets_default = Wallets;

// src/components/styled/Email.tsx
var import_react10 = __toModule(require("react"));

// src/lib/getConfiguration.ts
var import_store2 = __toModule(require_store2());
var getConfiguration = () => {
  const ethosStore = import_store2.default.namespace("ethos");
  const configuration = ethosStore("configuration");
  return configuration || {};
};
var getConfiguration_default = getConfiguration;

// src/lib/postIFrameMessage.ts
var import_store24 = __toModule(require_store2());

// src/lib/getIframe.ts
var import_store23 = __toModule(require_store2());

// src/lib/log.ts
var import_store22 = __toModule(require_store2());
var allowLog = (label) => {
  const logStore = import_store22.default.namespace("log");
  const allowed = logStore("allowed") || [];
  if (allowed.includes(label))
    return;
  logStore("allowed", [...allowed, label]);
  return `Logging enabled for ${label}. Call ethos.clearAllowLog() to turn off this logging.`;
};
var clearAllowLog = () => {
  const logStore = import_store22.default.namespace("log");
  logStore("allowed", []);
};
var log = (label, ...message) => {
  const logStore = import_store22.default.namespace("log");
  const allowed = logStore("allowed");
  if (!allowed || !(allowed.includes(label) || allowed.includes("all"))) {
    return;
  }
  console.log(label, ...message);
};
if (typeof window !== "undefined") {
  ;
  window.ethos = {
    allowLog,
    clearAllowLog
  };
}
var log_default = log;

// src/lib/getIframe.ts
var getIframe = (show) => {
  const {apiKey, walletAppUrl, network} = getConfiguration_default();
  log_default("getIframe", "getIframe", apiKey, walletAppUrl);
  if (!apiKey || !walletAppUrl)
    return;
  const iframeId = "ethos-wallet-iframe";
  let scrollY = 0;
  let iframe = document.getElementById(iframeId);
  const close = () => {
    if (!iframe)
      return;
    iframe.style.width = "1px";
    iframe.style.height = "1px";
  };
  const queryParams = new URLSearchParams(window.location.search);
  const accessToken = queryParams.get("access_token");
  const refreshToken = queryParams.get("refresh_token");
  let fullWalletAppUrl = walletAppUrl + `/wallet?apiKey=${apiKey}&network=${network}`;
  if (accessToken && refreshToken) {
    fullWalletAppUrl += `&access_token=${accessToken}&refresh_token=${refreshToken}`;
    queryParams.delete("access_token");
    queryParams.delete("refresh_token");
    let fullPath = location.protocol + "//" + location.host + location.pathname;
    if (queryParams.toString().length > 0) {
      fullPath += "?" + queryParams.toString();
    }
    import_store23.default.namespace("auth")("access_token", accessToken);
    import_store23.default.namespace("auth")("refresh_token", refreshToken);
    window.history.pushState({}, "", fullPath);
  } else {
    const accessToken2 = import_store23.default.namespace("auth")("access_token");
    const refreshToken2 = import_store23.default.namespace("auth")("refresh_token");
    if (accessToken2 && refreshToken2) {
      fullWalletAppUrl += `&access_token=${accessToken2}&refresh_token=${refreshToken2}`;
    }
  }
  if (!iframe) {
    log_default("getIframe", "Load Iframe", fullWalletAppUrl);
    iframe = document.createElement("IFRAME");
    iframe.src = fullWalletAppUrl;
    iframe.id = iframeId;
    iframe.style.border = "none";
    iframe.style.position = "absolute";
    iframe.style.top = scrollY - 1 + "px";
    iframe.style.right = "60px";
    iframe.style.width = "1px";
    iframe.style.height = "1px";
    iframe.style.zIndex = "99";
    iframe.style.backgroundColor = "transparent";
    iframe.setAttribute("allow", "payment; clipboard-read; clipboard-write");
    document.body.appendChild(iframe);
    window.addEventListener("message", (message) => {
      if (message.origin === walletAppUrl) {
        const {action, data} = message.data;
        switch (action) {
          case "close":
            close();
            break;
          case "resize":
            if ((data.width ?? 0) > 1 && (data.height ?? 0) > 1) {
              iframe.style.width = data.width + "px";
              iframe.style.height = data.height + "px";
            }
            break;
          case "ready":
            iframe.setAttribute("readyToReceiveMessages", "true");
            const messageStore = import_store23.default.namespace("iframeMessages");
            const messages = messageStore("messages") || [];
            for (const message2 of messages) {
              postIFrameMessage_default(message2);
            }
            messageStore("messages", null);
            break;
        }
      }
    });
    window.addEventListener("scroll", () => {
      scrollY = window.scrollY;
      iframe.style.top = scrollY + "px";
    });
  } else if (iframe.src !== fullWalletAppUrl) {
    iframe.src = fullWalletAppUrl;
  }
  if (show) {
    iframe.style.width = "360px";
    iframe.style.height = "600px";
  } else if (show !== void 0) {
    close();
  }
  return iframe;
};
var getIframe_default = getIframe;

// src/lib/postIFrameMessage.ts
var postIFrameMessage = (message) => {
  const iframe = getIframe_default();
  if (!iframe?.getAttribute("readyToReceiveMessages")) {
    const messageStore = import_store24.default.namespace("iframeMessages");
    const existingMessages = messageStore("messages") || [];
    const result = messageStore("messages", [...existingMessages, message]);
    log_default("iframe", "Storing iframe message", result);
    return;
  }
  iframe?.contentWindow?.postMessage(message, "*");
};
var postIFrameMessage_default = postIFrameMessage;

// src/lib/event.ts
var event = async (eventProps) => {
  postIFrameMessage_default({
    action: "event",
    data: eventProps
  });
};
var event_default = event;

// src/lib/login.ts
var import_store29 = __toModule(require_store2());

// src/lib/getWalletContents.ts
var import_utils = __toModule(require_utils3());
var import_client = __toModule(require_client2());

// src/lib/bigNumber.ts
var import_bignumber = __toModule(require_bignumber());
var newBN = (value) => new import_bignumber.default(value);
var sumBN = (balance, addition) => {
  let bn = new import_bignumber.default(balance.toString());
  let bnAddition = new import_bignumber.default(addition.toString());
  return bn.plus(bnAddition);
};
var formatBalance = (balance, decimals = 9) => {
  if (balance === void 0)
    return "---";
  let postfix = "";
  let bn = new import_bignumber.default(balance.toString()).shiftedBy(-1 * decimals);
  if (bn.gte(1e9)) {
    bn = bn.shiftedBy(-9);
    postfix = " B";
  } else if (bn.gte(1e6)) {
    bn = bn.shiftedBy(-6);
    postfix = " M";
  } else if (bn.gte(1e4)) {
    bn = bn.shiftedBy(-3);
    postfix = " K";
  }
  if (bn.gte(1)) {
    bn = bn.decimalPlaces(3, import_bignumber.default.ROUND_DOWN);
  } else {
    bn = bn.decimalPlaces(6, import_bignumber.default.ROUND_DOWN);
  }
  return bn.toFormat() + postfix;
};

// src/enums/Chain.ts
var Chain;
(function(Chain2) {
  Chain2["SUI_MAINNET"] = "sui:mainnet";
  Chain2["SUI_TESTNET"] = "sui:testnet";
  Chain2["SUI_DEVNET"] = "sui:devnet";
  Chain2["SUI_CUSTOM"] = "sui:custom";
})(Chain || (Chain = {}));

// src/lib/constants.ts
var primaryColor = "#6f53e4";
var appBaseUrl = typeof window !== "undefined" && window.location.origin.indexOf("http://localhost") === 0 ? "http://localhost:3000" : "https://ethoswallet.onrender.com";
var DEFAULT_NETWORK = "https://fullnode.testnet.sui.io/";
var DEFAULT_CHAIN = Chain.SUI_TESTNET;

// src/lib/getDisplay.ts
var getDisplay = (display) => {
  if (!display)
    return null;
  if ("data" in display && display.data && typeof display.data === "object") {
    return display.data;
  }
  return display;
};
var getDisplay_default = getDisplay;

// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty3.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty4.call(data, key);
}
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var arrayMap_default = arrayMap;

// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;

// node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
var INFINITY2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey_default(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_default = get;

// src/lib/getKioskNFT.ts
var isKiosk = (data) => {
  return !!data.type && data.type.includes("kiosk") && !!data.content && "fields" in data.content && ("kiosk" in data.content.fields || "for" in data.content.fields);
};
var getKioskObjects = async (client, data) => {
  if (!isKiosk(data))
    return [];
  let kiosk = get_default(data, "content.fields.kiosk");
  if (!kiosk)
    kiosk = get_default(data, "content.fields.for");
  if (!kiosk)
    return [];
  let allKioskObjects = [];
  let cursor;
  while (cursor !== null) {
    const response = await client.getDynamicFields({
      parentId: kiosk,
      cursor
    });
    if (!response.data)
      return [];
    allKioskObjects = [...allKioskObjects || [], ...response.data];
    if (response.hasNextPage && response.nextCursor !== cursor) {
      cursor = response.nextCursor;
    } else {
      cursor = null;
    }
  }
  const relevantKioskObjects = allKioskObjects.filter((kioskObject) => kioskObject.name.type === "0x0000000000000000000000000000000000000000000000000000000000000002::kiosk::Item" || kioskObject.name.type === "0x2::kiosk::Item");
  const objectIds = relevantKioskObjects.map((item) => item.objectId);
  let objects = [];
  const groupSize = 30;
  for (let i = 0; i < objectIds.length; i += groupSize) {
    const group = objectIds.slice(i, i + groupSize);
    const groupObjects = await client.multiGetObjects({
      ids: group,
      options: {
        showContent: true,
        showType: true,
        showDisplay: true,
        showOwner: true
      }
    });
    objects = [...objects, ...groupObjects];
  }
  return objects;
};

// src/lib/getWalletContents.ts
var import_store25 = __toModule(require_store2());
var ipfsConversion = (src) => {
  if (!src)
    return "";
  if (src.indexOf("ipfs") === 0) {
    return src.replace(/^ipfs:\/\//, "https://ipfs.io/ipfs/");
  }
  return src;
};
var empty = {
  suiBalance: newBN(0),
  balances: {},
  nfts: [],
  tokens: {},
  objects: []
};
var getWalletContents = async ({address: address2, network, existingContents, invalidPackageModifications}) => {
  try {
    const client = new import_client.SuiClient({
      url: network || DEFAULT_NETWORK
    });
    if (!address2) {
      return empty;
    }
    let invalidPackages = [];
    try {
      invalidPackages = import_store25.default.get("invalidPackages") ?? [];
      const invalidPackagesResponse = await fetch("https://raw.githubusercontent.com/EthosWallet/valid_packages/main/public/invalid_tokens.json");
      invalidPackages = await invalidPackagesResponse.json();
      import_store25.default.set("invalidPackages", invalidPackages);
      if (invalidPackageModifications?.invalidPackageAdditions) {
        invalidPackages = invalidPackages.concat(invalidPackageModifications.invalidPackageAdditions);
      }
      if (invalidPackageModifications?.invalidPackageSubtractions) {
        invalidPackages = invalidPackages.filter((packageId) => !invalidPackageModifications.invalidPackageSubtractions.includes(packageId));
      }
    } catch (e) {
      console.error(e);
    }
    const coinBalances = await client.getAllBalances({owner: address2});
    const validCoinBalances = coinBalances.filter((coinBalance) => !invalidPackages.includes(coinBalance.coinType.split("::")[0]));
    let objectInfos = [];
    let nextCursor = void 0;
    let limitedNextCursor = void 0;
    let page = 0;
    let hasNextPage = false;
    while (limitedNextCursor !== null) {
      page += 1;
      const pageObjectInfos = await client.getOwnedObjects({
        owner: address2,
        options: {
          showType: true,
          showOwner: true,
          showContent: true,
          showDisplay: true
        },
        cursor: limitedNextCursor
      });
      objectInfos = [
        ...objectInfos,
        ...pageObjectInfos.data
      ];
      hasNextPage = pageObjectInfos.hasNextPage;
      if (page > 20) {
        limitedNextCursor = null;
      } else {
        if (hasNextPage && nextCursor !== pageObjectInfos.nextCursor) {
          limitedNextCursor = pageObjectInfos.nextCursor ?? null;
        } else {
          limitedNextCursor = null;
        }
      }
    }
    if (objectInfos.length === 0) {
      if (existingContents === empty) {
        return null;
      }
      return empty;
    }
    const allObjectDatas = objectInfos.map((objectInfo) => objectInfo.data);
    for (const data of allObjectDatas) {
      if (!data)
        continue;
      if (isKiosk(data)) {
        const kioskObjects = await getKioskObjects(client, data);
        for (const kioskObject of kioskObjects) {
          if (kioskObject.data) {
            allObjectDatas.push({
              ...kioskObject.data,
              kiosk: data
            });
          }
        }
      }
    }
    const currentObjects = [];
    let newObjectInfos = [];
    if (existingContents?.objects && existingContents.objects.length > 0) {
      for (const data of allObjectDatas) {
        if (!data)
          continue;
        const existingObject = existingContents?.objects.find((existingObject2) => {
          if (typeof data === "object") {
            return existingObject2.objectId === data.objectId && existingObject2.version.toString() === data.version.toString();
          } else {
            return false;
          }
        });
        if (existingObject) {
          currentObjects.push(existingObject);
        } else {
          newObjectInfos.push(data);
        }
      }
    } else {
      newObjectInfos = allObjectDatas.filter((data) => !!data);
    }
    if (newObjectInfos.length === 0)
      return null;
    const newObjects = newObjectInfos;
    const objects = currentObjects.concat(newObjects);
    let suiBalance = newBN(0);
    const balances = validCoinBalances.reduce((acc, coinBalance) => {
      acc[coinBalance.coinType] = coinBalance;
      if (coinBalance.coinType === import_utils.SUI_TYPE_ARG) {
        suiBalance = newBN(coinBalance.totalBalance);
      }
      return acc;
    }, {});
    const nfts = [];
    const tokens = {};
    const convenenienceObjects = [];
    for (const data of objects) {
      const {display, content} = data;
      const {fields: f} = content?.dataType === "moveObject" ? content : {fields: {}};
      const fields = f;
      const safeDisplay = getDisplay_default(display);
      try {
        const typeStringComponents = (data.type || "").split("<");
        const subtype = (typeStringComponents[1] || "").replace(/>/, "");
        const typeComponents = typeStringComponents[0].split("::");
        const packageObjectId = typeComponents[0];
        const moduleName = typeComponents[1];
        const structName = typeComponents[typeComponents.length - 1];
        if (invalidPackages.includes(packageObjectId))
          continue;
        const safeUrl = ipfsConversion(safeDisplay?.image_url ?? safeDisplay?.img_url ?? safeDisplay?.url ?? fields?.url ?? fields?.image_url ?? fields?.img_url);
        convenenienceObjects.push({
          ...data,
          packageObjectId,
          moduleName,
          structName,
          name: safeDisplay?.name ?? fields?.name,
          description: safeDisplay?.description ?? fields?.description,
          imageUrl: safeUrl,
          display: safeDisplay,
          fields,
          isCoin: structName === "Coin"
        });
        if (structName === "Coin") {
          tokens[subtype] || (tokens[subtype] = {
            balance: 0,
            coins: []
          });
          tokens[subtype].balance = sumBN(tokens[subtype].balance, fields.balance);
          tokens[subtype].coins.push({
            objectId: data?.objectId,
            type: data?.type,
            balance: newBN(fields.balance),
            digest: data?.digest,
            version: data?.version,
            display: safeDisplay
          });
        } else {
          if (safeUrl) {
            nfts.push({
              type: data.type ?? "Unknown",
              packageObjectId,
              moduleName,
              structName,
              chain: "Sui",
              address: data?.objectId,
              objectId: data?.objectId,
              name: safeDisplay?.name ?? fields?.name,
              description: safeDisplay?.description ?? fields?.description,
              imageUrl: safeUrl,
              link: safeDisplay?.link,
              creator: safeDisplay?.creator,
              projectUrl: safeDisplay?.project_url,
              display: safeDisplay,
              fields,
              links: {
                "Explorer": `https://explorer.sui.io/objects/${data.objectId}`
              },
              kiosk: data.kiosk
            });
          }
        }
      } catch (error) {
        console.log("Error retrieving object", data, error);
      }
    }
    return {
      suiBalance,
      balances,
      tokens,
      nfts,
      objects: convenenienceObjects,
      hasNextPage,
      nextCursor: nextCursor ?? void 0
    };
  } catch (error) {
    console.log("Error retrieving wallet contents", error);
    return null;
  }
};
var getWalletContents_default = getWalletContents;

// src/lib/getEthosSigner.ts
var import_store27 = __toModule(require_store2());

// src/types/Signer.ts
var SignerType;
(function(SignerType2) {
  SignerType2["Extension"] = "extension";
  SignerType2["Hosted"] = "hosted";
})(SignerType || (SignerType = {}));

// src/lib/activeUser.ts
var activeUser = () => {
  log_default("activeUser", "Calling Active User");
  const {walletAppUrl, apiKey} = getConfiguration_default();
  log_default("activeUser", "Configuration", walletAppUrl, apiKey);
  const resolver = (resolve) => {
    const listener = (message2) => {
      log_default("activeUser", "Message Origin: ", message2.origin, walletAppUrl, message2);
      if (message2.origin === walletAppUrl) {
        const {action, data} = message2.data;
        log_default("activeUser", "Message From Wallet", action, data);
        if (action === "user" && data.apiKey === apiKey) {
          window.removeEventListener("message", listener);
          resolve(data?.user);
        }
      }
    };
    window.addEventListener("message", listener);
    const message = {action: "activeUser"};
    log_default("activeUser", "getIframe");
    getIframe_default();
    log_default('activeUser", "Post message to the iframe', message);
    postIFrameMessage_default(message);
  };
  return new Promise(resolver);
};
var activeUser_default = activeUser;

// src/lib/hostedInteraction.ts
var import_store26 = __toModule(require_store2());
var hostedInteraction = ({id, action, data, onResponse, showWallet: showWallet2 = false}) => {
  const {walletAppUrl} = getConfiguration_default();
  const iframeListener = (message) => {
    log_default("hostedInteraction", "response: ", message);
    if (message.origin === walletAppUrl) {
      const {approved, action: responseAction, data: responseData} = message.data;
      if (responseAction !== action)
        return;
      onResponse({approved, data: responseData});
      window.removeEventListener("message", iframeListener);
      getIframe_default(false);
    }
  };
  window.addEventListener("message", iframeListener);
  const ethosStore = import_store26.default.namespace("ethos");
  const configuration = ethosStore("configuration");
  const {network} = configuration;
  log_default("hostedInteraction", "Posting interaction", id, action, data);
  postIFrameMessage_default({id, network, action, data});
  getIframe_default(showWallet2);
};
var hostedInteraction_default = hostedInteraction;

// src/lib/getEthosSigner.ts
var getEthosSigner = async ({client, defaultChain}) => {
  const user = await activeUser_default();
  const accounts = (user?.accounts || []).filter((account) => account.chain === "sui");
  const currentAccount = accounts[0];
  const signAndExecuteTransactionBlock = (input) => {
    return new Promise((resolve, reject) => {
      const transactionEventListener = ({approved, data}) => {
        if (approved) {
          resolve(data.response);
        } else {
          reject({error: data?.response?.error || "User rejected transaction."});
        }
      };
      const serializedTransaction = input.transactionBlock.serialize();
      const account = input.account ?? currentAccount.address;
      const chain = input.chain ?? defaultChain ?? DEFAULT_CHAIN;
      hostedInteraction_default({
        action: "transaction",
        data: {
          input,
          serializedTransaction,
          account,
          chain
        },
        onResponse: transactionEventListener,
        showWallet: true
      });
    });
  };
  const executeTransactionBlock2 = (input) => {
    return client.executeTransactionBlock(input);
  };
  const signTransactionBlock2 = (input) => {
    return new Promise((resolve, reject) => {
      const transactionEventListener = ({approved, data}) => {
        if (approved) {
          resolve(data.response);
        } else {
          reject({error: data?.response?.error || "User rejected transaction."});
        }
      };
      const serializedTransaction = input.transactionBlock.serialize();
      const account = input.account ?? currentAccount.address;
      const chain = input.chain ?? defaultChain ?? DEFAULT_CHAIN;
      hostedInteraction_default({
        action: "transaction",
        data: {
          input,
          serializedTransaction,
          account,
          chain
        },
        onResponse: transactionEventListener,
        showWallet: true
      });
    });
  };
  const requestPreapproval = () => {
    return Promise.resolve(true);
  };
  const signPersonalMessage = (input) => {
    return new Promise((resolve, reject) => {
      const transactionEventListener = ({approved, data}) => {
        if (approved) {
          resolve({
            ...data.response,
            bytes: data.response.messageBytes
          });
        } else {
          reject({error: data?.response?.error || "User rejected signing."});
        }
      };
      hostedInteraction_default({
        action: "sign",
        data: {...input, signData: input.message},
        onResponse: transactionEventListener,
        showWallet: true
      });
    });
  };
  const disconnect = (fromWallet = false) => {
    return new Promise((resolve) => {
      const transactionEventListener = () => {
        resolve(true);
      };
      hostedInteraction_default({
        action: "logout",
        data: {
          fromWallet: typeof fromWallet === "boolean" ? fromWallet : false
        },
        onResponse: transactionEventListener
      });
      import_store27.default.namespace("auth")("access_token", null);
    });
  };
  const logout2 = () => {
    return disconnect(true);
  };
  return user ? {
    type: SignerType.Hosted,
    name: "Ethos",
    icon: dataIcon,
    email: user.email,
    getAddress: async () => currentAccount?.address,
    accounts,
    currentAccount,
    signAndExecuteTransactionBlock,
    executeTransactionBlock: executeTransactionBlock2,
    signTransactionBlock: signTransactionBlock2,
    requestPreapproval,
    signPersonalMessage,
    disconnect,
    logout: logout2,
    client
  } : null;
};
var getEthosSigner_default = getEthosSigner;
var dataIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iOCIgZmlsbD0iIzZEMjhEOSIvPgo8cGF0aCBvcGFjaXR5PSIwLjgiIGQ9Ik05LjEyMTg3IDYuODU3MDZIMTkuOTU4M0MyMC40NTcxIDYuODU3MDYgMjAuODYxNCA3LjI2MTQxIDIwLjg2MTQgNy43NjAyVjE5Ljk4ODZDMjAuODYxNCAyMC40ODc0IDIwLjQ1NzEgMjAuODkxOCAxOS45NTgzIDIwLjg5MThIOS4xMjE4N0M4LjYyMzA4IDIwLjg5MTggOC4yMTg3MiAyMC40ODc0IDguMjE4NzIgMTkuOTg4NlY3Ljc2MDJDOC4yMTg3MiA3LjI2MTQxIDguNjIzMDggNi44NTcwNiA5LjEyMTg3IDYuODU3MDZaIiBzdHJva2U9InVybCgjcGFpbnQwX2xpbmVhcl82OTlfMjY5OCkiIHN0cm9rZS13aWR0aD0iMC40NTE1NzIiLz4KPHBhdGggZD0iTTguNzEyNzQgNy40NTQ1OUwxNi4wOTQ1IDEwLjg4OTRDMTYuNDEyOSAxMS4wMzc2IDE2LjYxNjYgMTEuMzU3IDE2LjYxNjYgMTEuNzA4M1YyMy44MUMxNi42MTY2IDI0LjQ2MzUgMTUuOTQ0IDI0LjkwMDcgMTUuMzQ2OCAyNC42MzUzTDcuOTY1MDIgMjEuMzU1NkM3LjYzODgyIDIxLjIxMDcgNy40Mjg1OCAyMC44ODcyIDcuNDI4NTggMjAuNTMwM1Y4LjI3MzQzQzcuNDI4NTggNy42MTMxMSA4LjExNDA2IDcuMTc2MDIgOC43MTI3NCA3LjQ1NDU5WiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTIzLjM3ODIgMTUuMzc2N0MyMy40MzAzIDE1LjEzMjEgMjMuNTUzOCAxNC45MDg2IDIzLjczMzIgMTQuNzM0M0MyMy45MTI1IDE0LjU2IDI0LjEzOTYgMTQuNDQzIDI0LjM4NTYgMTQuMzk3OUwyNS4wNDA0IDE0LjI3ODRMMjQuMzg1NSAxNC4xNTg4SDI0LjM4NTZDMjQuMTM5NiAxNC4xMTM3IDIzLjkxMjUgMTMuOTk2NyAyMy43MzMyIDEzLjgyMjRDMjMuNTUzOCAxMy42NDgxIDIzLjQzMDMgMTMuNDI0NiAyMy4zNzgyIDEzLjE4TDIzLjIzNDEgMTIuNTAxM0wyMy4wOSAxMy4xOEMyMy4wMzc5IDEzLjQyNDYgMjIuOTE0NCAxMy42NDgxIDIyLjczNTEgMTMuODIyNEMyMi41NTU4IDEzLjk5NjcgMjIuMzI4NyAxNC4xMTM4IDIyLjA4MjcgMTQuMTU4OEwyMS40Mjc4IDE0LjI3ODRMMjIuMDgyNyAxNC4zOTc5SDIyLjA4MjdDMjIuMzI4NyAxNC40NDMgMjIuNTU1NyAxNC41NiAyMi43MzUgMTQuNzM0M0MyMi45MTQ0IDE0LjkwODYgMjMuMDM3OSAxNS4xMzIxIDIzLjA5IDE1LjM3NjdMMjMuMjM0MSAxNi4wNTU0TDIzLjM3ODIgMTUuMzc2N1oiIGZpbGw9IndoaXRlIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfNjk5XzI2OTgiIHgxPSIyMC44NjE0IiB5MT0iMTAuNTkyNiIgeDI9IjE0LjUzOTgiIHkyPSIxMy43NTM0IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IndoaXRlIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0id2hpdGUiIHN0b3Atb3BhY2l0eT0iMCIvPgo8L2xpbmVhckdyYWRpZW50Pgo8L2RlZnM+Cjwvc3ZnPgo=`;

// src/lib/initializeEthos.ts
var import_store28 = __toModule(require_store2());
var initializeEthos = (ethosConfiguration) => {
  const ethosStore = import_store28.default.namespace("ethos");
  log_default("initialize", "Ethos Configuration", ethosConfiguration);
  ethosStore("configuration", ethosConfiguration);
};
var initializeEthos_default = initializeEthos;

// src/lib/listenForMobileConnection.ts
var listenForMobileConnection = async () => {
  const {walletAppUrl} = getConfiguration_default();
  const connectionEventListener = (message) => {
    if (message.origin === walletAppUrl) {
      const {action, data} = message.data;
      if (action !== "connect")
        return;
      if (!data.address) {
        return;
      }
      ;
      window.removeEventListener("message", connectionEventListener);
      const signer = {
        currentAccount: {address: data.address}
      };
      const provider = {
        getSigner: signer
      };
      log_default("mobile", "Mobile connection established", provider, signer);
    }
  };
  window.removeEventListener("message", connectionEventListener);
  window.addEventListener("message", connectionEventListener);
};
var listenForMobileConnection_default = listenForMobileConnection;

// src/lib/lib.ts
var lib = {
  getWalletContents: getWalletContents_default,
  postIFrameMessage: postIFrameMessage_default,
  getEthosSigner: getEthosSigner_default,
  getConfiguration: getConfiguration_default,
  initializeEthos: initializeEthos_default,
  listenForMobileConnection: listenForMobileConnection_default
};
var lib_default = lib;

// src/lib/login.ts
var login = async ({email, provider, apiKey}) => {
  const {walletAppUrl, redirectTo} = lib_default.getConfiguration();
  const userStore = import_store29.default.namespace("users");
  if (provider) {
    const returnTo = redirectTo ?? location.href;
    const fullUrl = `${walletAppUrl}/auth?apiKey=${apiKey}&returnTo=${encodeURIComponent(returnTo)}`;
    location.href = `${walletAppUrl}/socialauth?provider=${provider}&redirectTo=${encodeURIComponent(fullUrl)}`;
    return;
  }
  return new Promise((resolve, _reject) => {
    const loginEventListener = (message) => {
      if (message.origin === walletAppUrl) {
        const {action, data} = message.data;
        if (action !== "login")
          return;
        window.removeEventListener("message", loginEventListener);
        userStore("current", data);
        resolve(data);
      }
    };
    window.addEventListener("message", loginEventListener);
    lib_default.postIFrameMessage({
      action: "login",
      data: {
        email,
        provider,
        returnTo: redirectTo ?? window.location.href,
        apiKey
      }
    });
  });
};
var login_default = login;

// src/components/styled/Email.tsx
var Email = ({setSigningIn, setEmailSent, width}) => {
  const {apiKey} = getConfiguration_default();
  const [email, setEmail] = (0, import_react10.useState)("");
  const validEmail = (0, import_react10.useMemo)(() => {
    if (!email)
      return false;
    if (email.length === 0)
      return false;
    return !!email.match(/(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])/);
  }, [email]);
  const sendEmail = (0, import_react10.useCallback)(async () => {
    if (!validEmail)
      return;
    await login_default({email, apiKey});
    setEmail("");
    setSigningIn(false);
    setEmailSent(true);
    event_default({action: "send_email", category: "sign_in", label: email, value: 1});
  }, [validEmail, login_default, email, apiKey]);
  const _handleChange = (0, import_react10.useCallback)((e) => {
    setEmail(e.target.value);
  }, []);
  const onSubmit = (0, import_react10.useCallback)(async (e) => {
    if (!validEmail) {
      e.preventDefault();
      return;
    }
    setSigningIn(true);
    sendEmail();
  }, [sendEmail]);
  return /* @__PURE__ */ import_react10.default.createElement("div", {
    role: "email-sign-in"
  }, /* @__PURE__ */ import_react10.default.createElement("form", {
    onSubmit,
    style: walletOptionContainer(width)
  }, /* @__PURE__ */ import_react10.default.createElement("input", {
    style: emailInput(),
    type: "email",
    placeholder: "Enter your email address...",
    value: email,
    onChange: _handleChange
  }), /* @__PURE__ */ import_react10.default.createElement(IconButton_default, {
    text: "Sign In With Email",
    type: "submit",
    width,
    disabled: !validEmail,
    primary: true
  })));
};
var Email_default = Email;

// src/components/styled/Dialog.tsx
var import_react11 = __toModule(require("react"));

// src/components/styled/FontProvider.tsx
var React10 = __toModule(require("react"));
var FontProvider = ({children}) => {
  const styles12 = () => ({
    fontFamily: "'Inter', sans-serif",
    color: "black",
    lineHeight: "1.5",
    fontSize: "16px"
  });
  return /* @__PURE__ */ React10.createElement(React10.Fragment, null, /* @__PURE__ */ React10.createElement("link", {
    href: "https://rsms.me/inter/inter.css",
    rel: "stylesheet"
  }), /* @__PURE__ */ React10.createElement("div", {
    style: styles12()
  }, children));
};
var FontProvider_default = FontProvider;

// src/components/styled/Dialog.tsx
var Dialog = ({isOpenAll, children}) => {
  return /* @__PURE__ */ import_react11.default.createElement(FontProvider_default, null, /* @__PURE__ */ import_react11.default.createElement("div", {
    style: dialog(isOpenAll),
    role: "dialog"
  }, /* @__PURE__ */ import_react11.default.createElement("div", {
    style: backdrop(isOpenAll)
  }), children));
};
var Dialog_default = Dialog;

// src/components/styled/ModalWrapper.tsx
var import_react12 = __toModule(require("react"));
var ModalWrapper = ({closeOnClickId, onClose, isOpenAll, width, back, children}) => {
  return /* @__PURE__ */ import_react12.default.createElement("div", {
    style: modalOuterWrapper(isOpenAll)
  }, /* @__PURE__ */ import_react12.default.createElement("div", {
    id: closeOnClickId,
    style: modalInnerWrapper(width)
  }, /* @__PURE__ */ import_react12.default.createElement("div", {
    style: dialogPanel(width)
  }, /* @__PURE__ */ import_react12.default.createElement("div", {
    style: topPanelStyle()
  }, /* @__PURE__ */ import_react12.default.createElement("span", null, back && /* @__PURE__ */ import_react12.default.createElement("span", {
    style: backStyle(),
    onClick: back
  }, "\u2190", /* @__PURE__ */ import_react12.default.createElement("span", {
    style: backStyleText()
  }, "Back"))), /* @__PURE__ */ import_react12.default.createElement("span", {
    style: closeStyle(),
    onClick: onClose
  }, /* @__PURE__ */ import_react12.default.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor"
  }, /* @__PURE__ */ import_react12.default.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M6 18L18 6M6 6l12 12"
  })))), children)));
};
var ModalWrapper_default = ModalWrapper;

// src/components/svg/InstallWalletIcon.tsx
var import_react13 = __toModule(require("react"));
var InstallWalletIcon = ({width = 60}) => {
  return /* @__PURE__ */ import_react13.default.createElement("svg", {
    width,
    height: width,
    viewBox: "0 0 60 60",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ import_react13.default.createElement("rect", {
    x: "1",
    y: "1",
    width: "58",
    height: "58",
    rx: "17",
    fill: "#1A1C26"
  }), /* @__PURE__ */ import_react13.default.createElement("path", {
    d: "M17.0307 21.5C18.1258 20.5314 19.538 19.9977 21 20H39C40.5213 20 41.9107 20.5667 42.9693 21.5C42.8475 20.5332 42.377 19.6442 41.6462 18.9998C40.9153 18.3553 39.9744 17.9998 39 18H21C20.0256 17.9998 19.0847 18.3553 18.3538 18.9998C17.623 19.6442 17.1525 20.5332 17.0307 21.5ZM17.0307 25.5C18.1258 24.5314 19.538 23.9977 21 24H39C40.5213 24 41.9107 24.5667 42.9693 25.5C42.8475 24.5332 42.377 23.6442 41.6462 22.9998C40.9153 22.3553 39.9744 21.9998 39 22H21C20.0256 21.9998 19.0847 22.3553 18.3538 22.9998C17.623 23.6442 17.1525 24.5332 17.0307 25.5ZM21 26C19.9391 26 18.9217 26.4214 18.1716 27.1716C17.4214 27.9217 17 28.9391 17 30V38C17 39.0609 17.4214 40.0783 18.1716 40.8284C18.9217 41.5786 19.9391 42 21 42H39C40.0609 42 41.0783 41.5786 41.8284 40.8284C42.5786 40.0783 43 39.0609 43 38V30C43 28.9391 42.5786 27.9217 41.8284 27.1716C41.0783 26.4214 40.0609 26 39 26H34C33.7348 26 33.4804 26.1054 33.2929 26.2929C33.1054 26.4804 33 26.7348 33 27C33 27.7956 32.6839 28.5587 32.1213 29.1213C31.5587 29.6839 30.7956 30 30 30C29.2044 30 28.4413 29.6839 27.8787 29.1213C27.3161 28.5587 27 27.7956 27 27C27 26.7348 26.8946 26.4804 26.7071 26.2929C26.5196 26.1054 26.2652 26 26 26H21Z",
    fill: "white"
  }), /* @__PURE__ */ import_react13.default.createElement("rect", {
    x: "1",
    y: "1",
    width: "58",
    height: "58",
    rx: "17",
    stroke: "#060914",
    strokeWidth: "2"
  }));
};
var InstallWalletIcon_default = InstallWalletIcon;

// src/components/styled/InstallWallet.tsx
var import_react14 = __toModule(require("react"));
var InstallWallet = ({walletInfos, width}) => {
  const icon = (data) => {
    if (!data)
      return /* @__PURE__ */ import_react14.default.createElement(import_react14.default.Fragment, null);
    if (typeof data === "string") {
      return /* @__PURE__ */ import_react14.default.createElement("img", {
        src: data,
        height: 32,
        width: 32
      });
    }
    return data;
  };
  const installWallets = [
    {
      name: "Ethos Wallet",
      icon: /* @__PURE__ */ import_react14.default.createElement(EthosWalletIcon_default, {
        width: 26
      }),
      link: "https://chrome.google.com/webstore/detail/ethos-wallet/mcbigmjiafegjnnogedioegffbooigli"
    },
    ...walletInfos || []
  ];
  return /* @__PURE__ */ import_react14.default.createElement(Header_default, {
    dappIcon: /* @__PURE__ */ import_react14.default.createElement(InstallWalletIcon_default, null),
    title: "Install A Wallet",
    subTitle: "Wallets allow you to interact with, store, send, and receive digital assets."
  }, /* @__PURE__ */ import_react14.default.createElement("div", {
    role: "wallet-sign-in"
  }, /* @__PURE__ */ import_react14.default.createElement("div", {
    style: walletOptionContainer(width)
  }, installWallets?.map((installWallet, index) => /* @__PURE__ */ import_react14.default.createElement("a", {
    key: `install-wallet-${index}`,
    style: iconButton(width),
    href: installWallet.link,
    target: "_blank"
  }, installWallet.name, /* @__PURE__ */ import_react14.default.createElement("div", null, icon(installWallet.icon)))))));
};
var InstallWallet_default = InstallWallet;

// src/hooks/useModal.ts
var import_react16 = __toModule(require("react"));

// src/components/ConnectContext.tsx
var import_react15 = __toModule(require("react"));
var defaultContents = {
  init: () => {
  }
};
var ConnectContext = (0, import_react15.createContext)(defaultContents);
var ConnectContext_default = ConnectContext;

// src/hooks/useModal.ts
var useModal = () => {
  const {modal} = (0, import_react16.useContext)(ConnectContext_default);
  return modal;
};
var useModal_default = useModal;

// src/hooks/useWallet.ts
var import_react17 = __toModule(require("react"));

// src/enums/EthosConnectStatus.ts
var EthosConnectStatus;
(function(EthosConnectStatus2) {
  EthosConnectStatus2["Loading"] = "loading";
  EthosConnectStatus2["NoConnection"] = "no_connection";
  EthosConnectStatus2["Connected"] = "connected";
})(EthosConnectStatus || (EthosConnectStatus = {}));

// src/hooks/useWallet.ts
var useWallet = () => {
  const {wallet} = (0, import_react17.useContext)(ConnectContext_default);
  return wallet ?? {status: EthosConnectStatus.Loading, client: null, setAltAccount: () => {
  }};
};
var useWallet_default = useWallet;

// src/hooks/useWindowDimensions.ts
var import_react18 = __toModule(require("react"));
function getWindowDimensions() {
  if (typeof window === "undefined")
    return {width: 0, height: 0};
  const {innerWidth: width, innerHeight: height} = window;
  return {
    width,
    height
  };
}
function useWindowDimensions() {
  const [windowDimensions, setWindowDimensions] = (0, import_react18.useState)({width: 0, height: 0});
  (0, import_react18.useEffect)(() => {
    setWindowDimensions(getWindowDimensions());
    function handleResize() {
      setWindowDimensions(getWindowDimensions());
    }
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  return windowDimensions;
}

// src/hooks/hooks.ts
var hooks = {
  useModal: useModal_default,
  useWallet: useWallet_default,
  useWindowDimensions
};
var hooks_default = hooks;

// src/components/styled/MobileWallet.tsx
var import_react19 = __toModule(require("react"));
var MobileWallet = () => {
  return /* @__PURE__ */ import_react19.default.createElement("div", {
    role: "wallet-sign-in"
  }, /* @__PURE__ */ import_react19.default.createElement("span", {
    style: ethosWalletTitleText()
  }, "Connect A Mobile Wallet"), /* @__PURE__ */ import_react19.default.createElement("div", {
    style: walletExplanation()
  }, /* @__PURE__ */ import_react19.default.createElement("p", null, "There are no mobile wallets yet on Sui.")));
};
var MobileWallet_default = MobileWallet;

// src/components/styled/Or.tsx
var import_react20 = __toModule(require("react"));
var Or = () => {
  return /* @__PURE__ */ import_react20.default.createElement("div", {
    style: strikeThroughOrContainer()
  }, /* @__PURE__ */ import_react20.default.createElement("div", {
    style: line()
  }), "or", /* @__PURE__ */ import_react20.default.createElement("div", {
    style: line()
  }));
};
var Or_default = Or;

// src/components/styled/SignInModal.tsx
function showSignInModal() {
  window.ethosInternal.showSignInModal();
}
function hideSignInModal() {
  window.ethosInternal.hideSignInModal();
}
var SignInModal = ({
  connectMessage,
  dappName,
  dappIcon,
  hideEmailSignIn,
  hideWalletSignIn,
  externalContext,
  preferredWallets
}) => {
  const {wallets: wallets2, selectWallet} = externalContext?.wallet || hooks_default.useWallet();
  const {isModalOpen, openModal, closeModal} = externalContext?.modal || hooks_default.useModal();
  const [isOpenAll, setIsOpenAll] = (0, import_react21.useState)(isModalOpen);
  const [signingIn, setSigningIn] = (0, import_react21.useState)(false);
  const [emailSent, setEmailSent] = (0, import_react21.useState)(false);
  const {width} = hooks_default.useWindowDimensions();
  const closeOnClickId = "ethos-close-on-click";
  const [showEmail, setShowEmail] = (0, import_react21.useState)(false);
  const [showMobile, setShowMobile] = (0, import_react21.useState)(false);
  const [showInstallWallet, setShowInstallWallet] = (0, import_react21.useState)(false);
  const [safeDappName, setSafeDappName] = (0, import_react21.useState)(dappName);
  const [safeWallets, setSafeWallets] = (0, import_react21.useState)();
  useHandleElementWithIdClicked(closeOnClickId, closeModal);
  (0, import_react21.useEffect)(() => {
    window.ethosInternal || (window.ethosInternal = {});
    window.ethosInternal.showSignInModal = () => {
      openModal();
    };
    window.ethosInternal.hideSignInModal = () => {
      closeModal();
    };
    setIsOpenAll(isModalOpen);
  }, [isModalOpen, setIsOpenAll, openModal, closeModal]);
  (0, import_react21.useEffect)(() => {
    if (hideEmailSignIn && hideWalletSignIn) {
      throw new Error("hideEmailSignIn and hideWalletSignIn cannot both be true");
    }
  }, [hideEmailSignIn, hideWalletSignIn]);
  (0, import_react21.useEffect)(() => {
    if (!safeDappName) {
      setSafeDappName(document.title);
    }
  }, [safeDappName]);
  (0, import_react21.useEffect)(() => {
    let safeWallets2 = wallets2 || [];
    if (preferredWallets && preferredWallets.length > 0) {
      safeWallets2 = safeWallets2.sort((a, b) => {
        let aIndex = preferredWallets.indexOf(a.name);
        if (aIndex === -1) {
          aIndex = safeWallets2.length;
        }
        let bIndex = preferredWallets.indexOf(b.name);
        if (bIndex === -1) {
          bIndex = safeWallets2.length;
        }
        return aIndex - bIndex;
      });
    }
    log_default("preferredWallets", preferredWallets, safeWallets2);
    setSafeWallets(safeWallets2);
  }, [wallets2, preferredWallets, log_default]);
  const _toggleInstallWallet = (0, import_react21.useCallback)(() => {
    setShowInstallWallet((prev) => !prev);
  }, []);
  const _toggleEmail = (0, import_react21.useCallback)(() => {
    setShowEmail((prev) => !prev);
  }, []);
  const _reset = (0, import_react21.useCallback)(() => {
    setShowInstallWallet(false);
    setShowMobile(false);
    setShowEmail(false);
  }, []);
  const safeConnectMessage = (0, import_react21.useMemo)(() => {
    if (connectMessage)
      return connectMessage;
    if (!safeDappName) {
      return /* @__PURE__ */ import_react21.default.createElement(import_react21.default.Fragment, null);
    }
    return /* @__PURE__ */ import_react21.default.createElement(import_react21.default.Fragment, null, "Connect to ", /* @__PURE__ */ import_react21.default.createElement("span", {
      style: highlighted()
    }, safeDappName));
  }, [safeDappName, connectMessage]);
  const modalContent = (0, import_react21.useMemo)(() => {
    if (!safeWallets) {
      return /* @__PURE__ */ import_react21.default.createElement(import_react21.default.Fragment, null);
    }
    if (showMobile) {
      return /* @__PURE__ */ import_react21.default.createElement(MobileWallet_default, null);
    }
    if (showInstallWallet || hideEmailSignIn && safeWallets.length === 0) {
      return /* @__PURE__ */ import_react21.default.createElement(InstallWallet_default, {
        width
      });
    }
    if (hideWalletSignIn) {
      return /* @__PURE__ */ import_react21.default.createElement(Email_default, {
        setSigningIn,
        setEmailSent,
        width
      });
    }
    if (!showEmail && safeWallets.length > 0)
      return /* @__PURE__ */ import_react21.default.createElement(Header_default, {
        title: safeConnectMessage,
        dappIcon,
        subTitle: "Choose from your installed wallets"
      }, /* @__PURE__ */ import_react21.default.createElement(Wallets_default, {
        wallets: safeWallets,
        selectWallet,
        width
      }), !hideEmailSignIn && /* @__PURE__ */ import_react21.default.createElement(import_react21.default.Fragment, null, /* @__PURE__ */ import_react21.default.createElement(Or_default, null), /* @__PURE__ */ import_react21.default.createElement("div", {
        style: submitButtonContainer()
      }, /* @__PURE__ */ import_react21.default.createElement(IconButton_default, {
        text: "Sign In With Email",
        onClick: _toggleEmail,
        width,
        primary: true
      }))));
    return /* @__PURE__ */ import_react21.default.createElement(Header_default, {
      title: safeConnectMessage,
      dappIcon,
      subTitle: `Log in to ${safeDappName}`
    }, /* @__PURE__ */ import_react21.default.createElement(Email_default, {
      setSigningIn,
      setEmailSent,
      width
    }), !hideWalletSignIn && /* @__PURE__ */ import_react21.default.createElement(import_react21.default.Fragment, null, /* @__PURE__ */ import_react21.default.createElement(Or_default, null), /* @__PURE__ */ import_react21.default.createElement("div", {
      style: submitButtonContainer()
    }, safeWallets.length > 0 ? /* @__PURE__ */ import_react21.default.createElement(IconButton_default, {
      icon: /* @__PURE__ */ import_react21.default.createElement(WalletsIcon_default, null),
      text: "Select One Of Your Wallets",
      onClick: _toggleEmail,
      width
    }) : /* @__PURE__ */ import_react21.default.createElement(IconButton_default, {
      icon: /* @__PURE__ */ import_react21.default.createElement(WalletsIcon_default, null),
      text: "Install A Wallet",
      onClick: _toggleInstallWallet,
      width
    }))));
  }, [safeConnectMessage, safeDappName, hideEmailSignIn, hideWalletSignIn, safeWallets, showEmail, showMobile, showInstallWallet]);
  const subpage = (0, import_react21.useMemo)(() => {
    return showMobile || showInstallWallet;
  }, [showMobile, showInstallWallet]);
  const loader = (0, import_react21.useMemo)(() => /* @__PURE__ */ import_react21.default.createElement("div", {
    style: loaderStyle()
  }, /* @__PURE__ */ import_react21.default.createElement(Loader_default, {
    width: 50
  })), []);
  return /* @__PURE__ */ import_react21.default.createElement(Dialog_default, {
    isOpenAll
  }, /* @__PURE__ */ import_react21.default.createElement(ModalWrapper_default, {
    closeOnClickId,
    onClose: closeModal,
    isOpenAll,
    width,
    back: subpage ? _reset : null
  }, emailSent ? /* @__PURE__ */ import_react21.default.createElement(EmailSent_default, null) : signingIn ? loader : modalContent));
};
var SignInModal_default = SignInModal;

// src/hooks/useContext.ts
var import_react25 = __toModule(require("react"));

// src/hooks/useAccount.ts
var import_react22 = __toModule(require("react"));
var useAccount = (signer, network, explicitInterval, invalidPackages) => {
  const [altAccount, setAltAccount] = (0, import_react22.useState)();
  const [account, setAccount] = (0, import_react22.useState)({});
  const latestNetwork = (0, import_react22.useRef)(network);
  const existingContents = (0, import_react22.useRef)();
  (0, import_react22.useEffect)(() => {
    if (!signer)
      return;
    latestNetwork.current = network;
    const initAccount = async () => {
      const address2 = altAccount?.address ?? signer.currentAccount?.address;
      if (!address2) {
        return;
      }
      setAccount((prev) => {
        if (prev.address === address2)
          return prev;
        return {...prev, address: address2};
      });
      const contents = await getWalletContents_default({
        address: address2,
        network,
        existingContents: existingContents.current,
        invalidPackageModifications: invalidPackages
      });
      if (!contents || network !== latestNetwork.current || JSON.stringify(existingContents.current) === JSON.stringify(contents))
        return;
      existingContents.current = contents;
      setAccount((prev) => ({...prev, contents}));
    };
    initAccount();
    const interval = setInterval(initAccount, explicitInterval ?? 5e3);
    return () => clearInterval(interval);
  }, [network, signer, altAccount]);
  return {account, altAccount, setAltAccount};
};
var useAccount_default = useAccount;

// src/hooks/useConnect.ts
var import_react24 = __toModule(require("react"));

// src/hooks/useWalletKit.ts
var import_react23 = __toModule(require("react"));

// node_modules/@wallet-standard/app/lib/esm/wallets.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AppReadyEvent_detail;
var wallets = void 0;
var registered = new Set();
var listeners = {};
function getWallets() {
  if (wallets)
    return wallets;
  wallets = Object.freeze({register, get: get2, on});
  if (typeof window === "undefined")
    return wallets;
  const api = Object.freeze({register});
  try {
    window.addEventListener("wallet-standard:register-wallet", ({detail: callback}) => callback(api));
  } catch (error) {
    console.error("wallet-standard:register-wallet event listener could not be added\n", error);
  }
  try {
    window.dispatchEvent(new AppReadyEvent(api));
  } catch (error) {
    console.error("wallet-standard:app-ready event could not be dispatched\n", error);
  }
  return wallets;
}
function register(...wallets2) {
  wallets2 = wallets2.filter((wallet) => !registered.has(wallet));
  if (!wallets2.length)
    return () => {
    };
  wallets2.forEach((wallet) => registered.add(wallet));
  listeners["register"]?.forEach((listener) => guard(() => listener(...wallets2)));
  return function unregister() {
    wallets2.forEach((wallet) => registered.delete(wallet));
    listeners["unregister"]?.forEach((listener) => guard(() => listener(...wallets2)));
  };
}
function get2() {
  return [...registered];
}
function on(event2, listener) {
  listeners[event2]?.push(listener) || (listeners[event2] = [listener]);
  return function off() {
    listeners[event2] = listeners[event2]?.filter((existingListener) => listener !== existingListener);
  };
}
function guard(callback) {
  try {
    callback();
  } catch (error) {
    console.error(error);
  }
}
var AppReadyEvent = class extends Event {
  constructor(api) {
    super("wallet-standard:app-ready", {
      bubbles: false,
      cancelable: false,
      composed: false
    });
    _AppReadyEvent_detail.set(this, void 0);
    __classPrivateFieldSet(this, _AppReadyEvent_detail, api, "f");
  }
  get detail() {
    return __classPrivateFieldGet(this, _AppReadyEvent_detail, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
};
_AppReadyEvent_detail = new WeakMap();

// node_modules/@mysten/wallet-standard/dist/index.mjs
var REQUIRED_FEATURES = [
  "standard:connect",
  "standard:events"
];
function isWalletWithSuiFeatures(wallet, features = []) {
  return [...REQUIRED_FEATURES, ...features].every((feature) => feature in wallet.features);
}

// node_modules/@mysten/wallet-kit-core/dist/index.mjs
var localStorageAdapter = {
  async set(key, value) {
    return localStorage.setItem(key, value);
  },
  async get(key) {
    return localStorage.getItem(key);
  },
  async del(key) {
    localStorage.removeItem(key);
  }
};
var DEFAULT_FEATURES = [
  "sui:signAndExecuteTransactionBlock"
];
var WalletKitCoreConnectionStatus = /* @__PURE__ */ ((WalletKitCoreConnectionStatus2) => {
  WalletKitCoreConnectionStatus2["DISCONNECTED"] = "DISCONNECTED";
  WalletKitCoreConnectionStatus2["CONNECTING"] = "CONNECTING";
  WalletKitCoreConnectionStatus2["CONNECTED"] = "CONNECTED";
  WalletKitCoreConnectionStatus2["ERROR"] = "ERROR";
  return WalletKitCoreConnectionStatus2;
})(WalletKitCoreConnectionStatus || {});
var SUI_WALLET_NAME = "Sui Wallet";
var RECENT_WALLET_STORAGE = "wallet-kit:last-wallet";
function waitToBeVisible() {
  if (!document || document.visibilityState === "visible") {
    return Promise.resolve();
  }
  let promiseResolve = null;
  const promise = new Promise((r) => promiseResolve = r);
  const callback = () => {
    if (promiseResolve && document.visibilityState === "visible") {
      promiseResolve();
      document.removeEventListener("visibilitychange", callback);
    }
  };
  document.addEventListener("visibilitychange", callback);
  return promise;
}
function sortWallets(wallets2, preferredWallets, features) {
  const suiWallets = wallets2.filter((wallet) => isWalletWithSuiFeatures(wallet, features));
  return [
    ...preferredWallets.map((name) => suiWallets.find((wallet) => wallet.name === name)).filter(Boolean),
    ...suiWallets.filter((wallet) => !preferredWallets.includes(wallet.name))
  ];
}
function createWalletKitCore({
  preferredWallets = [SUI_WALLET_NAME],
  storageAdapter = localStorageAdapter,
  storageKey = RECENT_WALLET_STORAGE,
  features = DEFAULT_FEATURES
}) {
  const registeredWallets = getWallets();
  let wallets2 = registeredWallets.get();
  const subscriptions = /* @__PURE__ */ new Set();
  let walletEventUnsubscribe = null;
  let internalState = {
    accounts: [],
    currentAccount: null,
    wallets: sortWallets(wallets2, preferredWallets, features),
    currentWallet: null,
    status: "DISCONNECTED"
  };
  const computeState = () => ({
    ...internalState,
    isConnecting: internalState.status === "CONNECTING",
    isConnected: internalState.status === "CONNECTED",
    isError: internalState.status === "ERROR"
  });
  let state = computeState();
  function setState(nextInternalState) {
    internalState = {
      ...internalState,
      ...nextInternalState
    };
    state = computeState();
    subscriptions.forEach((handler) => {
      try {
        handler(state);
      } catch {
      }
    });
  }
  function disconnected() {
    if (walletEventUnsubscribe) {
      walletEventUnsubscribe();
      walletEventUnsubscribe = null;
    }
    setState({
      status: "DISCONNECTED",
      accounts: [],
      currentAccount: null,
      currentWallet: null
    });
  }
  const handleWalletsChanged = () => {
    setState({
      wallets: sortWallets(registeredWallets.get(), preferredWallets, features)
    });
  };
  registeredWallets.on("register", handleWalletsChanged);
  registeredWallets.on("unregister", handleWalletsChanged);
  const walletKit = {
    async autoconnect() {
      if (state.currentWallet)
        return;
      await waitToBeVisible();
      try {
        const lastWalletName = await storageAdapter.get(storageKey);
        if (lastWalletName) {
          walletKit.connect(lastWalletName, {silent: true});
        }
      } catch {
      }
    },
    getState() {
      return state;
    },
    subscribe(handler) {
      subscriptions.add(handler);
      try {
        handler(state);
      } catch {
      }
      return () => {
        subscriptions.delete(handler);
      };
    },
    selectAccount(account) {
      if (account === internalState.currentAccount || !internalState.accounts.includes(account)) {
        return;
      }
      setState({
        currentAccount: account
      });
    },
    async connect(walletName, connectInput) {
      const currentWallet = internalState.wallets.find((wallet) => wallet.name === walletName) ?? null;
      setState({currentWallet});
      if (currentWallet) {
        if (walletEventUnsubscribe) {
          walletEventUnsubscribe();
        }
        walletEventUnsubscribe = currentWallet.features["standard:events"].on("change", ({accounts, features: features2, chains}) => {
          if (accounts) {
            setState({
              accounts,
              currentAccount: internalState.currentAccount && !accounts.find(({address: address2}) => address2 === internalState.currentAccount?.address) ? accounts[0] : internalState.currentAccount
            });
          }
        });
        try {
          setState({status: "CONNECTING"});
          await currentWallet.features["standard:connect"].connect(connectInput);
          setState({status: "CONNECTED"});
          try {
            await storageAdapter.set(storageKey, currentWallet.name);
          } catch {
          }
          setState({
            accounts: currentWallet.accounts,
            currentAccount: currentWallet.accounts[0] ?? null
          });
        } catch (e) {
          console.log("Wallet connection error", e);
          setState({status: "ERROR"});
        }
      } else {
        setState({status: "DISCONNECTED"});
      }
    },
    async disconnect() {
      if (!internalState.currentWallet) {
        console.warn("Attempted to `disconnect` but no wallet was connected.");
        return;
      }
      try {
        await storageAdapter.del(storageKey);
      } catch {
      }
      await internalState.currentWallet.features["standard:disconnect"]?.disconnect();
      disconnected();
    },
    signMessage(messageInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error("No wallet is currently connected, cannot call `signMessage`.");
      }
      if (!internalState.currentWallet.features["sui:signMessage"]) {
        throw new Error("Wallet does not support deprecated `signMessage` method.");
      }
      return internalState.currentWallet.features["sui:signMessage"].signMessage({
        ...messageInput,
        account: messageInput.account ?? internalState.currentAccount
      });
    },
    signPersonalMessage(messageInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error("No wallet is currently connected, cannot call `signPersonalMessage`.");
      }
      if (!internalState.currentWallet.features["sui:signPersonalMessage"]) {
        throw new Error("Wallet does not support the new `signPersonalMessage` method.");
      }
      return internalState.currentWallet.features["sui:signPersonalMessage"].signPersonalMessage({
        ...messageInput,
        account: messageInput.account ?? internalState.currentAccount
      });
    },
    async signTransactionBlock(transactionInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error("No wallet is currently connected, cannot call `signTransaction`.");
      }
      const {
        account = internalState.currentAccount,
        chain = internalState.currentAccount.chains[0]
      } = transactionInput;
      if (!chain) {
        throw new Error("Missing chain");
      }
      return internalState.currentWallet.features["sui:signTransactionBlock"].signTransactionBlock({
        ...transactionInput,
        account,
        chain
      });
    },
    async signAndExecuteTransactionBlock(transactionInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error("No wallet is currently connected, cannot call `signAndExecuteTransactionBlock`.");
      }
      const {
        account = internalState.currentAccount,
        chain = internalState.currentAccount.chains[0]
      } = transactionInput;
      if (!chain) {
        throw new Error("Missing chain");
      }
      return internalState.currentWallet.features["sui:signAndExecuteTransactionBlock"].signAndExecuteTransactionBlock({
        ...transactionInput,
        account,
        chain
      });
    }
  };
  return walletKit;
}

// src/hooks/useWalletKit.ts
var useWalletKit = ({defaultChain, client, preferredWallets, storageAdapter, storageKey, disableAutoConnect}) => {
  const walletKitRef = (0, import_react23.useRef)(null);
  if (!walletKitRef.current) {
    walletKitRef.current = createWalletKitCore({
      preferredWallets,
      storageAdapter,
      storageKey
    });
  }
  const {wallets: wallets2, status, currentWallet, accounts, currentAccount} = (0, import_react23.useSyncExternalStore)(walletKitRef.current.subscribe, walletKitRef.current.getState, walletKitRef.current.getState);
  (0, import_react23.useEffect)(() => {
    if (!disableAutoConnect) {
      walletKitRef.current?.autoconnect();
    }
  }, [status, wallets2]);
  const {autoconnect, ...walletFunctions} = walletKitRef.current;
  const signAndExecuteTransactionBlock = (0, import_react23.useCallback)((input) => {
    if (!currentWallet || !currentAccount) {
      throw new Error("No wallet connect to sign message");
    }
    const account = input.account || currentAccount;
    const chain = input.chain || defaultChain || DEFAULT_CHAIN;
    return currentWallet.features["sui:signAndExecuteTransactionBlock"].signAndExecuteTransactionBlock({
      ...input,
      account,
      chain
    });
  }, [currentWallet, currentAccount, defaultChain]);
  const executeTransactionBlock2 = (0, import_react23.useCallback)((input) => {
    return client.executeTransactionBlock(input);
  }, [client]);
  const signTransactionBlock2 = (0, import_react23.useCallback)((input) => {
    if (!currentWallet || !currentAccount) {
      throw new Error("No wallet connect to sign message");
    }
    const account = input.account || currentAccount;
    const chain = input.chain || defaultChain || DEFAULT_CHAIN;
    return currentWallet.features["sui:signTransactionBlock"].signTransactionBlock({
      ...input,
      account,
      chain
    });
  }, [currentWallet, currentAccount, defaultChain]);
  const signPersonalMessage = (0, import_react23.useCallback)((input) => {
    if (!currentWallet || !currentAccount) {
      throw new Error("No wallet connect to sign message");
    }
    const account = input.account || currentAccount;
    const message = typeof input.message === "string" ? new TextEncoder().encode(input.message) : input.message;
    const legacySignMessage = async (input2) => {
      const response = await currentWallet.features["sui:signMessage"]?.signMessage(input2);
      return {
        ...response,
        bytes: response?.messageBytes
      };
    };
    const signFunction = currentWallet.features["sui:signPersonalMessage"]?.signPersonalMessage ?? legacySignMessage;
    return signFunction({
      ...input,
      message,
      account
    });
  }, [currentWallet, currentAccount]);
  const requestPreapproval = (0, import_react23.useCallback)(async (preapproval) => {
    if (!currentWallet || !currentAccount) {
      throw new Error("No wallet connect to preapprove transactions");
    }
    const ethosWallet = window.ethosWallet;
    if (!ethosWallet || ["Ethos Wallet", "Ethos Mobile"].indexOf(currentWallet.name) === -1) {
      console.log("Wallet does not support preapproval");
      return false;
    }
    if (!preapproval.address) {
      preapproval.address = currentAccount.address;
    }
    if (!preapproval.chain) {
      preapproval.chain = defaultChain ?? DEFAULT_CHAIN;
    }
    return ethosWallet.requestPreapproval(preapproval);
  }, [currentWallet, currentAccount, defaultChain]);
  const constructedSigner = (0, import_react23.useMemo)(() => {
    if (!currentWallet || !currentAccount)
      return null;
    return {
      type: SignerType.Extension,
      name: currentWallet.name,
      icon: currentWallet.icon,
      getAddress: async () => currentAccount?.address,
      accounts,
      currentAccount,
      signAndExecuteTransactionBlock,
      executeTransactionBlock: executeTransactionBlock2,
      signTransactionBlock: signTransactionBlock2,
      requestPreapproval,
      signPersonalMessage,
      disconnect: () => {
        walletKitRef.current?.disconnect();
      },
      client
    };
  }, [
    currentWallet,
    accounts,
    currentAccount,
    signAndExecuteTransactionBlock,
    executeTransactionBlock2,
    requestPreapproval,
    signPersonalMessage,
    client
  ]);
  return {
    wallets: wallets2,
    status,
    signer: constructedSigner,
    ...walletFunctions
  };
};
var useWalletKit_default = useWalletKit;

// src/hooks/useConnect.ts
var import_client2 = __toModule(require_client2());
var useConnect = (ethosConfiguration, onWalletConnected) => {
  const signerFound = (0, import_react24.useRef)(false);
  const methodsChecked = (0, import_react24.useRef)({
    "ethos": false,
    "extension": false
  });
  const client = (0, import_react24.useMemo)(() => {
    const network = typeof ethosConfiguration?.network === "string" ? ethosConfiguration.network : DEFAULT_NETWORK;
    const client2 = new import_client2.SuiClient({url: network});
    return client2;
  }, [ethosConfiguration]);
  const [clientAndSigner, setClientAndSigner] = (0, import_react24.useState)({client: null, signer: null});
  const {
    wallets: wallets2,
    status: suiStatus,
    signer: suiSigner,
    getState,
    connect
  } = useWalletKit_default({
    client,
    defaultChain: ethosConfiguration?.chain ?? DEFAULT_CHAIN,
    preferredWallets: ethosConfiguration?.preferredWallets,
    disableAutoConnect: ethosConfiguration?.disableAutoConnect
  });
  const disconnect = (0, import_react24.useCallback)(() => {
    signerFound.current = false;
    methodsChecked.current = {
      "ethos": false,
      "extension": false
    };
    setClientAndSigner((prev) => ({
      ...prev,
      signer: null
    }));
  }, []);
  (0, import_react24.useEffect)(() => {
    signerFound.current = false;
    methodsChecked.current = {
      "ethos": false,
      "extension": false
    };
  }, [ethosConfiguration]);
  (0, import_react24.useEffect)(() => {
    const {client: client2, signer} = clientAndSigner;
    if (!client2 && !signer)
      return;
    const extensionState = getState();
    if (extensionState.isConnecting || extensionState.isError)
      return;
    onWalletConnected && onWalletConnected(clientAndSigner);
  }, [suiStatus, clientAndSigner, onWalletConnected, getState]);
  const checkSigner = (0, import_react24.useCallback)((signer, type) => {
    log_default("useConnect", "trying to set clientAndSigner", type, signerFound.current, methodsChecked.current);
    if (signerFound.current)
      return;
    if (type) {
      methodsChecked.current[type] = true;
    }
    const allMethodsChecked = !Object.values(methodsChecked.current).includes(false);
    if (!signer && !allMethodsChecked)
      return;
    signerFound.current = !!signer;
    if (signer) {
      const _disconnect = signer?.disconnect;
      signer.disconnect = () => {
        _disconnect();
        disconnect();
      };
    }
    setClientAndSigner({client, signer});
  }, [client, disconnect]);
  (0, import_react24.useEffect)(() => {
    if (suiStatus === WalletKitCoreConnectionStatus.DISCONNECTED) {
      methodsChecked.current["extension"] = false;
      signerFound.current = false;
      setClientAndSigner((prev) => ({
        ...prev,
        signer: null
      }));
    }
  }, [suiStatus]);
  (0, import_react24.useEffect)(() => {
    if (!ethosConfiguration)
      return;
    log_default("mobile", "listening to mobile connection from EthosConnectProvider");
  }, [checkSigner, ethosConfiguration]);
  (0, import_react24.useEffect)(() => {
    if (!ethosConfiguration)
      return;
    const state = getState();
    log_default("useConnect", "Setting clientAndSigner extension", state);
    if (state.isConnecting || state.isError)
      return;
    checkSigner(suiSigner, "extension");
  }, [suiStatus, getState, checkSigner, suiSigner, ethosConfiguration]);
  (0, import_react24.useEffect)(() => {
    if (!ethosConfiguration)
      return;
    if (!ethosConfiguration.apiKey) {
      log_default("useConnect", "Setting null clientAndSigner ethos");
      checkSigner(null, "ethos");
      return;
    }
    const fetchEthosSigner = async () => {
      const signer = await lib_default.getEthosSigner({client, defaultChain: ethosConfiguration.chain ?? DEFAULT_CHAIN});
      log_default("useConnect", "Setting clientAndSigner ethos", signer);
      checkSigner(signer, "ethos");
    };
    fetchEthosSigner();
  }, [client, checkSigner, ethosConfiguration]);
  return {wallets: wallets2, clientAndSigner, connect, getState};
};
var useConnect_default = useConnect;

// src/hooks/useContext.ts
var DEFAULT_CONFIGURATION = {
  network: DEFAULT_NETWORK,
  chain: DEFAULT_CHAIN,
  walletAppUrl: "https://ethoswallet.xyz"
};
var useContext3 = ({configuration, onWalletConnected}) => {
  const [ethosConfiguration, setEthosConfiguration] = (0, import_react25.useState)({
    ...DEFAULT_CONFIGURATION,
    ...configuration
  });
  const [isModalOpen, setIsModalOpen] = (0, import_react25.useState)(false);
  const init = (0, import_react25.useCallback)((config) => {
    log_default("EthosConnectProvider", "EthosConnectProvider Configuration:", config);
    const fullConfiguration = {
      ...DEFAULT_CONFIGURATION,
      ...config
    };
    lib_default.initializeEthos(fullConfiguration);
    setEthosConfiguration((prev) => {
      if (JSON.stringify(fullConfiguration) !== JSON.stringify(prev)) {
        return fullConfiguration;
      } else {
        return prev;
      }
    });
  }, []);
  (0, import_react25.useEffect)(() => {
    lib_default.initializeEthos(ethosConfiguration);
  }, [ethosConfiguration]);
  (0, import_react25.useEffect)(() => {
    if (!configuration)
      return;
    if (JSON.stringify(ethosConfiguration) === JSON.stringify(configuration))
      return;
    init(configuration);
  }, [ethosConfiguration, configuration]);
  const _onWalletConnected = (0, import_react25.useCallback)((clientAndSigner2) => {
    setIsModalOpen(false);
    onWalletConnected && onWalletConnected(clientAndSigner2);
  }, [onWalletConnected]);
  const {
    wallets: wallets2,
    connect: selectWallet,
    clientAndSigner,
    getState
  } = useConnect_default(ethosConfiguration, _onWalletConnected);
  const {
    account: {address: address2, contents},
    altAccount,
    setAltAccount
  } = useAccount_default(clientAndSigner.signer, ethosConfiguration?.network ?? DEFAULT_NETWORK, ethosConfiguration?.pollingInterval, ethosConfiguration?.invalidPackages);
  const modal = (0, import_react25.useMemo)(() => {
    const openModal = () => {
      setIsModalOpen(true);
    };
    const closeModal = () => {
      setIsModalOpen(false);
    };
    return {
      isModalOpen,
      openModal,
      closeModal
    };
  }, [isModalOpen, setIsModalOpen]);
  const wallet = (0, import_react25.useMemo)(() => {
    const {client, signer} = clientAndSigner;
    const extensionState = getState();
    let status;
    if (signer?.type === "hosted") {
      status = EthosConnectStatus.Connected;
    } else if (extensionState.isConnecting) {
      status = EthosConnectStatus.Loading;
    } else if (client && extensionState.isConnected && signer) {
      status = EthosConnectStatus.Connected;
    } else {
      status = EthosConnectStatus.NoConnection;
    }
    const context = {
      status,
      wallets: wallets2.map((w) => ({
        ...w,
        name: w.name,
        icon: w.icon
      })),
      selectWallet,
      client,
      altAccount,
      setAltAccount
    };
    if (signer && address2) {
      context.wallet = {
        ...signer,
        address: address2,
        contents
      };
    }
    return context;
  }, [
    wallets2,
    selectWallet,
    address2,
    altAccount,
    setAltAccount,
    clientAndSigner,
    contents,
    ethosConfiguration
  ]);
  (0, import_react25.useEffect)(() => {
    if (isModalOpen) {
      document.getElementsByTagName("html").item(0)?.setAttribute("style", "overflow: hidden;");
    } else {
      document.getElementsByTagName("html").item(0)?.setAttribute("style", "");
    }
  }, [isModalOpen]);
  const value = (0, import_react25.useMemo)(() => ({
    wallet,
    modal,
    clientAndSigner
  }), [wallet, modal, clientAndSigner]);
  return {...value, ethosConfiguration, init};
};
var useContext_default = useContext3;

// src/components/EthosConnectProvider.tsx
var EthosConnectProvider = ({ethosConfiguration, onWalletConnected, connectMessage, dappName, dappIcon, children}) => {
  const context = useContext_default({configuration: ethosConfiguration || {}, onWalletConnected});
  return /* @__PURE__ */ import_react26.default.createElement(ConnectContext_default.Provider, {
    value: context
  }, children, /* @__PURE__ */ import_react26.default.createElement(SignInModal_default, {
    isOpen: context.modal?.isModalOpen || false,
    hideEmailSignIn: context.ethosConfiguration?.hideEmailSignIn || false,
    hideWalletSignIn: context.ethosConfiguration?.hideWalletSignIn || false,
    connectMessage,
    dappName,
    dappIcon,
    preferredWallets: ethosConfiguration?.preferredWallets
  }));
};
var EthosConnectProvider_default = EthosConnectProvider;

// src/components/styled/SignInButton.tsx
var import_react28 = __toModule(require("react"));

// src/components/headless/WorkingButton.tsx
var import_react27 = __toModule(require("react"));
var WorkingButton = (props) => {
  const {children, isWorking, workingComponent, ...reactProps} = props;
  return /* @__PURE__ */ import_react27.default.createElement("button", {
    ...reactProps
  }, isWorking ? workingComponent || /* @__PURE__ */ import_react27.default.createElement("span", {
    className: "block p-2"
  }, /* @__PURE__ */ import_react27.default.createElement(Loader_default, {
    width: 32
  })) : /* @__PURE__ */ import_react27.default.createElement(import_react27.default.Fragment, null, children));
};
var WorkingButton_default = WorkingButton;

// src/components/styled/SignInButton.tsx
var SignInButton = (props) => {
  const {children, onClick, externalContext, ...reactProps} = props;
  const {openModal} = externalContext?.modal || useModal_default();
  const _onClick = (0, import_react28.useCallback)((e) => {
    openModal();
    onClick && onClick(e);
  }, [openModal, onClick]);
  return /* @__PURE__ */ import_react28.default.createElement(import_react28.default.Fragment, null, /* @__PURE__ */ import_react28.default.createElement(WorkingButton_default, {
    onClick: _onClick,
    ...reactProps,
    style: buttonDefault(props.style)
  }, children || /* @__PURE__ */ import_react28.default.createElement(import_react28.default.Fragment, null, "Sign In")));
};
var SignInButton_default = SignInButton;
var buttonDefault = (providedStyles) => ({
  lineHeight: "21px",
  border: "none",
  cursor: "pointer",
  fontFamily: "inherit",
  fontSize: "14px",
  ...providedStyles || {}
});

// src/components/headless/HoverColorButton.tsx
var import_react29 = __toModule(require("react"));
var HoverColorButton = (props) => {
  const {hoverBackgroundColor, hoverChildren, children, style, ...workingButtonProps} = props;
  const [hover, setHover] = (0, import_react29.useState)(false);
  const onMouseEnter = (0, import_react29.useCallback)(() => {
    setHover(true);
  }, []);
  const onMouseLeave = (0, import_react29.useCallback)(() => {
    setHover(false);
  }, []);
  return /* @__PURE__ */ import_react29.default.createElement(WorkingButton_default, {
    onMouseEnter,
    onMouseLeave,
    style: {
      ...style,
      backgroundColor: hover ? hoverBackgroundColor || primaryColor : void 0,
      color: hover ? "white" : "black"
    },
    ...workingButtonProps
  }, hover ? hoverChildren : children);
};
var HoverColorButton_default = HoverColorButton;

// src/components/styled/AddressWidget.tsx
var import_react35 = __toModule(require("react"));

// src/lib/truncateMiddle.ts
var truncateMiddle = (text, length = 6) => text ? `${text.slice(0, length)}...${text.slice(length * -1)}` : "";
var truncateMiddle_default = truncateMiddle;

// src/components/svg/Sui.tsx
var import_react30 = __toModule(require("react"));
var Sui = ({width = 24, color = "#6EBCEE"}) => /* @__PURE__ */ import_react30.default.createElement("svg", {
  id: "SuiSvg",
  xmlns: "http://www.w3.org/2000/svg",
  width,
  height: width * (40 / 28),
  viewBox: "-1 0 28 40",
  style: {display: "block", verticalAlign: "middle"}
}, /* @__PURE__ */ import_react30.default.createElement("path", {
  d: "M1.8611,33.0541a13.6477,13.6477,0,0,0,23.7778,0,13.89,13.89,0,0,0,0-13.8909L15.1824.8368a1.6444,1.6444,0,0,0-2.8648,0L1.8611,19.1632A13.89,13.89,0,0,0,1.8611,33.0541ZM10.8044,9.5555,13.0338,5.648a.8222.8222,0,0,1,1.4324,0L23.043,20.68a10.8426,10.8426,0,0,1,.8873,8.8828,9.4254,9.4254,0,0,0-.4388-1.4586c-1.1847-3.0254-3.8634-5.36-7.9633-6.9393-2.8187-1.0819-4.618-2.6731-5.3491-4.73C9.2375,13.7848,10.221,10.8942,10.8044,9.5555ZM7.0028,16.2184,4.457,20.68a10.8569,10.8569,0,0,0,0,10.8582,10.6776,10.6776,0,0,0,16.1566,2.935,7.5061,7.5061,0,0,0,.0667-5.2913c-.87-2.1858-2.9646-3.9308-6.2252-5.1876-3.6857-1.4147-6.08-3.6233-7.1157-6.5625A9.297,9.297,0,0,1,7.0028,16.2184Z",
  style: {fill: color, fillRule: "evenodd"}
}));
var Sui_default = Sui;

// src/components/styled/CopyWalletAddressButton.tsx
var import_react32 = __toModule(require("react"));

// src/components/styled/MenuButton.tsx
var import_react31 = __toModule(require("react"));
var MenuButton = (props) => {
  return /* @__PURE__ */ import_react31.default.createElement(HoverColorButton_default, {
    ...props,
    style: button()
  });
};
var MenuButton_default = MenuButton;
var button = () => ({
  width: "100%",
  borderRadius: "12px",
  textAlign: "left",
  padding: "6px 12px",
  display: "flex",
  alignItems: "center",
  gap: "6px",
  border: "none",
  fontFamily: "inherit",
  cursor: "pointer"
});

// src/components/styled/CopyWalletAddressButton.tsx
var CopyWalletAddressButton = (props) => {
  const {externalContext, ...buttonProps} = props;
  const {wallet} = externalContext?.wallet || useWallet_default();
  const children = (0, import_react32.useCallback)((hover) => /* @__PURE__ */ import_react32.default.createElement(import_react32.default.Fragment, null, /* @__PURE__ */ import_react32.default.createElement("svg", {
    width: "18",
    height: "18",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ import_react32.default.createElement("path", {
    d: "M15.6657 3.88789C15.3991 2.94272 14.5305 2.25 13.5 2.25H10.5C9.46954 2.25 8.60087 2.94272 8.33426 3.88789M15.6657 3.88789C15.7206 4.0825 15.75 4.28782 15.75 4.5V4.5C15.75 4.91421 15.4142 5.25 15 5.25H9C8.58579 5.25 8.25 4.91421 8.25 4.5V4.5C8.25 4.28782 8.27937 4.0825 8.33426 3.88789M15.6657 3.88789C16.3119 3.93668 16.9545 3.99828 17.5933 4.07241C18.6939 4.20014 19.5 5.149 19.5 6.25699V19.5C19.5 20.7426 18.4926 21.75 17.25 21.75H6.75C5.50736 21.75 4.5 20.7426 4.5 19.5V6.25699C4.5 5.149 5.30608 4.20014 6.40668 4.07241C7.04547 3.99828 7.68808 3.93668 8.33426 3.88789",
    stroke: hover ? "white" : "black",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })), "Copy Wallet Address"), []);
  const onClick = (0, import_react32.useCallback)((e) => {
    const element = e.target;
    const innerHTML = element.innerHTML;
    element.innerHTML = "Copied!";
    navigator.clipboard.writeText(wallet?.address || "");
    setTimeout(() => {
      element.innerHTML = innerHTML;
    }, 1e3);
  }, [wallet]);
  return /* @__PURE__ */ import_react32.default.createElement(MenuButton_default, {
    ...buttonProps,
    onClick,
    hoverChildren: children(true)
  }, children(false));
};
var CopyWalletAddressButton_default = CopyWalletAddressButton;

// src/components/styled/WalletExplorerButton.tsx
var import_react33 = __toModule(require("react"));
var WalletExplorerButton = (props) => {
  const children = (0, import_react33.useCallback)((hover) => /* @__PURE__ */ import_react33.default.createElement(import_react33.default.Fragment, null, /* @__PURE__ */ import_react33.default.createElement("svg", {
    width: "18",
    height: "18",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ import_react33.default.createElement("path", {
    d: "M12 21C16.1926 21 19.7156 18.1332 20.7157 14.2529M12 21C7.80742 21 4.28442 18.1332 3.2843 14.2529M12 21C14.4853 21 16.5 16.9706 16.5 12C16.5 7.02944 14.4853 3 12 3M12 21C9.51472 21 7.5 16.9706 7.5 12C7.5 7.02944 9.51472 3 12 3M12 3C15.3652 3 18.299 4.84694 19.8431 7.58245M12 3C8.63481 3 5.70099 4.84694 4.15692 7.58245M19.8431 7.58245C17.7397 9.40039 14.9983 10.5 12 10.5C9.00172 10.5 6.26027 9.40039 4.15692 7.58245M19.8431 7.58245C20.5797 8.88743 21 10.3946 21 12C21 12.778 20.9013 13.5329 20.7157 14.2529M20.7157 14.2529C18.1334 15.6847 15.1619 16.5 12 16.5C8.8381 16.5 5.86662 15.6847 3.2843 14.2529M3.2843 14.2529C3.09871 13.5329 3 12.778 3 12C3 10.3946 3.42032 8.88743 4.15692 7.58245",
    stroke: hover ? "white" : "black",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })), "Wallet Explorer"), []);
  const onClick = (0, import_react33.useCallback)(() => {
    window.open("https://ethoswallet.xyz/dashboard", "_blank");
  }, []);
  return /* @__PURE__ */ import_react33.default.createElement(MenuButton_default, {
    ...props,
    onClick,
    hoverChildren: children(true)
  }, children(false));
};
var WalletExplorerButton_default = WalletExplorerButton;

// src/components/styled/LogoutButton.tsx
var import_react34 = __toModule(require("react"));
var LogoutButton = (props) => {
  const {externalContext, ...buttonProps} = props;
  const {wallet} = externalContext?.wallet || useWallet_default();
  const children = (0, import_react34.useCallback)((hover) => /* @__PURE__ */ import_react34.default.createElement(import_react34.default.Fragment, null, /* @__PURE__ */ import_react34.default.createElement("svg", {
    width: "18",
    height: "18",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ import_react34.default.createElement("path", {
    d: "M13.5 21V20.25V21ZM7.5 21V21.75V21ZM5.25 18.75H6H5.25ZM5.25 5.25H4.5H5.25ZM7.5 3V2.25V3ZM13.5 3V3.75V3ZM15.75 5.25L15 5.25V5.25H15.75ZM15 9C15 9.41421 15.3358 9.75 15.75 9.75C16.1642 9.75 16.5 9.41421 16.5 9H15ZM16.5 15C16.5 14.5858 16.1642 14.25 15.75 14.25C15.3358 14.25 15 14.5858 15 15H16.5ZM15.75 18.75H16.5H15.75ZM18.2197 14.4697C17.9268 14.7626 17.9268 15.2374 18.2197 15.5303C18.5126 15.8232 18.9874 15.8232 19.2803 15.5303L18.2197 14.4697ZM21.75 12L22.2803 12.5303C22.5732 12.2374 22.5732 11.7626 22.2803 11.4697L21.75 12ZM19.2803 8.46967C18.9874 8.17678 18.5126 8.17678 18.2197 8.46967C17.9268 8.76256 17.9268 9.23744 18.2197 9.53033L19.2803 8.46967ZM9 11.25C8.58579 11.25 8.25 11.5858 8.25 12C8.25 12.4142 8.58579 12.75 9 12.75V11.25ZM13.5 20.25H7.5V21.75H13.5V20.25ZM6 18.75L6 5.25H4.5L4.5 18.75H6ZM7.5 3.75L13.5 3.75V2.25L7.5 2.25V3.75ZM15 5.25V9H16.5V5.25H15ZM15 15V18.75H16.5V15H15ZM6 5.25C6 4.42157 6.67157 3.75 7.5 3.75V2.25C5.84315 2.25 4.5 3.59315 4.5 5.25H6ZM7.5 20.25C6.67157 20.25 6 19.5784 6 18.75H4.5C4.5 20.4069 5.84315 21.75 7.5 21.75V20.25ZM13.5 21.75C15.1569 21.75 16.5 20.4069 16.5 18.75H15C15 19.5784 14.3284 20.25 13.5 20.25V21.75ZM13.5 3.75C14.3284 3.75 15 4.42157 15 5.25L16.5 5.25C16.5 3.59315 15.1569 2.25 13.5 2.25V3.75ZM19.2803 15.5303L22.2803 12.5303L21.2197 11.4697L18.2197 14.4697L19.2803 15.5303ZM22.2803 11.4697L19.2803 8.46967L18.2197 9.53033L21.2197 12.5303L22.2803 11.4697ZM21.75 11.25L9 11.25V12.75L21.75 12.75V11.25Z",
    fill: hover ? "white" : "black"
  })), "Log Out"), []);
  return /* @__PURE__ */ import_react34.default.createElement(MenuButton_default, {
    ...buttonProps,
    onClick: wallet?.disconnect,
    hoverChildren: children(true)
  }, children(false));
};
var LogoutButton_default = LogoutButton;

// src/components/styled/AddressWidget.tsx
var import_react36 = __toModule(require("react"));

// src/enums/AddressWidgetButtons.ts
var AddressWidgetButtons;
(function(AddressWidgetButtons2) {
  AddressWidgetButtons2["CopyWalletAddress"] = "copy_wallet_address";
  AddressWidgetButtons2["WalletExplorer"] = "wallet_explorer";
  AddressWidgetButtons2["Logout"] = "logout";
})(AddressWidgetButtons || (AddressWidgetButtons = {}));

// src/components/styled/AddressWidget.tsx
var AddressWidget = ({
  includeMenu = true,
  buttonColor = primaryColor,
  extraButtons = [],
  excludeButtons = [],
  externalContext
}) => {
  const {wallet} = externalContext?.wallet || useWallet_default();
  const [showMenu, setShowMenu] = (0, import_react35.useState)(false);
  (0, import_react36.useEffect)(() => {
    if (!wallet) {
      setShowMenu(false);
    }
  }, [wallet]);
  const onMouseEnter = (0, import_react35.useCallback)(() => {
    if (!wallet)
      return;
    setShowMenu(true);
  }, [wallet]);
  const onMouseLeave = (0, import_react35.useCallback)(() => {
    if (!wallet)
      return;
    setShowMenu(false);
  }, [wallet]);
  return /* @__PURE__ */ import_react35.default.createElement("div", {
    style: container(),
    onMouseEnter,
    onMouseLeave
  }, /* @__PURE__ */ import_react35.default.createElement("div", {
    style: primary()
  }, /* @__PURE__ */ import_react35.default.createElement("div", null, /* @__PURE__ */ import_react35.default.createElement(Sui_default, {
    color: "#222532",
    width: 12
  })), wallet ? /* @__PURE__ */ import_react35.default.createElement(import_react35.default.Fragment, null, /* @__PURE__ */ import_react35.default.createElement("div", {
    style: sui()
  }, formatBalance(wallet.contents?.suiBalance), " ", "Sui"), /* @__PURE__ */ import_react35.default.createElement("div", {
    style: address()
  }, wallet.icon && /* @__PURE__ */ import_react35.default.createElement("img", {
    style: walletIcon(),
    src: wallet.icon
  }), truncateMiddle_default(wallet.address))) : /* @__PURE__ */ import_react35.default.createElement(SignInButton_default, {
    style: signIn(),
    externalContext
  })), includeMenu && showMenu && /* @__PURE__ */ import_react35.default.createElement("div", {
    style: menu()
  }, !excludeButtons.includes(AddressWidgetButtons.CopyWalletAddress) && /* @__PURE__ */ import_react35.default.createElement(CopyWalletAddressButton_default, {
    externalContext,
    hoverBackgroundColor: buttonColor
  }), !excludeButtons.includes(AddressWidgetButtons.WalletExplorer) && /* @__PURE__ */ import_react35.default.createElement(WalletExplorerButton_default, {
    hoverBackgroundColor: buttonColor
  }), extraButtons, !excludeButtons.includes(AddressWidgetButtons.Logout) && /* @__PURE__ */ import_react35.default.createElement(LogoutButton_default, {
    externalContext,
    hoverBackgroundColor: buttonColor
  })));
};
var AddressWidget_default = AddressWidget;
var container = () => ({
  position: "relative",
  backgroundColor: "white",
  padding: "6px 12px 6px 18px",
  boxShadow: "1px 1px 3px 1px #dfdfe0",
  borderRadius: "18px",
  fontSize: "14px",
  color: "black"
});
var primary = () => ({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  gap: "12px"
});
var sui = () => ({
  whiteSpace: "nowrap"
});
var address = () => ({
  borderRadius: "30px",
  backgroundColor: "#f2f1f0",
  padding: "6px 12px",
  display: "flex",
  alignItems: "center",
  gap: "6px"
});
var menu = () => ({
  display: "flex",
  flexDirection: "column",
  gap: "6px",
  padding: "12px 18px",
  position: "absolute",
  bottom: 0,
  left: "12px",
  right: "12px",
  transform: "translateY(100%)",
  boxShadow: "1px 1px 3px 1px #dfdfe0",
  borderBottomLeftRadius: "18px",
  borderBottomRightRadius: "18px",
  backgroundColor: "white",
  zIndex: "99"
});
var signIn = () => ({
  padding: "0 12px 0 0",
  background: "none",
  whiteSpace: "nowrap"
});
var walletIcon = () => ({
  width: "20px",
  height: "20px"
});

// src/lib/logout.ts
var logout = async (signer, fromWallet = false) => {
  log_default("logout", `-- Wallet ${fromWallet} --`, `-- Is Extension: ${signer?.type} --`, `-- Disconnect: ${!!signer?.disconnect} --`, "signer", signer);
  if (signer.type === "extension" || !fromWallet) {
    await signer.disconnect();
  } else {
    await signer.logout();
  }
};
var logout_default = logout;

// src/lib/preapprove.ts
var preapprove = async ({signer, preapproval}) => {
  return signer.requestPreapproval(preapproval);
};
var preapprove_default = preapprove;

// src/lib/signMessage.ts
var signMessage = async ({signer, message}) => {
  return signer.signMessage({message});
};
var signMessage_default = signMessage;

// src/lib/transact.ts
var transact = async ({
  signer,
  transactionInput
}) => {
  log_default("transact", "Starting transaction", signer, transactionInput);
  return signer.signAndExecuteTransactionBlock(transactionInput);
};
var transact_default = transact;

// src/lib/signTransactionBlock.ts
var signTransactionBlock = async ({
  signer,
  transactionInput
}) => {
  log_default("transact", "Starting transaction", signer, transactionInput);
  return signer.signTransactionBlock(transactionInput);
};
var signTransactionBlock_default = signTransactionBlock;

// src/lib/executeTransactionBlock.ts
var executeTransactionBlock = async ({
  signer,
  transactionInput
}) => {
  log_default("transact", "Starting transaction", signer, transactionInput);
  return signer.executeTransactionBlock(transactionInput);
};
var executeTransactionBlock_default = executeTransactionBlock;

// src/lib/checkForAssetType.ts
var checkForAssetType = async ({signer, wallet, type, cursor, options, filter}) => {
  let owner;
  if (wallet) {
    owner = wallet.address;
  } else if (signer) {
    owner = signer.currentAccount?.address;
  }
  if (!owner)
    return;
  const client = (signer ?? wallet)?.client;
  if (!client)
    return;
  let kioskAssets = [];
  if (!cursor) {
    const kioskTokens = await client.getOwnedObjects({
      owner,
      filter: {
        StructType: "0x95a441d389b07437d00dd07e0b6f05f513d7659b13fd7c5d3923c7d9d847199b::ob_kiosk::OwnerToken"
      },
      options: options ?? {
        showContent: true,
        showType: true
      },
      cursor
    });
    for (const kioskToken of kioskTokens.data) {
      if (kioskToken.data) {
        const kioskObjects = await getKioskObjects(client, kioskToken.data);
        for (const kioskObject of kioskObjects) {
          if (kioskObject.data && kioskObject.data?.type === type) {
            kioskAssets.push(kioskObject.data);
          }
        }
      }
    }
  }
  const assets = await client.getOwnedObjects({
    owner,
    filter: filter ?? {
      StructType: type ?? ""
    },
    options: options ?? {
      showContent: true,
      showDisplay: true
    },
    cursor
  });
  return {
    assets: (assets.data ?? []).map((a) => a.data).concat(kioskAssets),
    nextCursor: assets.nextCursor
  };
};
var checkForAssetType_default = checkForAssetType;

// src/lib/hideWallet.ts
var hideWallet = (signer) => {
  if (signer.type === SignerType.Extension)
    return;
  getIframe_default(false);
};
var hideWallet_default = hideWallet;

// src/lib/showWallet.ts
var showWallet = (signer) => {
  if (signer.type === SignerType.Extension)
    return;
  getIframe_default(true);
};
var showWallet_default = showWallet;

// src/lib/dripSui.ts
var import_faucet = __toModule(require_faucet());
var dripSui = async ({address: address2, networkName}) => {
  return (0, import_faucet.requestSuiFromFaucetV0)({
    host: (0, import_faucet.getFaucetHost)(networkName),
    recipient: address2
  });
};
var dripSui_default = dripSui;

// src/lib/nameService.ts
var import_client3 = __toModule(require_client2());
var getSuiName = async (address2, network) => {
  const client = new import_client3.SuiClient({url: network ?? DEFAULT_NETWORK});
  return client.resolveNameServiceNames({address: address2});
};
var getSuiAddress = async (name, network) => {
  const client = new import_client3.SuiClient({url: network ?? DEFAULT_NETWORK});
  return client.resolveNameServiceAddress({name});
};

// src/hooks/useClientAndSigner.ts
var import_react37 = __toModule(require("react"));
var useClientAndSigner = () => {
  const {clientAndSigner} = (0, import_react37.useContext)(ConnectContext_default);
  return clientAndSigner || {client: null, signer: null};
};
var useClientAndSigner_default = useClientAndSigner;

// src/hooks/useAddress.ts
var useAddress = () => {
  const {signer} = useClientAndSigner_default();
  return signer?.currentAccount?.address;
};
var useAddress_default = useAddress;

// src/hooks/useContents.ts
var import_react38 = __toModule(require("react"));
var useContents = () => {
  const contents = (0, import_react38.useContext)(ConnectContext_default).wallet?.wallet?.contents;
  return contents;
};
var useContents_default = useContents;

// src/components/DetachedEthosConnectProvider.tsx
var import_react39 = __toModule(require("react"));
var DetachedEthosConnectProvider = ({context, connectMessage, dappName, dappIcon, children}) => {
  return /* @__PURE__ */ import_react39.default.createElement(import_react39.default.Fragment, null, children, /* @__PURE__ */ import_react39.default.createElement(SignInModal_default, {
    isOpen: context.modal.isModalOpen,
    hideEmailSignIn: context.ethosConfiguration?.hideEmailSignIn || false,
    hideWalletSignIn: context.ethosConfiguration?.hideWalletSignIn || false,
    connectMessage,
    dappName,
    dappIcon,
    externalContext: context
  }));
};
var DetachedEthosConnectProvider_default = DetachedEthosConnectProvider;

// src/index.ts
var components = {
  AddressWidget: AddressWidget_default,
  MenuButton: MenuButton_default,
  headless: {
    HoverColorButton: HoverColorButton_default
  }
};
var enums = {
  AddressWidgetButtons
};
var ethos = {
  login: login_default,
  logout: logout_default,
  signMessage: signMessage_default,
  transact: transact_default,
  signTransactionBlock: signTransactionBlock_default,
  executeTransactionBlock: executeTransactionBlock_default,
  preapprove: preapprove_default,
  showWallet: showWallet_default,
  hideWallet: hideWallet_default,
  showSignInModal,
  hideSignInModal,
  useClientAndSigner: useClientAndSigner_default,
  useAddress: useAddress_default,
  useContents: useContents_default,
  useWallet: useWallet_default,
  useContext: useContext_default,
  getWalletContents: getWalletContents_default,
  checkForAssetType: checkForAssetType_default,
  dripSui: dripSui_default,
  getSuiName,
  getSuiAddress,
  formatBalance,
  truncateMiddle: truncateMiddle_default,
  ipfsConversion,
  components,
  enums
};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/*! store2 - v2.14.2 - 2022-07-18
* Copyright (c) 2022 Nathan Bubna; Licensed (MIT OR GPL-3.0) */
