/**
 * The superstate function. This is the function that you should use to create a superstate.
 *
 * @param initialState The initial state.
 * @returns Methods (`ISuperState`) to work with your state.
 */
export declare function superstate<S>(initialState: S): ISuperState<S>;
export interface ISuperState<S> extends ISuperStateDraftMethods<S> {
    /**
     * @returns The current value of the state.
     */
    now: () => S;
    /**
     * Mutates the value of `now`. If the input is `undefined`, it uses the `draft` value instead.
     *
     * It won't broadcast any changes if the previous `now` would be equal the new `now`.
     */
    set: ISetFn<S>;
    /**
     * Starts monitoring changes to the state.
     *
     * @param subscriber A function that will be called when `now` or `draft` changes (depends on `target`).
     * @param target Can be either `now` or `draft` (default: `now`)
     * @returns A function to unsubscribe.
     */
    subscribe: (subscriber: ISubscriber<S>, target?: 'draft' | 'now' | undefined) => IUnsubscribe;
    /**
     * Unsubscribes all `now` and `draft` subscribers.
     *
     * After you call this method, changes will no longer be
     * broadcasted.
     */
    unsubscribeAll: () => void;
    /**
     * Extends superstate with additional methods.
     *
     * Note: Currently only extensions that mutates the draft are supported.
     *
     * @param IExtension The extensions to add.
     * @returns The extended superstate.
     */
    extend: <E extends IExtensions<S>>(extensions: E) => ISuperState<S> & IExtensionMethods<S, E>;
    /**
     * Adds a middleware to superstate.
     */
    use: IUseFn<S>;
}
export interface ISuperStateDraftMethods<S> {
    /**
     * @retur The draft version of your state. May be `undefined` if no draft is available. To set the value of the draft, call `.set()`.
     */
    draft: IDraftFn<S>;
    /**
     * Overrides the value of `now` with the value of `draft`.
     *
     * If `draft` is `undefined`, nothing will happen.
     *
     * If `draft` is equals to `now`, nothing will happen either.
     */
    publish: () => ISuperState<S>;
    /**
     * Discards the draft, setting its value to `undefined`.
     * Upon calling this function, a draft broadcast will occur.
     */
    discard: IDiscardFn<S>;
    /**
     * Assigns the value passed via `input` to `draft`.
     *
     * @param input It can be a raw value or a function whose first and sole argument is the value of the previous `draft`. In case there is no previous draft, the first argument will be the previous value of `now`.
     * @param options.silent (default: `false`) Whether to broadcast the change.
     */
    sketch: ISketchFn<S>;
}
export declare type IExtensionPropsBag<S> = ISuperState<S>;
/**
 * The type of the draft.
 * Almost the same thing as the state,
 * except it can be `undefined`.
 */
export declare type IDraft<S> = S | undefined;
declare type IMutateInput<S> = ((prev: S) => S) | S;
declare type IMutateOptions = {
    /**
     * Whether to broadcast the change or not.
     *
     * `true`: broadcast the change,
     *
     * `false`: don't broadcast the change.
     */
    silent?: boolean;
};
declare type ISubscriber<S> = (newState: S) => void;
declare type IExtensionUserParams = any[];
declare type IExtensionAllParams<S> = [IExtensionPropsBag<S>, ...IExtensionUserParams];
declare type IExtension<S, O = void> = (...params: IExtensionAllParams<S>) => O;
declare type IExtensions<S> = Record<string, IExtension<S>>;
declare type IExtensionMethods<S, E extends IExtensions<S>> = {
    [key in keyof E]: (...params: DropFirst<Parameters<E[key]>>) => ReturnType<E[key]>;
};
declare type IUnsubscribe = () => void;
declare type ISketchFn<S> = (input: IMutateInput<S>, options?: IMutateOptions) => ISuperState<S>;
declare type ISetFn<S> = (input: IMutateInput<S>, options?: IMutateOptions) => ISuperState<S>;
declare type IDiscardFn<S> = () => ISuperState<S>;
declare type IDraftFn<S> = () => IDraft<S>;
declare type IUseFn<S> = (middlewares: IMiddleware<S>[]) => ISuperState<S>;
declare type DropFirst<T extends unknown[]> = T extends [any, ...infer U] ? U : never;
export declare type IMiddlewareInput<S = any> = ISuperState<S> & {
    eventType: IMiddlewareEventType;
};
declare type IMiddleware<S> = (input: IMiddlewareInput<S>) => void;
declare type IMiddlewareEventType = 'init' | 'before:set' | 'after:set' | 'before:sketch' | 'after:sketch' | 'before:publish' | 'after:publish' | 'before:change' | 'after:change' | 'before:discard' | 'after:discard' | 'before:broadcast:now' | 'after:broadcast:now' | 'before:broadcast:draft' | 'after:broadcast:draft';
export {};
